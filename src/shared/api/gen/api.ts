/* tslint:disable */
/* eslint-disable */
/**
 * Automodern
 *              FastAPI Docs.             # Инструкция по работе с security-token header             https://avada.teamwork.com/app/notebooks/364392             # VAT-номера:             SK4020458739 BE0550479651 BE0550479651 IE3668997OH IT00154189997             # Дебажные токены:             admin - для суперадмина             staff - для тестового сотрудника             client - для тестового клиента             agent - для тестового агента             supplier - для тестового поставщика             
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Accept language.
 * @export
 * @enum {string}
 */

export const AcceptLanguage = {
    En: 'en',
    Ru: 'ru',
    Sl: 'sl'
} as const;

export type AcceptLanguage = typeof AcceptLanguage[keyof typeof AcceptLanguage];


/**
 * Access and refresh token schema.
 * @export
 * @interface AccessRefreshTokensSchema
 */
export interface AccessRefreshTokensSchema {
    /**
     * 
     * @type {string}
     * @memberof AccessRefreshTokensSchema
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof AccessRefreshTokensSchema
     */
    'access': string;
}
/**
 * Bank account or cashbox complex schema.
 * @export
 * @interface AccountCashboxComplexSchema
 */
export interface AccountCashboxComplexSchema {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxComplexSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxComplexSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxComplexSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {SimpleCurrencySchema}
     * @memberof AccountCashboxComplexSchema
     */
    'currency': SimpleCurrencySchema;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxComplexSchema
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxComplexSchema
     */
    'availableBalance'?: number;
}
/**
 * Bank account or cashbox create schema.
 * @export
 * @interface AccountCashboxCreateSchema
 */
export interface AccountCashboxCreateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxCreateSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxCreateSchema
     */
    'isActive': boolean;
    /**
     * Name of the settlement account or cashbox. Must be unique within the names.
     * @type {string}
     * @memberof AccountCashboxCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxCreateSchema
     */
    'currencyId': number;
    /**
     * Name of the bank or magazine.
     * @type {string}
     * @memberof AccountCashboxCreateSchema
     */
    'placeName'?: string;
    /**
     * Address of the bank or magazine.
     * @type {string}
     * @memberof AccountCashboxCreateSchema
     */
    'address'?: string;
    /**
     * Name of the bank identification number, BIN.
     * @type {number}
     * @memberof AccountCashboxCreateSchema
     */
    'bankBin'?: number;
    /**
     * IBAN account number.
     * @type {string}
     * @memberof AccountCashboxCreateSchema
     */
    'iban'?: string;
    /**
     * Unique SWIFT code of the bank.
     * @type {string}
     * @memberof AccountCashboxCreateSchema
     */
    'swift'?: string;
    /**
     * Overdraft amount.
     * @type {number}
     * @memberof AccountCashboxCreateSchema
     */
    'overdraft'?: number;
}
/**
 * Bank account or cashbox detail schema.
 * @export
 * @interface AccountCashboxDetailSchema
 */
export interface AccountCashboxDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxDetailSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxDetailSchema
     */
    'placeName'?: string;
    /**
     * 
     * @type {BaseCurrencySchema}
     * @memberof AccountCashboxDetailSchema
     */
    'currency'?: BaseCurrencySchema;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxDetailSchema
     */
    'overdraft'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxDetailSchema
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxDetailSchema
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxDetailSchema
     */
    'bankBin'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxDetailSchema
     */
    'iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxDetailSchema
     */
    'swift'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Bank account or cashbox for payment order schema.
 * @export
 * @interface AccountCashboxForPaymentOrderSchema
 */
export interface AccountCashboxForPaymentOrderSchema {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxForPaymentOrderSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxForPaymentOrderSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxForPaymentOrderSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {SimpleCurrencySchema}
     * @memberof AccountCashboxForPaymentOrderSchema
     */
    'currency': SimpleCurrencySchema;
    /**
     * Required for bank account name. Optional for cashbox place name.
     * @type {string}
     * @memberof AccountCashboxForPaymentOrderSchema
     */
    'placeName'?: string;
}
/**
 * Bank account or cashbox list schema.
 * @export
 * @interface AccountCashboxListSchema
 */
export interface AccountCashboxListSchema {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxListSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxListSchema
     */
    'placeName'?: string;
    /**
     * 
     * @type {BaseCurrencySchema}
     * @memberof AccountCashboxListSchema
     */
    'currency'?: BaseCurrencySchema;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxListSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxListSchema
     */
    'overdraft'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxListSchema
     */
    'balance': number;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxListSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Bank account and cashbox params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const AccountCashboxQueryOrder = {
    Id: 'id',
    DateCreated: 'dateCreated',
    IsCashbox: 'isCashbox',
    PlaceName: 'placeName',
    Currency: 'currency',
    Name: 'name',
    Overdraft: 'overdraft',
    IsActive: 'isActive'
} as const;

export type AccountCashboxQueryOrder = typeof AccountCashboxQueryOrder[keyof typeof AccountCashboxQueryOrder];


/**
 * Account cashbox report currency schema.
 * @export
 * @interface AccountCashboxReportCurrencySchema
 */
export interface AccountCashboxReportCurrencySchema {
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxReportCurrencySchema
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportCurrencySchema
     */
    'totalBalanceStart': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportCurrencySchema
     */
    'totalBalanceEnd': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportCurrencySchema
     */
    'totalIncomeAmount': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportCurrencySchema
     */
    'totalExpenseAmount': number;
}
/**
 * Account cashbox report schema.
 * @export
 * @interface AccountCashboxReportLogSchema
 */
export interface AccountCashboxReportLogSchema {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportLogSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxReportLogSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxReportLogSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {SimpleCurrencySchema}
     * @memberof AccountCashboxReportLogSchema
     */
    'currency': SimpleCurrencySchema;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportLogSchema
     */
    'incomeAmount': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportLogSchema
     */
    'expenseAmount': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportLogSchema
     */
    'balanceStart': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportLogSchema
     */
    'balanceEnd': number;
}
/**
 * Account cashbox report page schema.
 * @export
 * @interface AccountCashboxReportPage
 */
export interface AccountCashboxReportPage {
    /**
     * 
     * @type {Array<AccountCashboxReportLogSchema>}
     * @memberof AccountCashboxReportPage
     */
    'items': Array<AccountCashboxReportLogSchema>;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof AccountCashboxReportPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof AccountCashboxReportPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof AccountCashboxReportPage
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<AccountCashboxReportCurrencySchema>}
     * @memberof AccountCashboxReportPage
     */
    'currencies'?: Array<AccountCashboxReportCurrencySchema>;
}
/**
 * Account cashbox query order enum.
 * @export
 * @enum {string}
 */

export const AccountCashboxReportQueryOrder = {
    Id: 'id',
    Name: 'name',
    Currency: 'currency',
    IsCashbox: 'isCashbox'
} as const;

export type AccountCashboxReportQueryOrder = typeof AccountCashboxReportQueryOrder[keyof typeof AccountCashboxReportQueryOrder];


/**
 * Bank account or cashbox simple schema.
 * @export
 * @interface AccountCashboxSimpleSchema
 */
export interface AccountCashboxSimpleSchema {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxSimpleSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxSimpleSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxSimpleSchema
     */
    'isCashbox': boolean;
}
/**
 * Bank account or cashbox update schema.
 * @export
 * @interface AccountCashboxUpdateSchema
 */
export interface AccountCashboxUpdateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxUpdateSchema
     */
    'isCashbox': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCashboxUpdateSchema
     */
    'isActive': boolean;
    /**
     * Name of the settlement account or cashbox. Must be unique within the names.
     * @type {string}
     * @memberof AccountCashboxUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxUpdateSchema
     */
    'currencyId'?: number;
    /**
     * Name of the bank or magazine.
     * @type {string}
     * @memberof AccountCashboxUpdateSchema
     */
    'placeName'?: string;
    /**
     * Address of the bank or magazine.
     * @type {string}
     * @memberof AccountCashboxUpdateSchema
     */
    'address'?: string;
    /**
     * Name of the bank identification number, BIN.
     * @type {number}
     * @memberof AccountCashboxUpdateSchema
     */
    'bankBin'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountCashboxUpdateSchema
     */
    'iban'?: string;
    /**
     * Unique SWIFT code of the bank.
     * @type {string}
     * @memberof AccountCashboxUpdateSchema
     */
    'swift'?: string;
    /**
     * Overdraft amount.
     * @type {number}
     * @memberof AccountCashboxUpdateSchema
     */
    'overdraft'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxUpdateSchema
     */
    'currentBalance'?: number;
}
/**
 * Schema for accounts and cashboxes page.
 * @export
 * @interface AccountsCashboxesPage
 */
export interface AccountsCashboxesPage {
    /**
     * 
     * @type {Array<AccountCashboxListSchema>}
     * @memberof AccountsCashboxesPage
     */
    'items': Array<AccountCashboxListSchema>;
    /**
     * 
     * @type {number}
     * @memberof AccountsCashboxesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof AccountsCashboxesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof AccountsCashboxesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof AccountsCashboxesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof AccountsCashboxesPage
     */
    'totalPages': number;
}
/**
 * Supplier additional invoice change schema.
 * @export
 * @interface AdditionalExpenseUpdateCommentsSchema
 */
export interface AdditionalExpenseUpdateCommentsSchema {
    /**
     * 
     * @type {Array<BaseNomenclatureAdditionalExpenseUpdateCommentSchema>}
     * @memberof AdditionalExpenseUpdateCommentsSchema
     */
    'additionalExpenses': Array<BaseNomenclatureAdditionalExpenseUpdateCommentSchema>;
}
/**
 * Agent client statistics for currencies schema.
 * @export
 * @interface AgentClientStatisticsCurrenciesSchema
 */
export interface AgentClientStatisticsCurrenciesSchema {
    /**
     * 
     * @type {Array<SimpleCurrencySchema>}
     * @memberof AgentClientStatisticsCurrenciesSchema
     */
    'currencies': Array<SimpleCurrencySchema>;
}
/**
 * Supplier debts and overpayments schema.
 * @export
 * @interface AgentClientStatisticsForCurrencySchema
 */
export interface AgentClientStatisticsForCurrencySchema {
    /**
     * 
     * @type {Array<DebtOrOverpaymentSchema>}
     * @memberof AgentClientStatisticsForCurrencySchema
     */
    'clientsPayments': Array<DebtOrOverpaymentSchema>;
    /**
     * 
     * @type {Array<DebtOrOverpaymentSchema>}
     * @memberof AgentClientStatisticsForCurrencySchema
     */
    'clientsDebts': Array<DebtOrOverpaymentSchema>;
}
/**
 * Agent contract termination schema.
 * @export
 * @interface AgentContractTerminationSchema
 */
export interface AgentContractTerminationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof AgentContractTerminationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof AgentContractTerminationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Create Agent schema.
 * @export
 * @interface AgentCreateSchema
 */
export interface AgentCreateSchema {
    /**
     * Name
     * @type {string}
     * @memberof AgentCreateSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof AgentCreateSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AgentCreateSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof AgentCreateSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentCreateSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof AgentCreateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof AgentCreateSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * Additional user locations
     * @type {Array<UserLocationCreateSchema>}
     * @memberof AgentCreateSchema
     */
    'additionalLocations'?: Array<UserLocationCreateSchema>;
    /**
     * Country id
     * @type {number}
     * @memberof AgentCreateSchema
     */
    'countryId': number;
    /**
     * Sites
     * @type {Array<UserSiteCreateSchema>}
     * @memberof AgentCreateSchema
     */
    'sites'?: Array<UserSiteCreateSchema>;
    /**
     * 
     * @type {string}
     * @memberof AgentCreateSchema
     */
    'agentReferralCode': string;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof AgentCreateSchema
     */
    'vatNumber'?: string;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof AgentCreateSchema
     */
    'isVatPayer': boolean;
    /**
     * Currencies ids to add to user
     * @type {Array<AgentCurrencyCreateSchema>}
     * @memberof AgentCreateSchema
     */
    'userCurrencies': Array<AgentCurrencyCreateSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof AgentCreateSchema
     */
    'agentMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactBaseSchema>}
     * @memberof AgentCreateSchema
     */
    'agentAdditionalContacts'?: Array<UserAdditionalContactBaseSchema>;
}
/**
 * Agent currency schema.
 * @export
 * @interface AgentCurrencyCreateSchema
 */
export interface AgentCurrencyCreateSchema {
    /**
     * Currency id
     * @type {number}
     * @memberof AgentCurrencyCreateSchema
     */
    'currencyId': number;
}
/**
 * Agent currency update formset schema.
 * @export
 * @interface AgentCurrencyFormsetSchema
 */
export interface AgentCurrencyFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof AgentCurrencyFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AgentCurrencyFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentCurrencyFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * Currency id
     * @type {number}
     * @memberof AgentCurrencyFormsetSchema
     */
    'currencyId': number;
}
/**
 * Agent deactivation schema.
 * @export
 * @interface AgentDeactivationSchema
 */
export interface AgentDeactivationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof AgentDeactivationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof AgentDeactivationSchema
     */
    'cancellationReasonId'?: number;
    /**
     * 
     * @type {ChangeUnclosedDocumentResponsibleListSchema}
     * @memberof AgentDeactivationSchema
     */
    'unclosedDocuments': ChangeUnclosedDocumentResponsibleListSchema;
    /**
     * Staff user automatic activation date. If not specified, staff should be activated manually.
     * @type {string}
     * @memberof AgentDeactivationSchema
     */
    'autoActivateDate'?: string;
}
/**
 * Agent full info schema.
 * @export
 * @interface AgentFullInfoSchema
 */
export interface AgentFullInfoSchema {
    /**
     * Name
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentFullInfoSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof AgentFullInfoSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof AgentFullInfoSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof AgentFullInfoSchema
     */
    'isVatPayer': boolean;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'avatar'?: string;
    /**
     * Additional user locations
     * @type {Array<UserLocationReadSchema>}
     * @memberof AgentFullInfoSchema
     */
    'additionalLocations': Array<UserLocationReadSchema>;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof AgentFullInfoSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * Sites
     * @type {Array<UserSiteReadSchema>}
     * @memberof AgentFullInfoSchema
     */
    'sites': Array<UserSiteReadSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof AgentFullInfoSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentFullInfoSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentFullInfoSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentFullInfoSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof AgentFullInfoSchema
     */
    'agentReferralCode': string;
    /**
     * 
     * @type {AgentStatuses}
     * @memberof AgentFullInfoSchema
     */
    'agentStatus': AgentStatuses;
    /**
     * 
     * @type {Array<UserCurrencyReadSchema>}
     * @memberof AgentFullInfoSchema
     */
    'userCurrencies': Array<UserCurrencyReadSchema>;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof AgentFullInfoSchema
     */
    'agentMainContact': UserMainContactBaseReadSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof AgentFullInfoSchema
     */
    'agentAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
    /**
     * 
     * @type {number}
     * @memberof AgentFullInfoSchema
     */
    'notFinishedClientsCount': number;
    /**
     * 
     * @type {number}
     * @memberof AgentFullInfoSchema
     */
    'notesCount': number;
    /**
     * 
     * @type {number}
     * @memberof AgentFullInfoSchema
     */
    'unreadChatMessagesCount': number;
}
/**
 * Agent labels query-filter for agent list.
 * @export
 * @enum {string}
 */

export const AgentLabels = {
    Supplier: 'is_supplier',
    Client: 'is_client'
} as const;

export type AgentLabels = typeof AgentLabels[keyof typeof AgentLabels];


/**
 * Agent list schema.
 * @export
 * @interface AgentListSchema
 */
export interface AgentListSchema {
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof AgentListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof AgentListSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentListSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentListSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentListSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {CountrySchema}
     * @memberof AgentListSchema
     */
    'country': CountrySchema;
    /**
     * 
     * @type {string}
     * @memberof AgentListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof AgentListSchema
     */
    'agentMainContact': UserMainContactBaseReadSchema;
    /**
     * 
     * @type {AgentStatuses}
     * @memberof AgentListSchema
     */
    'agentStatus': AgentStatuses;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof AgentListSchema
     */
    'agentAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
    /**
     * 
     * @type {number}
     * @memberof AgentListSchema
     */
    'clientsCount': number;
}
/**
 * Agent page schema.
 * @export
 * @interface AgentPage
 */
export interface AgentPage {
    /**
     * 
     * @type {Array<AgentListSchema>}
     * @memberof AgentPage
     */
    'items': Array<AgentListSchema>;
    /**
     * 
     * @type {number}
     * @memberof AgentPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof AgentPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof AgentPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof AgentPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof AgentPage
     */
    'totalPages': number;
}
/**
 * Agent permissions schema.
 * @export
 * @interface AgentPermissionsSchema
 */
export interface AgentPermissionsSchema {
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentChangePriceType': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewClients': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentChangeClients': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentChangeClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewNomenclatureCost': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentChangeClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentChangeClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentPostClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentCancelClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewOtherAgentClientAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewOtherAgentClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewOtherAgentClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewOtherAgentClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewOtherAgentClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewOtherAgentClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentPermissionsSchema
     */
    'agentViewSetAsPersonalAgent': boolean;
}
/**
 * Agent query order choices.
 * @export
 * @enum {string}
 */

export const AgentQueryOrder = {
    DateCreated: 'dateCreated'
} as const;

export type AgentQueryOrder = typeof AgentQueryOrder[keyof typeof AgentQueryOrder];


/**
 * AgentSchema schema.
 * @export
 * @interface AgentSchema
 */
export interface AgentSchema {
    /**
     * Name
     * @type {string}
     * @memberof AgentSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof AgentSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AgentSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof AgentSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof AgentSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof AgentSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof AgentSchema
     */
    'isVatPayer': boolean;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof AgentSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AgentSchema
     */
    'avatar'?: string;
    /**
     * Additional user locations
     * @type {Array<UserLocationReadSchema>}
     * @memberof AgentSchema
     */
    'additionalLocations': Array<UserLocationReadSchema>;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof AgentSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * Sites
     * @type {Array<UserSiteReadSchema>}
     * @memberof AgentSchema
     */
    'sites': Array<UserSiteReadSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof AgentSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AgentSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof AgentSchema
     */
    'agentReferralCode': string;
    /**
     * 
     * @type {AgentStatuses}
     * @memberof AgentSchema
     */
    'agentStatus': AgentStatuses;
    /**
     * 
     * @type {Array<UserCurrencyReadSchema>}
     * @memberof AgentSchema
     */
    'userCurrencies': Array<UserCurrencyReadSchema>;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof AgentSchema
     */
    'agentMainContact': UserMainContactBaseReadSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof AgentSchema
     */
    'agentAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
}
/**
 * Agent simple page schema.
 * @export
 * @interface AgentSimplePage
 */
export interface AgentSimplePage {
    /**
     * 
     * @type {Array<SimpleUserSchema>}
     * @memberof AgentSimplePage
     */
    'items': Array<SimpleUserSchema>;
    /**
     * 
     * @type {number}
     * @memberof AgentSimplePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof AgentSimplePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof AgentSimplePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof AgentSimplePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof AgentSimplePage
     */
    'totalPages': number;
}
/**
 * Agent statuses choices.
 * @export
 * @enum {string}
 */

export const AgentStatuses = {
    Active: 'active',
    Inactive: 'inactive',
    InProcessing: 'in_processing',
    Terminated: 'terminated'
} as const;

export type AgentStatuses = typeof AgentStatuses[keyof typeof AgentStatuses];


/**
 * Supplier turn schema.
 * @export
 * @interface AgentTurnSchema
 */
export interface AgentTurnSchema {
    /**
     * 
     * @type {string}
     * @memberof AgentTurnSchema
     */
    'agentReferralCode': string;
    /**
     * Currencies ids to add to user
     * @type {Array<AgentCurrencyFormsetSchema>}
     * @memberof AgentTurnSchema
     */
    'userCurrencies': Array<AgentCurrencyFormsetSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof AgentTurnSchema
     */
    'agentMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactFormsetSchema>}
     * @memberof AgentTurnSchema
     */
    'agentAdditionalContacts'?: Array<UserAdditionalContactFormsetSchema>;
}
/**
 * Agent activate schema.
 * @export
 * @interface AgentUpdateEmailSchema
 */
export interface AgentUpdateEmailSchema {
    /**
     * Email
     * @type {string}
     * @memberof AgentUpdateEmailSchema
     */
    'email': string;
}
/**
 * Agent update phone schema.
 * @export
 * @interface AgentUpdatePhoneSchema
 */
export interface AgentUpdatePhoneSchema {
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AgentUpdatePhoneSchema
     */
    'phone': string;
}
/**
 * Create Agent schema.
 * @export
 * @interface AgentUpdateSchema
 */
export interface AgentUpdateSchema {
    /**
     * Name
     * @type {string}
     * @memberof AgentUpdateSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof AgentUpdateSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AgentUpdateSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof AgentUpdateSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentUpdateSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof AgentUpdateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof AgentUpdateSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * Additional user locations
     * @type {Array<UserLocationFormsetSchema>}
     * @memberof AgentUpdateSchema
     */
    'additionalLocations'?: Array<UserLocationFormsetSchema>;
    /**
     * Country id
     * @type {number}
     * @memberof AgentUpdateSchema
     */
    'countryId': number;
    /**
     * Sites
     * @type {Array<UserSiteFormsetSchema>}
     * @memberof AgentUpdateSchema
     */
    'sites'?: Array<UserSiteFormsetSchema>;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateSchema
     */
    'agentReferralCode': string;
    /**
     * Currencies ids to add to user
     * @type {Array<AgentCurrencyFormsetSchema>}
     * @memberof AgentUpdateSchema
     */
    'userCurrencies': Array<AgentCurrencyFormsetSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof AgentUpdateSchema
     */
    'agentMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactFormsetSchema>}
     * @memberof AgentUpdateSchema
     */
    'agentAdditionalContacts'?: Array<UserAdditionalContactFormsetSchema>;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof AgentUpdateSchema
     */
    'vatNumber'?: string;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof AgentUpdateSchema
     */
    'isVatPayer': boolean;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AllDocumentStatuses = {
    Ordering: 'ordering',
    Created: 'created',
    InProgress: 'in_progress',
    Completed: 'completed',
    Cancelled: 'cancelled',
    SubmittedForPayment: 'submitted_for_payment',
    PartiallyPaid: 'partially_paid',
    Paid: 'paid',
    Deleted: 'deleted',
    Conducted: 'conducted',
    InProcessing: 'in_processing',
    CreatedByClient: 'created_by_client',
    CreatedBySupplier: 'created_by_supplier',
    CreatedByAgent: 'created_by_agent',
    CreatedByStaff: 'created_by_staff'
} as const;

export type AllDocumentStatuses = typeof AllDocumentStatuses[keyof typeof AllDocumentStatuses];


/**
 * All document type choices.
 * @export
 * @enum {string}
 */

export const AllDocumentTypes = {
    ClientOrder: 'client_order',
    SupplierOrder: 'supplier_order',
    ClientProforma: 'client_proforma',
    SupplierProforma: 'supplier_proforma',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return',
    IncomingPaymentOrder: 'incoming_payment_order',
    OutgoingPaymentOrder: 'outgoing_payment_order',
    IncomingCashOrder: 'incoming_cash_order',
    OutgoingCashOrder: 'outgoing_cash_order',
    Compensation: 'compensation'
} as const;

export type AllDocumentTypes = typeof AllDocumentTypes[keyof typeof AllDocumentTypes];


/**
 * Allocated invoice schema for Payment Orders and Compensations.
 * @export
 * @interface AllocatedBaseInvoice
 */
export interface AllocatedBaseInvoice {
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof AllocatedBaseInvoice
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {string}
     * @memberof AllocatedBaseInvoice
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AllocatedBaseInvoice
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof AllocatedBaseInvoice
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof AllocatedBaseInvoice
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof AllocatedBaseInvoice
     */
    'dateCreated': string;
    /**
     * Document number.
     * @type {string}
     * @memberof AllocatedBaseInvoice
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof AllocatedBaseInvoice
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof AllocatedBaseInvoice
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof AllocatedBaseInvoice
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof AllocatedBaseInvoice
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof AllocatedBaseInvoice
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatedBaseInvoice
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatedBaseInvoice
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {BaseOrderForFinancesSchema}
     * @memberof AllocatedBaseInvoice
     */
    'order': BaseOrderForFinancesSchema;
}
/**
 * AnalyticsCategory query order.
 * @export
 * @enum {string}
 */

export const AnalyticsCategoryQueryOrder = {
    Id: 'id',
    Name: 'name',
    DateCreated: 'dateCreated',
    Status: 'status',
    Group: 'group'
} as const;

export type AnalyticsCategoryQueryOrder = typeof AnalyticsCategoryQueryOrder[keyof typeof AnalyticsCategoryQueryOrder];


/**
 * Activity kind choices.
 * @export
 * @enum {string}
 */

export const AnalyticsItemActivityKinds = {
    Operating: 'operating',
    Financial: 'financial',
    Investments: 'investments'
} as const;

export type AnalyticsItemActivityKinds = typeof AnalyticsItemActivityKinds[keyof typeof AnalyticsItemActivityKinds];


/**
 * AnalyticsItem query order.
 * @export
 * @enum {string}
 */

export const AnalyticsItemQueryOrder = {
    Id: 'id',
    Name: 'name',
    DateCreated: 'dateCreated',
    Type: 'type',
    Category: 'category',
    ActivityKind: 'activityKind',
    Status: 'status'
} as const;

export type AnalyticsItemQueryOrder = typeof AnalyticsItemQueryOrder[keyof typeof AnalyticsItemQueryOrder];


/**
 * Item type choices.
 * @export
 * @enum {string}
 */

export const AnalyticsItemTypes = {
    Constant: 'constant',
    Variable: 'variable',
    NorBoth: 'nor_both'
} as const;

export type AnalyticsItemTypes = typeof AnalyticsItemTypes[keyof typeof AnalyticsItemTypes];


/**
 * Schema for history log page.
 * @export
 * @interface AuthLogPage
 */
export interface AuthLogPage {
    /**
     * 
     * @type {Array<AuthLogSchema>}
     * @memberof AuthLogPage
     */
    'items': Array<AuthLogSchema>;
    /**
     * 
     * @type {number}
     * @memberof AuthLogPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof AuthLogPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof AuthLogPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof AuthLogPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof AuthLogPage
     */
    'totalPages': number;
}
/**
 * AuthLog schema.
 * @export
 * @interface AuthLogSchema
 */
export interface AuthLogSchema {
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'userIp': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'device': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'browser': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'region': string;
    /**
     * 
     * @type {AuthLogType}
     * @memberof AuthLogSchema
     */
    'type': AuthLogType;
    /**
     * 
     * @type {string}
     * @memberof AuthLogSchema
     */
    'dateCreated': string;
}
/**
 * Auth log type.
 * @export
 * @enum {string}
 */

export const AuthLogType = {
    Login: 'login',
    Logout: 'logout'
} as const;

export type AuthLogType = typeof AuthLogType[keyof typeof AuthLogType];


/**
 * AutoModernRequisite list schema.
 * @export
 * @interface AutoModernRequisiteListSchema
 */
export interface AutoModernRequisiteListSchema {
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'nameShort'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'addressLegal'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'addressMailing'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'registrationNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'swift'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'director'?: string;
    /**
     * 
     * @type {RequisiteLanguages}
     * @memberof AutoModernRequisiteListSchema
     */
    'language': RequisiteLanguages;
    /**
     * 
     * @type {number}
     * @memberof AutoModernRequisiteListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteListSchema
     */
    'dateCreated': string;
}
/**
 * AutoModernRequisite multiple update schema.
 * @export
 * @interface AutoModernRequisiteMultipleUpdateSchema
 */
export interface AutoModernRequisiteMultipleUpdateSchema {
    /**
     * 
     * @type {Array<AutoModernRequisiteUpdateSchema>}
     * @memberof AutoModernRequisiteMultipleUpdateSchema
     */
    'requisites': Array<AutoModernRequisiteUpdateSchema>;
}
/**
 * AutoModernRequisite update schema.
 * @export
 * @interface AutoModernRequisiteUpdateSchema
 */
export interface AutoModernRequisiteUpdateSchema {
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'nameShort'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'addressLegal'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'addressMailing'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'registrationNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'swift'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'director'?: string;
    /**
     * 
     * @type {RequisiteLanguages}
     * @memberof AutoModernRequisiteUpdateSchema
     */
    'language': RequisiteLanguages;
}
/**
 * Brand schema.
 * @export
 * @interface BaseBrandSchema
 */
export interface BaseBrandSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseBrandSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseBrandSchema
     */
    'name': string;
}
/**
 * Base deactivate schema.
 * @export
 * @interface BaseCancellationSchema
 */
export interface BaseCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof BaseCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof BaseCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Base compensation invoice detail schema.
 * @export
 * @interface BaseCompensationInvoiceDetailSchema
 */
export interface BaseCompensationInvoiceDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseCompensationInvoiceDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {AllocatedBaseInvoice}
     * @memberof BaseCompensationInvoiceDetailSchema
     */
    'invoice': AllocatedBaseInvoice;
    /**
     * 
     * @type {number}
     * @memberof BaseCompensationInvoiceDetailSchema
     */
    'oldSumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseCompensationInvoiceDetailSchema
     */
    'oldSumToPay'?: number;
}
/**
 * Base compensation product return detail schema.
 * @export
 * @interface BaseCompensationProductReturnDetailSchema
 */
export interface BaseCompensationProductReturnDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseCompensationProductReturnDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {BaseProductReturnSchemaForCompensation}
     * @memberof BaseCompensationProductReturnDetailSchema
     */
    'productReturn': BaseProductReturnSchemaForCompensation;
    /**
     * 
     * @type {number}
     * @memberof BaseCompensationProductReturnDetailSchema
     */
    'oldSumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseCompensationProductReturnDetailSchema
     */
    'oldSumToPay'?: number;
}
/**
 * Base country schema.
 * @export
 * @interface BaseCountrySchema
 */
export interface BaseCountrySchema {
    /**
     * 
     * @type {number}
     * @memberof BaseCountrySchema
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseCountrySchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseCountrySchema
     */
    'phoneCode': string;
    /**
     * 
     * @type {string}
     * @memberof BaseCountrySchema
     */
    'flag': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseCountrySchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseCountrySchema
     */
    'isEu': boolean;
}
/**
 * Base currency schema.
 * @export
 * @interface BaseCurrencySchema
 */
export interface BaseCurrencySchema {
    /**
     * 
     * @type {number}
     * @memberof BaseCurrencySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseCurrencySchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseCurrencySchema
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof BaseCurrencySchema
     */
    'rate': number;
}
/**
 * Base document schema for payment order.
 * @export
 * @interface BaseDocumentListSchema
 */
export interface BaseDocumentListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof BaseDocumentListSchema
     */
    'documentNumber': string;
    /**
     * Document ID. Only conducted documents with debt.
     * @type {number}
     * @memberof BaseDocumentListSchema
     */
    'id': number;
    /**
     * Document date created.
     * @type {string}
     * @memberof BaseDocumentListSchema
     */
    'dateCreated': string;
    /**
     * Document type.
     * @type {PaymentOrderBaseDocumentTypes}
     * @memberof BaseDocumentListSchema
     */
    'type': PaymentOrderBaseDocumentTypes;
}
/**
 * Base document schema.
 * @export
 * @interface BaseDocumentSchema
 */
export interface BaseDocumentSchema {
    /**
     * Document ID. Only conducted documents with debt.
     * @type {number}
     * @memberof BaseDocumentSchema
     */
    'id': number;
}
/**
 * Base financial analysis Item schema.
 * @export
 * @interface BaseFinancialAnalysisItemSchema
 */
export interface BaseFinancialAnalysisItemSchema {
    /**
     * Financial analysis Item name
     * @type {string}
     * @memberof BaseFinancialAnalysisItemSchema
     */
    'name': string;
    /**
     * Comment
     * @type {string}
     * @memberof BaseFinancialAnalysisItemSchema
     */
    'comment': string;
    /**
     * Item type
     * @type {AnalyticsItemTypes}
     * @memberof BaseFinancialAnalysisItemSchema
     */
    'type': AnalyticsItemTypes;
    /**
     * Activity kind
     * @type {AnalyticsItemActivityKinds}
     * @memberof BaseFinancialAnalysisItemSchema
     */
    'activityKind': AnalyticsItemActivityKinds;
    /**
     * Is active
     * @type {boolean}
     * @memberof BaseFinancialAnalysisItemSchema
     */
    'isActive': boolean;
}
/**
 * Label schema for client invoice.
 * @export
 * @interface BaseInvoiceLabelSchema
 */
export interface BaseInvoiceLabelSchema {
    /**
     * 
     * @type {boolean}
     * @memberof BaseInvoiceLabelSchema
     */
    'hasProductPartialReturn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseInvoiceLabelSchema
     */
    'hasProductFullReturn': boolean;
}
/**
 * Base invoice payment create schema.
 * @export
 * @interface BaseInvoicePaymentChangeSchema
 */
export interface BaseInvoicePaymentChangeSchema {
    /**
     * Allocated payment sum for invoice.
     * @type {number}
     * @memberof BaseInvoicePaymentChangeSchema
     */
    'sum': number;
    /**
     * Client/supplier invoice id.
     * @type {number}
     * @memberof BaseInvoicePaymentChangeSchema
     */
    'invoiceId': number;
}
/**
 * Base invoice payment schema.
 * @export
 * @interface BaseInvoicePaymentSchema
 */
export interface BaseInvoicePaymentSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseInvoicePaymentSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof BaseInvoicePaymentSchema
     */
    'sum': number;
    /**
     * 
     * @type {AllocatedBaseInvoice}
     * @memberof BaseInvoicePaymentSchema
     */
    'invoice': AllocatedBaseInvoice;
}
/**
 * BaseInvoiceQueryOrder model.
 * @export
 * @enum {string}
 */

export const BaseInvoiceQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    DateConduction: 'dateConduction',
    SumWithVat: 'sumWithVat',
    SumPaid: 'sumPaid',
    SumToPay: 'sumToPay'
} as const;

export type BaseInvoiceQueryOrder = typeof BaseInvoiceQueryOrder[keyof typeof BaseInvoiceQueryOrder];


/**
 * Base nomenclature additional expense update comment schema.
 * @export
 * @interface BaseNomenclatureAdditionalExpenseUpdateCommentSchema
 */
export interface BaseNomenclatureAdditionalExpenseUpdateCommentSchema {
    /**
     * Client nomenclature additional expense.
     * @type {number}
     * @memberof BaseNomenclatureAdditionalExpenseUpdateCommentSchema
     */
    'id': number;
    /**
     * Comment field
     * @type {string}
     * @memberof BaseNomenclatureAdditionalExpenseUpdateCommentSchema
     */
    'comment'?: string;
}
/**
 * Base nomenclature category schema.
 * @export
 * @interface BaseNomenclatureCategorySchema
 */
export interface BaseNomenclatureCategorySchema {
    /**
     * 
     * @type {number}
     * @memberof BaseNomenclatureCategorySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseNomenclatureCategorySchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseNomenclatureCategorySchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseNomenclatureCategorySchema
     */
    'dateCreated': string;
}
/**
 * Document page schema.
 * @export
 * @interface BaseNomenclatureReportPageSchema
 */
export interface BaseNomenclatureReportPageSchema {
    /**
     * 
     * @type {Array<any>}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'items': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'stockEndTotal': number;
    /**
     * 
     * @type {number}
     * @memberof BaseNomenclatureReportPageSchema
     */
    'sumCostPriceEndTotal': number;
}
/**
 * Base nomenclature subcategory schema.
 * @export
 * @interface BaseNomenclatureSubcategorySchema
 */
export interface BaseNomenclatureSubcategorySchema {
    /**
     * 
     * @type {number}
     * @memberof BaseNomenclatureSubcategorySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseNomenclatureSubcategorySchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseNomenclatureSubcategorySchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseNomenclatureSubcategorySchema
     */
    'isActive': boolean;
}
/**
 * Base order for additional expense schema.
 * @export
 * @interface BaseOrderForAdditionalExpenseSchema
 */
export interface BaseOrderForAdditionalExpenseSchema {
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof BaseOrderForAdditionalExpenseSchema
     */
    'user': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof BaseOrderForAdditionalExpenseSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderForAdditionalExpenseSchema
     */
    'rate': number;
}
/**
 * Base order for finances schema.
 * @export
 * @interface BaseOrderForFinancesSchema
 */
export interface BaseOrderForFinancesSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof BaseOrderForFinancesSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof BaseOrderForFinancesSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof BaseOrderForFinancesSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof BaseOrderForFinancesSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderForFinancesSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseOrderForFinancesSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof BaseOrderForFinancesSchema
     */
    'contract'?: SimpleContractSchema;
}
/**
 * Base order nomenclature detail schema.
 * @export
 * @interface BaseOrderNomenclatureForDocumentSchema
 */
export interface BaseOrderNomenclatureForDocumentSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureForDocumentSchema
     */
    'availableOrderQuantityForInvoices'?: number;
}
/**
 * Base supplier invoice nomenclature schema.
 * @export
 * @interface BaseOrderNomenclatureSchema
 */
export interface BaseOrderNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseOrderNomenclatureSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof BaseOrderNomenclatureSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
}
/**
 * BaseOrderQueryOrder model.
 * @export
 * @enum {string}
 */

export const BaseOrderQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    SumWithVat: 'sumWithVat',
    SumPaidByConductedInvoices: 'sumPaidByConductedInvoices',
    SumPaid: 'sumPaid',
    SumToPay: 'sumToPay'
} as const;

export type BaseOrderQueryOrder = typeof BaseOrderQueryOrder[keyof typeof BaseOrderQueryOrder];


/**
 * Base user schema for a client/supplier order list.
 * @export
 * @interface BaseOrderUserSchema
 */
export interface BaseOrderUserSchema {
    /**
     * Name
     * @type {string}
     * @memberof BaseOrderUserSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseOrderUserSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseOrderUserSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof BaseOrderUserSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof BaseOrderUserSchema
     */
    'counterAgentKind': CounterAgentKinds;
}
/**
 * BaseNomenclatureProductReturn schema.
 * @export
 * @interface BaseProductReturnNomenclatureSchema
 */
export interface BaseProductReturnNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseProductReturnNomenclatureSchema
     */
    'invoiceNomenclatureId': number;
    /**
     * 
     * @type {number}
     * @memberof BaseProductReturnNomenclatureSchema
     */
    'quantity': number;
}
/**
 * Base product return schema for compensation.
 * @export
 * @interface BaseProductReturnSchemaForCompensation
 */
export interface BaseProductReturnSchemaForCompensation {
    /**
     * 
     * @type {number}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'dateCreated': string;
    /**
     * 
     * @type {InvoiceSchemaForCompensationProductReturn}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'invoice': InvoiceSchemaForCompensationProductReturn;
    /**
     * 
     * @type {string}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'dateConduction': string;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'responsible': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof BaseProductReturnSchemaForCompensation
     */
    'status': ProductReturnStatuses;
}
/**
 * BaseNomenclatureProforma schema.
 * @export
 * @interface BaseProformaNomenclatureSchema
 */
export interface BaseProformaNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseProformaNomenclatureSchema
     */
    'orderNomenclatureId': number;
    /**
     * 
     * @type {number}
     * @memberof BaseProformaNomenclatureSchema
     */
    'quantity': number;
}
/**
 * Base report schema.
 * @export
 * @interface BaseReportSchema
 */
export interface BaseReportSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseReportSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseReportSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof BaseReportSchema
     */
    'turnover': number;
    /**
     * 
     * @type {number}
     * @memberof BaseReportSchema
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof BaseReportSchema
     */
    'profit': number;
    /**
     * 
     * @type {number}
     * @memberof BaseReportSchema
     */
    'percentage': number;
}
/**
 * Base report totals schema.
 * @export
 * @interface BaseReportTotalsSchema
 */
export interface BaseReportTotalsSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseReportTotalsSchema
     */
    'totalTurnover': number;
    /**
     * 
     * @type {number}
     * @memberof BaseReportTotalsSchema
     */
    'totalCost': number;
    /**
     * 
     * @type {number}
     * @memberof BaseReportTotalsSchema
     */
    'totalProfit': number;
    /**
     * 
     * @type {number}
     * @memberof BaseReportTotalsSchema
     */
    'totalPercentage': number;
}
/**
 * Base simple user read schema.
 * @export
 * @interface BaseSimpleUserReadSchema
 */
export interface BaseSimpleUserReadSchema {
    /**
     * 
     * @type {string}
     * @memberof BaseSimpleUserReadSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseSimpleUserReadSchema
     */
    'name': string;
}
/**
 * Base direction.
 * @export
 * @enum {string}
 */

export const BaseSort = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type BaseSort = typeof BaseSort[keyof typeof BaseSort];


/**
 * NomenclatureVendorCode schema.
 * @export
 * @interface BaseVendorCodeSchema
 */
export interface BaseVendorCodeSchema {
    /**
     * 
     * @type {number}
     * @memberof BaseVendorCodeSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseVendorCodeSchema
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseVendorCodeSchema
     */
    'isBase': boolean;
}
/**
 * 
 * @export
 * @interface BodyValidatorsVatValidatorsUniqueNamePost
 */
export interface BodyValidatorsVatValidatorsUniqueNamePost {
    /**
     * Name of user that you currently editing.
     * @type {string}
     * @memberof BodyValidatorsVatValidatorsUniqueNamePost
     */
    'name': string;
    /**
     * Set user type of user that you currently editing.
     * @type {UserTypes}
     * @memberof BodyValidatorsVatValidatorsUniqueNamePost
     */
    'user_type': UserTypes;
    /**
     * Exclude user by id (current user that you edit).
     * @type {number}
     * @memberof BodyValidatorsVatValidatorsUniqueNamePost
     */
    'exclude_id'?: number;
}
/**
 * Brand crate schema.
 * @export
 * @interface BrandCreateSchema
 */
export interface BrandCreateSchema {
    /**
     * Name of the brand. Must be unique within the brands.
     * @type {string}
     * @memberof BrandCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandCreateSchema
     */
    'isActive': boolean;
}
/**
 * Brand detail schema.
 * @export
 * @interface BrandDetailSchema
 */
export interface BrandDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof BrandDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BrandDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof BrandDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BrandDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Brand schema for list schemas.
 * @export
 * @interface BrandListSchema
 */
export interface BrandListSchema {
    /**
     * 
     * @type {number}
     * @memberof BrandListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BrandListSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof BrandListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandListSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BrandListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Brand params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const BrandQueryOrder = {
    Id: 'id',
    DateCreated: 'dateCreated',
    Name: 'name',
    IsActive: 'isActive'
} as const;

export type BrandQueryOrder = typeof BrandQueryOrder[keyof typeof BrandQueryOrder];


/**
 * Brand schema.
 * @export
 * @interface BrandSchema
 */
export interface BrandSchema {
    /**
     * 
     * @type {number}
     * @memberof BrandSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BrandSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof BrandSchema
     */
    'dateCreated': string;
}
/**
 * Brand create schema.
 * @export
 * @interface BrandUpdateSchema
 */
export interface BrandUpdateSchema {
    /**
     * Name of the brand. Must be unique within the brands.
     * @type {string}
     * @memberof BrandUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BrandUpdateSchema
     */
    'isActive': boolean;
}
/**
 * Schema for brands page.
 * @export
 * @interface BrandsPage
 */
export interface BrandsPage {
    /**
     * 
     * @type {Array<BrandListSchema>}
     * @memberof BrandsPage
     */
    'items': Array<BrandListSchema>;
    /**
     * 
     * @type {number}
     * @memberof BrandsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof BrandsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof BrandsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof BrandsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof BrandsPage
     */
    'totalPages': number;
}
/**
 * UserContractKind model.
 * @export
 * @enum {string}
 */

export const CabinetUserKinds = {
    Client: 'client',
    Supplier: 'supplier',
    Agent: 'agent'
} as const;

export type CabinetUserKinds = typeof CabinetUserKinds[keyof typeof CabinetUserKinds];


/**
 * CancelContractSchema schema.
 * @export
 * @interface CancelContractSchema
 */
export interface CancelContractSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof CancelContractSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof CancelContractSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * CancellationReasonGroup schema.
 * @export
 * @interface CancellationReasonCreateUpdateSchema
 */
export interface CancellationReasonCreateUpdateSchema {
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonCreateUpdateSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonCreateUpdateSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonCreateUpdateSchema
     */
    'isBase'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CancellationReasonCreateUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonCreateUpdateSchema
     */
    'isActive': boolean;
}
/**
 * CancellationReasonGroup detail schema.
 * @export
 * @interface CancellationReasonGroupDetailSchema
 */
export interface CancellationReasonGroupDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof CancellationReasonGroupDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {CancellationReasonGroupRecipient}
     * @memberof CancellationReasonGroupDetailSchema
     */
    'recipient': CancellationReasonGroupRecipient;
    /**
     * 
     * @type {CancellationReasonGroupTypes}
     * @memberof CancellationReasonGroupDetailSchema
     */
    'type': CancellationReasonGroupTypes;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonGroupDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {Array<CancellationReasonListSchema>}
     * @memberof CancellationReasonGroupDetailSchema
     */
    'reasons': Array<CancellationReasonListSchema>;
}
/**
 * CancellationReasonGroup list schema.
 * @export
 * @interface CancellationReasonGroupListSchema
 */
export interface CancellationReasonGroupListSchema {
    /**
     * 
     * @type {string}
     * @memberof CancellationReasonGroupListSchema
     */
    'name': string;
    /**
     * 
     * @type {CancellationReasonGroupRecipient}
     * @memberof CancellationReasonGroupListSchema
     */
    'recipient': CancellationReasonGroupRecipient;
    /**
     * 
     * @type {CancellationReasonGroupTypes}
     * @memberof CancellationReasonGroupListSchema
     */
    'type': CancellationReasonGroupTypes;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonGroupListSchema
     */
    'id': number;
}
/**
 * PriceCategories page schema.
 * @export
 * @interface CancellationReasonGroupPage
 */
export interface CancellationReasonGroupPage {
    /**
     * 
     * @type {Array<CancellationReasonGroupListSchema>}
     * @memberof CancellationReasonGroupPage
     */
    'items': Array<CancellationReasonGroupListSchema>;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonGroupPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonGroupPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof CancellationReasonGroupPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof CancellationReasonGroupPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof CancellationReasonGroupPage
     */
    'totalPages': number;
}
/**
 * Categories query order.
 * @export
 * @enum {string}
 */

export const CancellationReasonGroupQueryOrder = {
    Id: 'id',
    Recipient: 'recipient'
} as const;

export type CancellationReasonGroupQueryOrder = typeof CancellationReasonGroupQueryOrder[keyof typeof CancellationReasonGroupQueryOrder];


/**
 * Enum for cancellation reason group recipient.
 * @export
 * @enum {string}
 */

export const CancellationReasonGroupRecipient = {
    Manager: 'manager',
    Client: 'client'
} as const;

export type CancellationReasonGroupRecipient = typeof CancellationReasonGroupRecipient[keyof typeof CancellationReasonGroupRecipient];


/**
 * Enum for cancellation reason type.
 * @export
 * @enum {string}
 */

export const CancellationReasonGroupTypes = {
    OrderDescription: 'order_description',
    ClientOrderDescription: 'client_order_description',
    ClientProformaDescription: 'client_proforma_description',
    ClientInvoiceDescription: 'client_invoice_description',
    ClientReturnDescription: 'client_return_description',
    ProductReturn: 'product_return',
    ProductReturnType: 'product_return_type',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientReturn: 'client_return',
    SupplierReturn: 'supplier_return',
    IncomingCashOrder: 'incoming_cash_order',
    OutgoingCashOrder: 'outgoing_cash_order',
    IncomingPaymentOrder: 'incoming_payment_order',
    OutgoingPaymentOrder: 'outgoing_payment_order',
    ClientInactiveDescription: 'client_inactive_description',
    SupplierInactiveDescription: 'supplier_inactive_description',
    ClientContractTerminationDescription: 'client_contract_termination_description',
    SupplierContractTerminationDescription: 'supplier_contract_termination_description',
    AgentInactiveDescription: 'agent_inactive_description',
    AgentContractTerminatedDescription: 'agent_contract_terminated_description',
    EmployeeTerminatedDescription: 'employee_terminated_description',
    EmployeeInactiveDescription: 'employee_inactive_description',
    ProductTransfer: 'product_transfer',
    Compensation: 'compensation'
} as const;

export type CancellationReasonGroupTypes = typeof CancellationReasonGroupTypes[keyof typeof CancellationReasonGroupTypes];


/**
 * CancellationReasonGroup schema.
 * @export
 * @interface CancellationReasonGroupUpdateSchema
 */
export interface CancellationReasonGroupUpdateSchema {
    /**
     * 
     * @type {Array<CancellationReasonCreateUpdateSchema>}
     * @memberof CancellationReasonGroupUpdateSchema
     */
    'reasons': Array<CancellationReasonCreateUpdateSchema>;
}
/**
 * CancellationReason list schema.
 * @export
 * @interface CancellationReasonListSchema
 */
export interface CancellationReasonListSchema {
    /**
     * 
     * @type {string}
     * @memberof CancellationReasonListSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonListSchema
     */
    'groupId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonListSchema
     */
    'isBase': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof CancellationReasonListSchema
     */
    'canBeDeleted'?: boolean;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof CancellationReasonListSchema
     */
    'hasReferences': boolean;
}
/**
 * CancellationReason schema.
 * @export
 * @interface CancellationReasonSchema
 */
export interface CancellationReasonSchema {
    /**
     * 
     * @type {string}
     * @memberof CancellationReasonSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CancellationReasonSchema
     */
    'groupId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CancellationReasonSchema
     */
    'isBase': boolean;
}
/**
 * Cancellation schema.
 * @export
 * @interface CancellationSchema
 */
export interface CancellationSchema {
    /**
     * 
     * @type {CancellationReasonSchema}
     * @memberof CancellationSchema
     */
    'reason'?: CancellationReasonSchema;
    /**
     * 
     * @type {string}
     * @memberof CancellationSchema
     */
    'text': string;
    /**
     * 
     * @type {LabelLevel}
     * @memberof CancellationSchema
     */
    'level': LabelLevel;
    /**
     * 
     * @type {string}
     * @memberof CancellationSchema
     */
    'dateCreated': string;
}
/**
 * Financial analysis category groups choices.
 * @export
 * @enum {string}
 */

export const CategoryGroups = {
    Constant: 'constant',
    Variable: 'variable',
    Investments: 'investments'
} as const;

export type CategoryGroups = typeof CategoryGroups[keyof typeof CategoryGroups];


/**
 * Categories query order.
 * @export
 * @enum {string}
 */

export const CategoryQueryOrder = {
    Id: 'id',
    Name: 'name',
    DateCreated: 'dateCreated',
    Status: 'status'
} as const;

export type CategoryQueryOrder = typeof CategoryQueryOrder[keyof typeof CategoryQueryOrder];


/**
 * ChangeCabinetLoginPasswordType enum.
 * @export
 * @enum {string}
 */

export const ChangeCabinetLoginPasswordType = {
    UserActivation: 'user_activation',
    NewPassword: 'new_password',
    NewEmail: 'new_email',
    SendAgain: 'send_again'
} as const;

export type ChangeCabinetLoginPasswordType = typeof ChangeCabinetLoginPasswordType[keyof typeof ChangeCabinetLoginPasswordType];


/**
 * Change profile password schema.
 * @export
 * @interface ChangeProfilePasswordSchema
 */
export interface ChangeProfilePasswordSchema {
    /**
     * Old password
     * @type {string}
     * @memberof ChangeProfilePasswordSchema
     */
    'oldPassword': string;
    /**
     * Old password
     * @type {string}
     * @memberof ChangeProfilePasswordSchema
     */
    'newPassword': string;
    /**
     * Old password
     * @type {string}
     * @memberof ChangeProfilePasswordSchema
     */
    'newPasswordConfirm': string;
}
/**
 * Change order responsible list schema.
 * @export
 * @interface ChangeUnclosedDocumentResponsibleListSchema
 */
export interface ChangeUnclosedDocumentResponsibleListSchema {
    /**
     * 
     * @type {Array<ChangeUnclosedDocumentResponsibleSchema>}
     * @memberof ChangeUnclosedDocumentResponsibleListSchema
     */
    'clientOrderList': Array<ChangeUnclosedDocumentResponsibleSchema>;
    /**
     * 
     * @type {Array<ChangeUnclosedDocumentResponsibleSchema>}
     * @memberof ChangeUnclosedDocumentResponsibleListSchema
     */
    'clientProformaList': Array<ChangeUnclosedDocumentResponsibleSchema>;
    /**
     * 
     * @type {Array<ChangeUnclosedDocumentResponsibleSchema>}
     * @memberof ChangeUnclosedDocumentResponsibleListSchema
     */
    'clientInvoiceList': Array<ChangeUnclosedDocumentResponsibleSchema>;
    /**
     * 
     * @type {Array<ChangeUnclosedDocumentResponsibleSchema>}
     * @memberof ChangeUnclosedDocumentResponsibleListSchema
     */
    'clientProductReturnList': Array<ChangeUnclosedDocumentResponsibleSchema>;
    /**
     * 
     * @type {Array<ChangeUnclosedDocumentResponsibleSchema>}
     * @memberof ChangeUnclosedDocumentResponsibleListSchema
     */
    'clientCompensationList': Array<ChangeUnclosedDocumentResponsibleSchema>;
}
/**
 * Change order responsible schema.
 * @export
 * @interface ChangeUnclosedDocumentResponsibleSchema
 */
export interface ChangeUnclosedDocumentResponsibleSchema {
    /**
     * Document id
     * @type {number}
     * @memberof ChangeUnclosedDocumentResponsibleSchema
     */
    'id': number;
    /**
     * Responsible staff id
     * @type {string}
     * @memberof ChangeUnclosedDocumentResponsibleSchema
     */
    'responsibleId': string;
}
/**
 * Chat page schema.
 * @export
 * @interface ChatPage
 */
export interface ChatPage {
    /**
     * 
     * @type {Array<ChatSchema>}
     * @memberof ChatPage
     */
    'items': Array<ChatSchema>;
    /**
     * 
     * @type {number}
     * @memberof ChatPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ChatPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ChatPage
     */
    'limit': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ChatPage
     */
    'offsetId'?: number;
}
/**
 * Chat schema.
 * @export
 * @interface ChatSchema
 */
export interface ChatSchema {
    /**
     * 
     * @type {number}
     * @memberof ChatSchema
     */
    'id': number;
    /**
     * 
     * @type {Array<CreatorUserSchema>}
     * @memberof ChatSchema
     */
    'participants': Array<CreatorUserSchema>;
    /**
     * 
     * @type {number}
     * @memberof ChatSchema
     */
    'unreadMessagesCount': number;
    /**
     * 
     * @type {LatestMessageSchema}
     * @memberof ChatSchema
     */
    'latestMessage': LatestMessageSchema;
}
/**
 * ContractCreateSchema schema.
 * @export
 * @interface ClientContractCreateSchema
 */
export interface ClientContractCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof ClientContractCreateSchema
     */
    'dateStart': string;
    /**
     * 
     * @type {string}
     * @memberof ClientContractCreateSchema
     */
    'dateEnd': string;
    /**
     * 
     * @type {string}
     * @memberof ClientContractCreateSchema
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientContractCreateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ClientContractCreateSchema
     */
    'accountCashboxIds': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ClientContractCreateSchema
     */
    'userCurrencyId': number;
    /**
     * 
     * @type {number}
     * @memberof ClientContractCreateSchema
     */
    'incotermId'?: number;
    /**
     * Prepayment percent. Used only for equipment contract type.
     * @type {number}
     * @memberof ClientContractCreateSchema
     */
    'prepaymentPercent'?: number;
    /**
     * Transport mode. Used only for equipment contract type.
     * @type {ContractTransportModes}
     * @memberof ClientContractCreateSchema
     */
    'transportMode'?: ContractTransportModes;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientContractCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientContractCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientContractCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientContractCreateSchema
     */
    'userId': string;
    /**
     * 
     * @type {ContractTypes}
     * @memberof ClientContractCreateSchema
     */
    'type': ContractTypes;
}
/**
 * Create Client schema.
 * @export
 * @interface ClientCreateSchema
 */
export interface ClientCreateSchema {
    /**
     * Name
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientCreateSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof ClientCreateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof ClientCreateSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * Additional user locations
     * @type {Array<UserLocationCreateSchema>}
     * @memberof ClientCreateSchema
     */
    'additionalLocations'?: Array<UserLocationCreateSchema>;
    /**
     * Country id
     * @type {number}
     * @memberof ClientCreateSchema
     */
    'countryId': number;
    /**
     * Sites
     * @type {Array<UserSiteCreateSchema>}
     * @memberof ClientCreateSchema
     */
    'sites'?: Array<UserSiteCreateSchema>;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientCreateSchema
     */
    'clientType': ClientTypes;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'vatNumber'?: string;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof ClientCreateSchema
     */
    'isVatPayer': boolean;
    /**
     * Currencies ids to add to user
     * @type {Array<ClientCurrencyCreateSchema>}
     * @memberof ClientCreateSchema
     */
    'userCurrencies': Array<ClientCurrencyCreateSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof ClientCreateSchema
     */
    'clientMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactBaseSchema>}
     * @memberof ClientCreateSchema
     */
    'clientAdditionalContacts'?: Array<UserAdditionalContactBaseSchema>;
    /**
     * 
     * @type {Array<UserDeliveryMethodCreateSchema>}
     * @memberof ClientCreateSchema
     */
    'clientDeliveryMethods'?: Array<UserDeliveryMethodCreateSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientCreateSchema
     */
    'clientPriceCategoryId': number;
    /**
     * 
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'clientManagerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientCreateSchema
     */
    'clientAgentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientCreateSchema
     */
    'clientCategoryId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientCreateSchema
     */
    'clientSourceId'?: number;
}
/**
 * Client currency schema.
 * @export
 * @interface ClientCurrencyCreateSchema
 */
export interface ClientCurrencyCreateSchema {
    /**
     * Currency id
     * @type {number}
     * @memberof ClientCurrencyCreateSchema
     */
    'currencyId': number;
    /**
     * 
     * @type {UserCreditLimitSchemaWriteSchema}
     * @memberof ClientCurrencyCreateSchema
     */
    'creditLimit': UserCreditLimitSchemaWriteSchema;
}
/**
 * Client debt schema.
 * @export
 * @interface ClientCurrencyDebtSchema
 */
export interface ClientCurrencyDebtSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientCurrencyDebtSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientCurrencyDebtSchema
     */
    'clientBalanceAbs': number;
    /**
     * 
     * @type {SimpleCurrencySchema}
     * @memberof ClientCurrencyDebtSchema
     */
    'currency': SimpleCurrencySchema;
}
/**
 * Client currency update formset schema.
 * @export
 * @interface ClientCurrencyFormsetSchema
 */
export interface ClientCurrencyFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientCurrencyFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCurrencyFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCurrencyFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * Currency id
     * @type {number}
     * @memberof ClientCurrencyFormsetSchema
     */
    'currencyId': number;
    /**
     * 
     * @type {UserCreditLimitSchemaWriteSchema}
     * @memberof ClientCurrencyFormsetSchema
     */
    'creditLimit': UserCreditLimitSchemaWriteSchema;
}
/**
 * Client deactivation schema.
 * @export
 * @interface ClientDeactivationSchema
 */
export interface ClientDeactivationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof ClientDeactivationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof ClientDeactivationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Client debts report client schema.
 * @export
 * @interface ClientDebtsReportClientSchema
 */
export interface ClientDebtsReportClientSchema {
    /**
     * 
     * @type {string}
     * @memberof ClientDebtsReportClientSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClientDebtsReportClientSchema
     */
    'name': string;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientDebtsReportClientSchema
     */
    'clientType': ClientTypes;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof ClientDebtsReportClientSchema
     */
    'clientCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {CountrySchema}
     * @memberof ClientDebtsReportClientSchema
     */
    'country': CountrySchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientDebtsReportClientSchema
     */
    'clientAgent'?: SimpleUserSchema;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof ClientDebtsReportClientSchema
     */
    'clientManager'?: SimpleStaffReadSchema;
    /**
     * 
     * @type {Array<ClientCurrencyDebtSchema>}
     * @memberof ClientDebtsReportClientSchema
     */
    'userCurrencies': Array<ClientCurrencyDebtSchema>;
}
/**
 * Client debts report page schema.
 * @export
 * @interface ClientDebtsReportPageSchema
 */
export interface ClientDebtsReportPageSchema {
    /**
     * 
     * @type {Array<ClientDebtsReportClientSchema>}
     * @memberof ClientDebtsReportPageSchema
     */
    'items': Array<ClientDebtsReportClientSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientDebtsReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientDebtsReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientDebtsReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientDebtsReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientDebtsReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<CurrencyDebtSchema>}
     * @memberof ClientDebtsReportPageSchema
     */
    'currencies': Array<CurrencyDebtSchema>;
}
/**
 * Client debts report query order enum.
 * @export
 * @enum {string}
 */

export const ClientDebtsReportQueryOrder = {
    Id: 'id',
    Name: 'name',
    ClientType: 'client_type',
    ClientCategory: 'client_category',
    Country: 'country',
    Agent: 'agent',
    Manager: 'manager',
    Debt: 'debt'
} as const;

export type ClientDebtsReportQueryOrder = typeof ClientDebtsReportQueryOrder[keyof typeof ClientDebtsReportQueryOrder];


/**
 * Client full info schema.
 * @export
 * @interface ClientFullInfoSchema
 */
export interface ClientFullInfoSchema {
    /**
     * Name
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientFullInfoSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof ClientFullInfoSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof ClientFullInfoSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof ClientFullInfoSchema
     */
    'isVatPayer': boolean;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClientFullInfoSchema
     */
    'avatar'?: string;
    /**
     * Additional user locations
     * @type {Array<UserLocationReadSchema>}
     * @memberof ClientFullInfoSchema
     */
    'additionalLocations': Array<UserLocationReadSchema>;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof ClientFullInfoSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * Sites
     * @type {Array<UserSiteReadSchema>}
     * @memberof ClientFullInfoSchema
     */
    'sites': Array<UserSiteReadSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof ClientFullInfoSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientFullInfoSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientFullInfoSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientFullInfoSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientFullInfoSchema
     */
    'clientType': ClientTypes;
    /**
     * 
     * @type {ClientStatuses}
     * @memberof ClientFullInfoSchema
     */
    'clientStatus': ClientStatuses;
    /**
     * 
     * @type {ClientRegistrationMethods}
     * @memberof ClientFullInfoSchema
     */
    'clientRegistrationMethod': ClientRegistrationMethods;
    /**
     * 
     * @type {Array<UserCurrencyReadSchema>}
     * @memberof ClientFullInfoSchema
     */
    'userCurrencies': Array<UserCurrencyReadSchema>;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof ClientFullInfoSchema
     */
    'clientManager': SimpleStaffReadSchema;
    /**
     * 
     * @type {SimpleAgentReadSchema}
     * @memberof ClientFullInfoSchema
     */
    'clientAgent'?: SimpleAgentReadSchema;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof ClientFullInfoSchema
     */
    'clientCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof ClientFullInfoSchema
     */
    'clientPriceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {ClientSourceSimpleSchema}
     * @memberof ClientFullInfoSchema
     */
    'clientSource'?: ClientSourceSimpleSchema;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof ClientFullInfoSchema
     */
    'clientMainContact': UserMainContactBaseReadSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof ClientFullInfoSchema
     */
    'clientAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
    /**
     * 
     * @type {Array<UserDeliveryReadSchema>}
     * @memberof ClientFullInfoSchema
     */
    'clientDeliveryMethods'?: Array<UserDeliveryReadSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'ordersCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'proformasCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'invoicesCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'paymentsCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'returnsCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'mutualSettlementsCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'contractsCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'notesCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientFullInfoSchema
     */
    'chatMessagesCount'?: number;
    /**
     * 
     * @type {VatRates}
     * @memberof ClientFullInfoSchema
     */
    'vatRate'?: VatRates;
}
/**
 * Client invoice additional expense create schema.
 * @export
 * @interface ClientInvoiceAdditionalExpenseChangeSchema
 */
export interface ClientInvoiceAdditionalExpenseChangeSchema {
    /**
     * If None - new client invoice for allocation will be created.
     * @type {number}
     * @memberof ClientInvoiceAdditionalExpenseChangeSchema
     */
    'id'?: number;
    /**
     * Client invoice ID
     * @type {number}
     * @memberof ClientInvoiceAdditionalExpenseChangeSchema
     */
    'clientInvoiceId': number;
    /**
     * Additional expenses list for client invoice
     * @type {Array<ClientNomenclatureAdditionalExpenseChangeSchema>}
     * @memberof ClientInvoiceAdditionalExpenseChangeSchema
     */
    'additionalExpenses': Array<ClientNomenclatureAdditionalExpenseChangeSchema>;
    /**
     * Field for deleting client invoice.
     * @type {boolean}
     * @memberof ClientInvoiceAdditionalExpenseChangeSchema
     */
    'isDeleted'?: boolean;
}
/**
 * Client invoice additional expense schema.
 * @export
 * @interface ClientInvoiceAdditionalExpenseSchema
 */
export interface ClientInvoiceAdditionalExpenseSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {InvoiceSchemaForAdditionalExpense}
     * @memberof ClientInvoiceAdditionalExpenseSchema
     */
    'clientInvoice': InvoiceSchemaForAdditionalExpense;
    /**
     * 
     * @type {Array<ClientNomenclatureAdditionalExpenseSchema>}
     * @memberof ClientInvoiceAdditionalExpenseSchema
     */
    'additionalExpenses': Array<ClientNomenclatureAdditionalExpenseSchema>;
}
/**
 * Client invoice cancellation schema.
 * @export
 * @interface ClientInvoiceCancellationSchema
 */
export interface ClientInvoiceCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof ClientInvoiceCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof ClientInvoiceCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Client invoice create schema.
 * @export
 * @interface ClientInvoiceCreateSchema
 */
export interface ClientInvoiceCreateSchema {
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof ClientInvoiceCreateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof ClientInvoiceCreateSchema
     */
    'comment'?: string;
    /**
     * Delivery type. Can be used from client card.
     * @type {DeliveryMethods}
     * @memberof ClientInvoiceCreateSchema
     */
    'deliveryType'?: DeliveryMethods;
    /**
     * Delivery address. Can be used from client card.
     * @type {string}
     * @memberof ClientInvoiceCreateSchema
     */
    'deliveryAddress'?: string;
    /**
     * Total sum of weights of all added nomenclatures. Can be entered manually.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'weight'?: number;
    /**
     * Length. Manual data entry.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'length'?: number;
    /**
     * Width. Manual data entry.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'width'?: number;
    /**
     * Height. Manual data entry.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'height'?: number;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientInvoiceCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Order ID. Only active orders.
     * @type {number}
     * @memberof ClientInvoiceCreateSchema
     */
    'orderId': number;
    /**
     * 
     * @type {Array<ClientInvoiceNomenclatureChangeSchema>}
     * @memberof ClientInvoiceCreateSchema
     */
    'invoiceNomenclatures': Array<ClientInvoiceNomenclatureChangeSchema>;
}
/**
 * Client invoice update delivery status schema.
 * @export
 * @interface ClientInvoiceDeliveryStatusUpdateSchema
 */
export interface ClientInvoiceDeliveryStatusUpdateSchema {
    /**
     * Delivery status.
     * @type {InvoiceDeliveryStatuses}
     * @memberof ClientInvoiceDeliveryStatusUpdateSchema
     */
    'deliveryStatus'?: InvoiceDeliveryStatuses;
}
/**
 * Client invoice detail schema.
 * @export
 * @interface ClientInvoiceDetailSchema
 */
export interface ClientInvoiceDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof ClientInvoiceDetailSchema
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientInvoiceDetailSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'datePayment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'isOverduePayment'?: boolean;
    /**
     * Check if request user has conduct permission.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasConductPermission'?: boolean;
    /**
     * Check if request user has cancel permission.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasCancelPermission'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasOverdueInvoices'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'isSufficientFunds'?: boolean;
    /**
     * Check if invoice has conducted supplier invoices with additional expenses.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasConductedSupplierInvoices': boolean;
    /**
     * If invoice has created or conducted returns.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasRelatedReturns': boolean;
    /**
     * Check if invoice has created return.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasCreatedReturn': boolean;
    /**
     * Check if invoice has conducted returns.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasConductedReturns': boolean;
    /**
     * Check if invoice has related payment orders.
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasRelatedPayments'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'canConduct'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'canCancel'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'canCreateReturn'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'discountMarkupTotal'?: number;
    /**
     * 
     * @type {ClientOrderDetailSchemaForClientInvoice}
     * @memberof ClientInvoiceDetailSchema
     */
    'order': ClientOrderDetailSchemaForClientInvoice;
    /**
     * 
     * @type {Array<ClientInvoiceNomenclatureDetailSchema>}
     * @memberof ClientInvoiceDetailSchema
     */
    'invoiceNomenclatures': Array<ClientInvoiceNomenclatureDetailSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'hasEnoughNomenclatures'?: boolean;
    /**
     * 
     * @type {DeliveryMethods}
     * @memberof ClientInvoiceDetailSchema
     */
    'deliveryType'?: DeliveryMethods;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'deliveryAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceDetailSchema
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'dateSend'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'dateDelivery'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'dateDeliveryActual'?: string;
    /**
     * 
     * @type {InvoiceDeliveryStatuses}
     * @memberof ClientInvoiceDetailSchema
     */
    'deliveryStatus'?: InvoiceDeliveryStatuses;
    /**
     * 
     * @type {SimpleIncotermSchema}
     * @memberof ClientInvoiceDetailSchema
     */
    'incoterm'?: SimpleIncotermSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceDetailSchema
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'isSkippedSlovenia': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceDetailSchema
     */
    'canSelectShippedDeliveryStatus'?: boolean;
}
/**
 * Client invoice for product return read schema.
 * @export
 * @interface ClientInvoiceForProductReturnDetailSchema
 */
export interface ClientInvoiceForProductReturnDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {ClientOrderForProductReturnDetailSchema}
     * @memberof ClientInvoiceForProductReturnDetailSchema
     */
    'order': ClientOrderForProductReturnDetailSchema;
}
/**
 * Client invoice for product return read schema.
 * @export
 * @interface ClientInvoiceForProductReturnListSchema
 */
export interface ClientInvoiceForProductReturnListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {ClientOrderForProductReturnListSchema}
     * @memberof ClientInvoiceForProductReturnListSchema
     */
    'order': ClientOrderForProductReturnListSchema;
}
/**
 * Client invoice income list schema.
 * @export
 * @interface ClientInvoiceIncomeListSchema
 */
export interface ClientInvoiceIncomeListSchema {
    /**
     * 
     * @type {Array<ClientInvoiceNomenclatureIncomeSchema>}
     * @memberof ClientInvoiceIncomeListSchema
     */
    'invoiceNomenclatures': Array<ClientInvoiceNomenclatureIncomeSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceIncomeListSchema
     */
    'totalSumCostPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceIncomeListSchema
     */
    'totalSumSellingPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceIncomeListSchema
     */
    'totalCurrencyGain'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceIncomeListSchema
     */
    'totalPercentageGain'?: number;
}
/**
 * Client invoice labels query-filter for client invoice list.
 * @export
 * @enum {string}
 */

export const ClientInvoiceLabels = {
    PaymentDate: 'has_payment_date',
    PassedPaymentDate: 'has_passed_payment_date',
    InactiveClient: 'has_inactive_client',
    ProductReturn: 'has_product_return'
} as const;

export type ClientInvoiceLabels = typeof ClientInvoiceLabels[keyof typeof ClientInvoiceLabels];


/**
 * Client invoice list schema.
 * @export
 * @interface ClientInvoiceListSchema
 */
export interface ClientInvoiceListSchema {
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientInvoiceListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof ClientInvoiceListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof ClientInvoiceListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceListSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceListSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof ClientInvoiceListSchema
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientInvoiceListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientInvoiceListSchema
     */
    'dateCreated': string;
    /**
     * Document number.
     * @type {string}
     * @memberof ClientInvoiceListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientInvoiceListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientInvoiceListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientInvoiceListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof ClientInvoiceListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {ClientOrderReadSchemaForDocumentsList}
     * @memberof ClientInvoiceListSchema
     */
    'order': ClientOrderReadSchemaForDocumentsList;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceListSchema
     */
    'isCashPayment': boolean;
    /**
     * 
     * @type {InvoiceDeliveryStatuses}
     * @memberof ClientInvoiceListSchema
     */
    'deliveryStatus'?: InvoiceDeliveryStatuses;
    /**
     * 
     * @type {CancellationSchema}
     * @memberof ClientInvoiceListSchema
     */
    'cancellation'?: CancellationSchema;
}
/**
 * Client invoice nomenclature change schema for create/update schemas.
 * @export
 * @interface ClientInvoiceNomenclatureChangeSchema
 */
export interface ClientInvoiceNomenclatureChangeSchema {
    /**
     * Order nomenclature ID. Must be unique
     * @type {number}
     * @memberof ClientInvoiceNomenclatureChangeSchema
     */
    'orderNomenclatureId': number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof ClientInvoiceNomenclatureChangeSchema
     */
    'quantity': number;
}
/**
 * Client invoice nomenclature detail schema.
 * @export
 * @interface ClientInvoiceNomenclatureDetailSchema
 */
export interface ClientInvoiceNomenclatureDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'currentPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'productReturnNomenclaturesQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'availableQuantityForReturn'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'discountMarkupPerItem'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'discountMarkupPerItemAbsolute'?: number;
    /**
     * 
     * @type {ClientOrderNomenclatureForClientDocumentSchema}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'orderNomenclature': ClientOrderNomenclatureForClientDocumentSchema;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInvoiceNomenclatureDetailSchema
     */
    'hasEnoughAvailableQuantity'?: boolean;
}
/**
 * Client invoice nomenclature income schema.
 * @export
 * @interface ClientInvoiceNomenclatureIncomeSchema
 */
export interface ClientInvoiceNomenclatureIncomeSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'id': number;
    /**
     * 
     * @type {SimpleOrderNomenclatureSchema}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'orderNomenclature': SimpleOrderNomenclatureSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'costPrice': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'sumCostPrice': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'sellingPrice': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'sumSellingPrice': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'currencyGain': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureIncomeSchema
     */
    'percentageGain': number;
}
/**
 * Client order nomenclature list schema.
 * @export
 * @interface ClientInvoiceNomenclatureListSchema
 */
export interface ClientInvoiceNomenclatureListSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'currentPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'productReturnNomenclaturesQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'availableQuantityForReturn'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'discountMarkupPerItem'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'discountMarkupPerItemAbsolute'?: number;
    /**
     * 
     * @type {SimpleOrderNomenclatureSchema}
     * @memberof ClientInvoiceNomenclatureListSchema
     */
    'orderNomenclature': SimpleOrderNomenclatureSchema;
}
/**
 * Client invoice nomenclature page schema.
 * @export
 * @interface ClientInvoiceNomenclaturePageSchema
 */
export interface ClientInvoiceNomenclaturePageSchema {
    /**
     * 
     * @type {Array<ClientInvoiceNomenclatureListSchema>}
     * @memberof ClientInvoiceNomenclaturePageSchema
     */
    'items': Array<ClientInvoiceNomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclaturePageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoiceNomenclaturePageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientInvoiceNomenclaturePageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientInvoiceNomenclaturePageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientInvoiceNomenclaturePageSchema
     */
    'totalPages': number;
}
/**
 * Client invoice nomenclature update schema.
 * @export
 * @interface ClientInvoiceNomenclatureUpdateSchema
 */
export interface ClientInvoiceNomenclatureUpdateSchema {
    /**
     * Order nomenclature ID. Must be unique
     * @type {number}
     * @memberof ClientInvoiceNomenclatureUpdateSchema
     */
    'orderNomenclatureId': number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof ClientInvoiceNomenclatureUpdateSchema
     */
    'quantity': number;
    /**
     * Field id. If None - new invoice nomenclature will be created.
     * @type {number}
     * @memberof ClientInvoiceNomenclatureUpdateSchema
     */
    'id'?: number;
    /**
     * Field for deleting invoice nomenclature
     * @type {boolean}
     * @memberof ClientInvoiceNomenclatureUpdateSchema
     */
    'isDeleted': boolean;
}
/**
 * Client invoices page schema.
 * @export
 * @interface ClientInvoicePage
 */
export interface ClientInvoicePage {
    /**
     * 
     * @type {Array<ClientInvoiceListSchema>}
     * @memberof ClientInvoicePage
     */
    'items': Array<ClientInvoiceListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoicePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientInvoicePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientInvoicePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientInvoicePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientInvoicePage
     */
    'totalPages': number;
}
/**
 * Client invoice update schema.
 * @export
 * @interface ClientInvoiceUpdateSchema
 */
export interface ClientInvoiceUpdateSchema {
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof ClientInvoiceUpdateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof ClientInvoiceUpdateSchema
     */
    'comment'?: string;
    /**
     * Delivery type. Can be used from client card.
     * @type {DeliveryMethods}
     * @memberof ClientInvoiceUpdateSchema
     */
    'deliveryType'?: DeliveryMethods;
    /**
     * Delivery address. Can be used from client card.
     * @type {string}
     * @memberof ClientInvoiceUpdateSchema
     */
    'deliveryAddress'?: string;
    /**
     * Total sum of weights of all added nomenclatures. Can be entered manually.
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'weight'?: number;
    /**
     * Length. Manual data entry.
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'length'?: number;
    /**
     * Width. Manual data entry.
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'width'?: number;
    /**
     * Height. Manual data entry.
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'height'?: number;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientInvoiceUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {InvoiceUpdateStatuses}
     * @memberof ClientInvoiceUpdateSchema
     */
    'status': InvoiceUpdateStatuses;
    /**
     * 
     * @type {Array<ClientInvoiceNomenclatureUpdateSchema>}
     * @memberof ClientInvoiceUpdateSchema
     */
    'invoiceNomenclatures': Array<ClientInvoiceNomenclatureUpdateSchema>;
    /**
     * Scheduled delivery date. Only current or future date.
     * @type {string}
     * @memberof ClientInvoiceUpdateSchema
     */
    'dateDelivery'?: string;
    /**
     * Incoterm id. Can be used from client contract.
     * @type {number}
     * @memberof ClientInvoiceUpdateSchema
     */
    'incotermId': number;
    /**
     * Address. Can be used from client contract.
     * @type {string}
     * @memberof ClientInvoiceUpdateSchema
     */
    'address': string;
    /**
     * Is skipped slovenia. Can be used from client contract.
     * @type {boolean}
     * @memberof ClientInvoiceUpdateSchema
     */
    'isSkippedSlovenia': boolean;
}
/**
 * Agent client statistics schema.
 * @export
 * @interface ClientInvoicesDetailedStatisticsSchema
 */
export interface ClientInvoicesDetailedStatisticsSchema {
    /**
     * 
     * @type {ClientTypeInvoicesStatisticsSchema}
     * @memberof ClientInvoicesDetailedStatisticsSchema
     */
    'retail': ClientTypeInvoicesStatisticsSchema;
    /**
     * 
     * @type {ClientTypeInvoicesStatisticsSchema}
     * @memberof ClientInvoicesDetailedStatisticsSchema
     */
    'autoService': ClientTypeInvoicesStatisticsSchema;
    /**
     * 
     * @type {ClientTypeInvoicesStatisticsSchema}
     * @memberof ClientInvoicesDetailedStatisticsSchema
     */
    'wholesale': ClientTypeInvoicesStatisticsSchema;
}
/**
 * Client labels query-filter for client list.
 * @export
 * @enum {string}
 */

export const ClientLabels = {
    Supplier: 'is_supplier',
    Agent: 'is_agent'
} as const;

export type ClientLabels = typeof ClientLabels[keyof typeof ClientLabels];


/**
 * Client list schema.
 * @export
 * @interface ClientListSchema
 */
export interface ClientListSchema {
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof ClientListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof ClientListSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientListSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientListSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientListSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientListSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientListSchema
     */
    'clientType': ClientTypes;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof ClientListSchema
     */
    'clientCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof ClientListSchema
     */
    'clientMainContact': UserMainContactBaseReadSchema;
    /**
     * 
     * @type {SimpleAgentReadSchema}
     * @memberof ClientListSchema
     */
    'clientAgent'?: SimpleAgentReadSchema;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof ClientListSchema
     */
    'clientManager': SimpleStaffReadSchema;
    /**
     * 
     * @type {ClientStatuses}
     * @memberof ClientListSchema
     */
    'clientStatus': ClientStatuses;
    /**
     * 
     * @type {CountrySchema}
     * @memberof ClientListSchema
     */
    'country': CountrySchema;
    /**
     * 
     * @type {string}
     * @memberof ClientListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {Array<DebtOrOverpaymentSchema>}
     * @memberof ClientListSchema
     */
    'debtsOrOverpayments'?: Array<DebtOrOverpaymentSchema>;
}
/**
 * Client nomenclature additional expense create schema.
 * @export
 * @interface ClientNomenclatureAdditionalExpenseChangeSchema
 */
export interface ClientNomenclatureAdditionalExpenseChangeSchema {
    /**
     * If None - new additional expense will be created.
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseChangeSchema
     */
    'id'?: number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseChangeSchema
     */
    'priceWithoutVat': number;
    /**
     * Order nomenclature ID from supplier invoice.
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseChangeSchema
     */
    'orderNomenclatureId': number;
    /**
     * Field for deleting additional expense.
     * @type {boolean}
     * @memberof ClientNomenclatureAdditionalExpenseChangeSchema
     */
    'isDeleted': boolean;
}
/**
 * Client nomenclature additional expense list schema.
 * @export
 * @interface ClientNomenclatureAdditionalExpenseListSchema
 */
export interface ClientNomenclatureAdditionalExpenseListSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'priceWithoutVat': number;
    /**
     * 
     * @type {BaseOrderNomenclatureSchema}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'orderNomenclature': BaseOrderNomenclatureSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'priceWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'euroSumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'euroSumWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'euroVatTotal'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {SimpleClientInvoiceAdditionalExpenseSchema}
     * @memberof ClientNomenclatureAdditionalExpenseListSchema
     */
    'expense': SimpleClientInvoiceAdditionalExpenseSchema;
}
/**
 * Client nomenclature additional expense schema.
 * @export
 * @interface ClientNomenclatureAdditionalExpenseSchema
 */
export interface ClientNomenclatureAdditionalExpenseSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientNomenclatureAdditionalExpenseSchema
     */
    'priceWithoutVat': number;
    /**
     * 
     * @type {BaseOrderNomenclatureSchema}
     * @memberof ClientNomenclatureAdditionalExpenseSchema
     */
    'orderNomenclature': BaseOrderNomenclatureSchema;
}
/**
 * Client order cancellation schema.
 * @export
 * @interface ClientOrderCancellationSchema
 */
export interface ClientOrderCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof ClientOrderCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof ClientOrderCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Client schema for client order list.
 * @export
 * @interface ClientOrderClientSchema
 */
export interface ClientOrderClientSchema {
    /**
     * Name
     * @type {string}
     * @memberof ClientOrderClientSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderClientSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderClientSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof ClientOrderClientSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientOrderClientSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof ClientOrderClientSchema
     */
    'clientCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientOrderClientSchema
     */
    'clientType': ClientTypes;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderClientSchema
     */
    'clientAgent'?: SimpleUserSchema;
}
/**
 * Client order create schema.
 * @export
 * @interface ClientOrderCreateSchema
 */
export interface ClientOrderCreateSchema {
    /**
     * Price category ID. Only active categories or categories.
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'priceCategoryId': number;
    /**
     * Currency rate. Only \'1\' for EUR currency
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'rate': number;
    /**
     * Only signed contracts. Only contract with selected currency for order. Client contract IDs for client. Supplier contract IDs for supplier.
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'contractId'?: number;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof ClientOrderCreateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof ClientOrderCreateSchema
     */
    'comment'?: string;
    /**
     * User currency ID. Only active client/supplier currencies.
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'userCurrencyId': number;
    /**
     * 1) Pulled up according to the selected currency of the Client (if no contractId).  2) Or, if a contract is selected, the current accounts/cashboxes specified. in the client\'s contract will be pulled up.  3) Active accounts and cashboxes are pulled up from the settings
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'accountCashboxId': number;
    /**
     * Sending warehouse ID.
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'warehouseId': number;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Client ID for client order. Supplier ID for supplier order
     * @type {string}
     * @memberof ClientOrderCreateSchema
     */
    'userId': string;
    /**
     * 
     * @type {DiscountMarkupChangeSchema}
     * @memberof ClientOrderCreateSchema
     */
    'discountMarkup'?: DiscountMarkupChangeSchema;
    /**
     * 
     * @type {Array<ClientOrderNomenclatureChangeSchema>}
     * @memberof ClientOrderCreateSchema
     */
    'orderNomenclatures': Array<ClientOrderNomenclatureChangeSchema>;
}
/**
 * Client order detail schema.
 * @export
 * @interface ClientOrderDetailSchema
 */
export interface ClientOrderDetailSchema {
    /**
     * 
     * @type {SimpleUserWithVat}
     * @memberof ClientOrderDetailSchema
     */
    'user': SimpleUserWithVat;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof ClientOrderDetailSchema
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'rate'?: number;
    /**
     * 
     * @type {VatRates}
     * @memberof ClientOrderDetailSchema
     */
    'vatRate'?: VatRates;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof ClientOrderDetailSchema
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderDetailSchema
     */
    'comment'?: string;
    /**
     * Created or conducted(with debt) invoices. Created or \'submitted_for_payment\' proformas
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'hasUnclosedDocuments': boolean;
    /**
     * Conducted invoices or paid proformas
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'hasCompletedDocuments': boolean;
    /**
     * Only created proformas
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'hasOnlyCreatedProformas': boolean;
    /**
     * Can change currency rate in CRM
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'crmChangeCurrencyRate': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canChangeCurrency'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canChangeCurrencyRate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canChangeContract'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canComplete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canCancel'?: boolean;
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof ClientOrderDetailSchema
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof ClientOrderDetailSchema
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderDetailSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderDetailSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof ClientOrderDetailSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof ClientOrderDetailSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchema
     */
    'discountMarkupTotal'?: number;
    /**
     * 
     * @type {AccountCashboxSimpleSchema}
     * @memberof ClientOrderDetailSchema
     */
    'accountCashbox': AccountCashboxSimpleSchema;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ClientOrderDetailSchema
     */
    'warehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {DiscountMarkupDetailSchema}
     * @memberof ClientOrderDetailSchema
     */
    'discountMarkup'?: DiscountMarkupDetailSchema;
    /**
     * 
     * @type {Array<ClientOrderNomenclatureDetailSchema>}
     * @memberof ClientOrderDetailSchema
     */
    'orderNomenclatures': Array<ClientOrderNomenclatureDetailSchema>;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderDetailSchema
     */
    'clientComment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'hasConductedInvoices': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'crmChangePriceType': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canChangePriceCategory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canChangeAccountCashbox'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchema
     */
    'canChangeWarehouse'?: boolean;
}
/**
 * Client order detail schema for client invoice.
 * @export
 * @interface ClientOrderDetailSchemaForClientInvoice
 */
export interface ClientOrderDetailSchemaForClientInvoice {
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'id': number;
    /**
     * 
     * @type {SimpleUserWithVat}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'user': SimpleUserWithVat;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'rate': number;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'warehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {AccountCashboxSimpleSchema}
     * @memberof ClientOrderDetailSchemaForClientInvoice
     */
    'accountCashbox': AccountCashboxSimpleSchema;
}
/**
 * Client order detail schema for proforma.
 * @export
 * @interface ClientOrderDetailSchemaForProforma
 */
export interface ClientOrderDetailSchemaForProforma {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {SimpleUserSchemaForClientProforma}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'user': SimpleUserSchemaForClientProforma;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'vatRate'?: number;
    /**
     * 
     * @type {AccountCashboxSimpleSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'accountCashbox': AccountCashboxSimpleSchema;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'warehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {DiscountMarkupDetailSchema}
     * @memberof ClientOrderDetailSchemaForProforma
     */
    'discountMarkup'?: DiscountMarkupDetailSchema;
}
/**
 * Client order detail schema for proforma.
 * @export
 * @interface ClientOrderForProductReturnDetailSchema
 */
export interface ClientOrderForProductReturnDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchemaForClientProforma}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'user': SimpleUserSchemaForClientProforma;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'vatRate'?: number;
    /**
     * 
     * @type {DiscountMarkupDetailSchema}
     * @memberof ClientOrderForProductReturnDetailSchema
     */
    'discountMarkup'?: DiscountMarkupDetailSchema;
}
/**
 * Client order detail schema for proforma.
 * @export
 * @interface ClientOrderForProductReturnListSchema
 */
export interface ClientOrderForProductReturnListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchemaForClientProforma}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'user': SimpleUserSchemaForClientProforma;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {AccountCashboxSimpleSchema}
     * @memberof ClientOrderForProductReturnListSchema
     */
    'accountCashbox': AccountCashboxSimpleSchema;
}
/**
 * Client order list schema for nomenclature reserve.
 * @export
 * @interface ClientOrderForReserveListSchema
 */
export interface ClientOrderForReserveListSchema {
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderForReserveListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof ClientOrderForReserveListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof ClientOrderForReserveListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderForReserveListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderForReserveListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderForReserveListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderForReserveListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderForReserveListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderForReserveListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof ClientOrderForReserveListSchema
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderForReserveListSchema
     */
    'responsible': SimpleUserSchema;
}
/**
 * Label schema for client order.
 * @export
 * @interface ClientOrderLabelSchema
 */
export interface ClientOrderLabelSchema {
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderLabelSchema
     */
    'hasOrderRelationship': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderLabelSchema
     */
    'hasProductPartialReturn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderLabelSchema
     */
    'hasProductFullReturn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderLabelSchema
     */
    'hasReserve': boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderLabelSchema
     */
    'cancellationText'?: string;
}
/**
 * Client order labels query-filter for client order list.
 * @export
 * @enum {string}
 */

export const ClientOrderLabels = {
    Reserve: 'has_reserve',
    OrderRelationship: 'has_order_relationship',
    InactiveClient: 'has_inactive_client',
    ProductReturn: 'has_product_return'
} as const;

export type ClientOrderLabels = typeof ClientOrderLabels[keyof typeof ClientOrderLabels];


/**
 * Client order list schema.
 * @export
 * @interface ClientOrderListSchema
 */
export interface ClientOrderListSchema {
    /**
     * 
     * @type {OrderStatuses}
     * @memberof ClientOrderListSchema
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ClientOrderListSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderListSchema
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof ClientOrderListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof ClientOrderListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderListSchema
     */
    'sumPaidByConductedInvoices'?: number;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof ClientOrderListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {ClientOrderClientSchema}
     * @memberof ClientOrderListSchema
     */
    'user': ClientOrderClientSchema;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderListSchema
     */
    'isCashPayment': boolean;
    /**
     * 
     * @type {CancellationSchema}
     * @memberof ClientOrderListSchema
     */
    'cancellation'?: CancellationSchema;
}
/**
 * Client order detail schema for proforma.
 * @export
 * @interface ClientOrderListSchemaForProforma
 */
export interface ClientOrderListSchemaForProforma {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderListSchemaForProforma
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderListSchemaForProforma
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderListSchemaForProforma
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderListSchemaForProforma
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderListSchemaForProforma
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderListSchemaForProforma
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof ClientOrderListSchemaForProforma
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ClientOrderListSchemaForProforma
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderListSchemaForProforma
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientOrderListSchemaForProforma
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {SimpleUserSchemaForClientProforma}
     * @memberof ClientOrderListSchemaForProforma
     */
    'user': SimpleUserSchemaForClientProforma;
}
/**
 * Client order nomenclature change schema for create/update schemas.
 * @export
 * @interface ClientOrderNomenclatureChangeSchema
 */
export interface ClientOrderNomenclatureChangeSchema {
    /**
     * Nomenclature ID. Only active nomenclatures.
     * @type {number}
     * @memberof ClientOrderNomenclatureChangeSchema
     */
    'nomenclatureId': number;
    /**
     * Nomenclature vendor code ID. Required for product nomenclatures.
     * @type {number}
     * @memberof ClientOrderNomenclatureChangeSchema
     */
    'vendorCodeId'?: number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof ClientOrderNomenclatureChangeSchema
     */
    'quantity': number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof ClientOrderNomenclatureChangeSchema
     */
    'price': number;
    /**
     * Reserve nomenclature field.
     * @type {boolean}
     * @memberof ClientOrderNomenclatureChangeSchema
     */
    'isReserve': boolean;
}
/**
 * Client order nomenclature detail schema.
 * @export
 * @interface ClientOrderNomenclatureDetailSchema
 */
export interface ClientOrderNomenclatureDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {DocumentNomenclatureSchema}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'nomenclature': DocumentNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'availableOrderQuantityForInvoices'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'discountMarkupPerItem'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'discountMarkupPerItemAbsolute'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'isReserve': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'reserveQuantity'?: number;
    /**
     * 
     * @type {WarehouseNomenclatureQuantitySchema}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'warehouseNomenclature'?: WarehouseNomenclatureQuantitySchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureDetailSchema
     */
    'availableQuantity'?: number;
}
/**
 * Client order nomenclature schema for the client invoice and proformas.
 * @export
 * @interface ClientOrderNomenclatureForClientDocumentSchema
 */
export interface ClientOrderNomenclatureForClientDocumentSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'availableOrderQuantityForInvoices'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'isReserve': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'reserveQuantity'?: number;
    /**
     * 
     * @type {WarehouseNomenclatureQuantitySchema}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'warehouseNomenclature'?: WarehouseNomenclatureQuantitySchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureForClientDocumentSchema
     */
    'availableQuantity'?: number;
}
/**
 * Client order nomenclature list schema.
 * @export
 * @interface ClientOrderNomenclatureListSchema
 */
export interface ClientOrderNomenclatureListSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'availableOrderQuantityForInvoices'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'isReserve': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'reserveQuantity'?: number;
    /**
     * 
     * @type {WarehouseNomenclatureQuantitySchema}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'warehouseNomenclature'?: WarehouseNomenclatureQuantitySchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'availableQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'discountMarkupPerItem'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclatureListSchema
     */
    'discountMarkupPerItemAbsolute'?: number;
}
/**
 * Client order nomenclature page schema.
 * @export
 * @interface ClientOrderNomenclaturePageSchema
 */
export interface ClientOrderNomenclaturePageSchema {
    /**
     * 
     * @type {Array<ClientOrderNomenclatureListSchema>}
     * @memberof ClientOrderNomenclaturePageSchema
     */
    'items': Array<ClientOrderNomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclaturePageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderNomenclaturePageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientOrderNomenclaturePageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientOrderNomenclaturePageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientOrderNomenclaturePageSchema
     */
    'totalPages': number;
}
/**
 * Client order nomenclature update schema.
 * @export
 * @interface ClientOrderNomenclatureUpdateSchema
 */
export interface ClientOrderNomenclatureUpdateSchema {
    /**
     * Nomenclature ID. Only active nomenclatures.
     * @type {number}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'nomenclatureId': number;
    /**
     * Nomenclature vendor code ID. Required for product nomenclatures.
     * @type {number}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'vendorCodeId'?: number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'quantity': number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'price': number;
    /**
     * Reserve nomenclature field.
     * @type {boolean}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'isReserve': boolean;
    /**
     * Field id. If None - new order nomenclature will be created.
     * @type {number}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'id'?: number;
    /**
     * Field for deleting order nomenclature
     * @type {boolean}
     * @memberof ClientOrderNomenclatureUpdateSchema
     */
    'isDeleted': boolean;
}
/**
 * Client orders page schema.
 * @export
 * @interface ClientOrderPage
 */
export interface ClientOrderPage {
    /**
     * 
     * @type {Array<ClientOrderListSchema>}
     * @memberof ClientOrderPage
     */
    'items': Array<ClientOrderListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientOrderPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientOrderPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientOrderPage
     */
    'totalPages': number;
}
/**
 * Client order read schema for client invoice/proforma list endpoints.
 * @export
 * @interface ClientOrderReadSchemaForDocumentsList
 */
export interface ClientOrderReadSchemaForDocumentsList {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'dateCreated': string;
    /**
     * 
     * @type {ClientOrderClientSchema}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'user': ClientOrderClientSchema;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof ClientOrderReadSchemaForDocumentsList
     */
    'contract'?: SimpleContractSchema;
}
/**
 * Client order update schema.
 * @export
 * @interface ClientOrderUpdateSchema
 */
export interface ClientOrderUpdateSchema {
    /**
     * Price category ID. Only active categories or categories.
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'priceCategoryId': number;
    /**
     * Currency rate. Only \'1\' for EUR currency
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'rate': number;
    /**
     * Only signed contracts. Only contract with selected currency for order. Client contract IDs for client. Supplier contract IDs for supplier.
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'contractId'?: number;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof ClientOrderUpdateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof ClientOrderUpdateSchema
     */
    'comment'?: string;
    /**
     * User currency ID. Only active client/supplier currencies.
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'userCurrencyId': number;
    /**
     * 1) Pulled up according to the selected currency of the Client (if no contractId).  2) Or, if a contract is selected, the current accounts/cashboxes specified. in the client\'s contract will be pulled up.  3) Active accounts and cashboxes are pulled up from the settings
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'accountCashboxId': number;
    /**
     * Sending warehouse ID.
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'warehouseId': number;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof ClientOrderUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientOrderUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {OrderUpdateStatuses}
     * @memberof ClientOrderUpdateSchema
     */
    'status': OrderUpdateStatuses;
    /**
     * 
     * @type {DiscountMarkupChangeSchema}
     * @memberof ClientOrderUpdateSchema
     */
    'discountMarkup'?: DiscountMarkupChangeSchema;
    /**
     * 
     * @type {Array<ClientOrderNomenclatureUpdateSchema>}
     * @memberof ClientOrderUpdateSchema
     */
    'orderNomenclatures': Array<ClientOrderNomenclatureUpdateSchema>;
}
/**
 * Client order with reserve list schema.
 * @export
 * @interface ClientOrderWithReserveListSchema
 */
export interface ClientOrderWithReserveListSchema {
    /**
     * 
     * @type {ClientOrderForReserveListSchema}
     * @memberof ClientOrderWithReserveListSchema
     */
    'order': ClientOrderForReserveListSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientOrderWithReserveListSchema
     */
    'reserveQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof ClientOrderWithReserveListSchema
     */
    'reservationDate': string;
}
/**
 * Client page schema.
 * @export
 * @interface ClientPage
 */
export interface ClientPage {
    /**
     * 
     * @type {Array<ClientListSchema>}
     * @memberof ClientPage
     */
    'items': Array<ClientListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientPage
     */
    'totalPages': number;
}
/**
 * Client proforma labels.
 * @export
 * @enum {string}
 */

export const ClientProductReturnLabels = {
    ClientInactive: 'client_inactive'
} as const;

export type ClientProductReturnLabels = typeof ClientProductReturnLabels[keyof typeof ClientProductReturnLabels];


/**
 * Base proforma read schema.
 * @export
 * @interface ClientProductReturnListSchema
 */
export interface ClientProductReturnListSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof ClientProductReturnListSchema
     */
    'status': ProductReturnStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientProductReturnListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnListSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientProductReturnListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientProductReturnListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientProductReturnListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnListSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientProductReturnListSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientProductReturnListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {CancellationSchema}
     * @memberof ClientProductReturnListSchema
     */
    'cancellation'?: CancellationSchema;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof ClientProductReturnListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {ClientInvoiceForProductReturnListSchema}
     * @memberof ClientProductReturnListSchema
     */
    'invoice': ClientInvoiceForProductReturnListSchema;
}
/**
 * BaseNomenclatureProductReturn create schema.
 * @export
 * @interface ClientProductReturnNomenclatureReadSchema
 */
export interface ClientProductReturnNomenclatureReadSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'discountMarkupPerItem'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'discountMarkupPerItemAbsolute'?: number;
    /**
     * 
     * @type {InvoiceNomenclatureForProductReturnsSchema}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'invoiceNomenclature': InvoiceNomenclatureForProductReturnsSchema;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnNomenclatureReadSchema
     */
    'maxProductReturnNomenclaturesQuantity'?: number;
}
/**
 * Client page schema.
 * @export
 * @interface ClientProductReturnPage
 */
export interface ClientProductReturnPage {
    /**
     * 
     * @type {Array<ClientProductReturnListSchema>}
     * @memberof ClientProductReturnPage
     */
    'items': Array<ClientProductReturnListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientProductReturnPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientProductReturnPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientProductReturnPage
     */
    'totalPages': number;
}
/**
 * Base proforma read schema.
 * @export
 * @interface ClientProductReturnSchema
 */
export interface ClientProductReturnSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof ClientProductReturnSchema
     */
    'status': ProductReturnStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientProductReturnSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ClientProductReturnSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProductReturnSchema
     */
    'discountMarkupTotal'?: number;
    /**
     * 
     * @type {ClientInvoiceForProductReturnDetailSchema}
     * @memberof ClientProductReturnSchema
     */
    'invoice': ClientInvoiceForProductReturnDetailSchema;
    /**
     * 
     * @type {Array<ClientProductReturnNomenclatureReadSchema>}
     * @memberof ClientProductReturnSchema
     */
    'clientProductReturnNomenclatures': Array<ClientProductReturnNomenclatureReadSchema>;
}
/**
 * Client proforma labels.
 * @export
 * @enum {string}
 */

export const ClientProformaLabels = {
    DatePaymentPassed: 'date_payment_passed',
    DatePaymentNotPassed: 'date_payment_not_passed',
    ClientInactive: 'client_inactive'
} as const;

export type ClientProformaLabels = typeof ClientProformaLabels[keyof typeof ClientProformaLabels];


/**
 * Base proforma read schema.
 * @export
 * @interface ClientProformaListSchema
 */
export interface ClientProformaListSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientProformaListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProformaStatuses}
     * @memberof ClientProformaListSchema
     */
    'status': ProformaStatuses;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientProformaListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof ClientProformaListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof ClientProformaListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientProformaListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientProformaListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientProformaListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientProformaListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {CancellationSchema}
     * @memberof ClientProformaListSchema
     */
    'cancellation'?: CancellationSchema;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof ClientProformaListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientProformaListSchema
     */
    'isCashPayment': boolean;
    /**
     * 
     * @type {ClientOrderListSchemaForProforma}
     * @memberof ClientProformaListSchema
     */
    'order': ClientOrderListSchemaForProforma;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaListSchema
     */
    'datePayment'?: string;
}
/**
 * BaseNomenclatureProforma create schema.
 * @export
 * @interface ClientProformaNomenclatureReadSchema
 */
export interface ClientProformaNomenclatureReadSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'discountMarkupPerItem'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'discountMarkupPerItemAbsolute'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'quantity': number;
    /**
     * 
     * @type {ClientOrderNomenclatureForClientDocumentSchema}
     * @memberof ClientProformaNomenclatureReadSchema
     */
    'orderNomenclature': ClientOrderNomenclatureForClientDocumentSchema;
}
/**
 * Client page schema.
 * @export
 * @interface ClientProformaPage
 */
export interface ClientProformaPage {
    /**
     * 
     * @type {Array<ClientProformaListSchema>}
     * @memberof ClientProformaPage
     */
    'items': Array<ClientProformaListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientProformaPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientProformaPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientProformaPage
     */
    'totalPages': number;
}
/**
 * Client proforma read schema.
 * @export
 * @interface ClientProformaSchema
 */
export interface ClientProformaSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ClientProformaSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ClientProformaSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'id': number;
    /**
     * 
     * @type {ProformaStatuses}
     * @memberof ClientProformaSchema
     */
    'status': ProformaStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ClientProformaSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaSchema
     */
    'datePayment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof ClientProformaSchema
     */
    'discountMarkupTotal'?: number;
    /**
     * 
     * @type {ClientOrderDetailSchemaForProforma}
     * @memberof ClientProformaSchema
     */
    'order': ClientOrderDetailSchemaForProforma;
    /**
     * 
     * @type {SimpleIncotermSchema}
     * @memberof ClientProformaSchema
     */
    'incoterm'?: SimpleIncotermSchema;
    /**
     * 
     * @type {Array<ClientProformaNomenclatureReadSchema>}
     * @memberof ClientProformaSchema
     */
    'clientProformaNomenclatures': Array<ClientProformaNomenclatureReadSchema>;
    /**
     * 
     * @type {DatePaymentLabel}
     * @memberof ClientProformaSchema
     */
    'datePaymentLabel'?: DatePaymentLabel;
    /**
     * 
     * @type {string}
     * @memberof ClientProformaSchema
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientProformaSchema
     */
    'isSkippedSlovenia': boolean;
}
/**
 * Client query order choices.
 * @export
 * @enum {string}
 */

export const ClientQueryOrder = {
    DateCreated: 'dateCreated'
} as const;

export type ClientQueryOrder = typeof ClientQueryOrder[keyof typeof ClientQueryOrder];


/**
 * Registration methods choices.
 * @export
 * @enum {string}
 */

export const ClientRegistrationMethods = {
    AddedByAgent: 'added_by_agent',
    AddedByStaff: 'added_by_staff',
    AddedByAdmin: 'added_by_admin',
    RegisteredAsClient: 'registered_as_client'
} as const;

export type ClientRegistrationMethods = typeof ClientRegistrationMethods[keyof typeof ClientRegistrationMethods];


/**
 * ClientSchema schema.
 * @export
 * @interface ClientSchema
 */
export interface ClientSchema {
    /**
     * Name
     * @type {string}
     * @memberof ClientSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof ClientSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof ClientSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof ClientSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof ClientSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof ClientSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof ClientSchema
     */
    'isVatPayer': boolean;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof ClientSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClientSchema
     */
    'avatar'?: string;
    /**
     * Additional user locations
     * @type {Array<UserLocationReadSchema>}
     * @memberof ClientSchema
     */
    'additionalLocations': Array<UserLocationReadSchema>;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof ClientSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * Sites
     * @type {Array<UserSiteReadSchema>}
     * @memberof ClientSchema
     */
    'sites': Array<UserSiteReadSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientSchema
     */
    'clientType': ClientTypes;
    /**
     * 
     * @type {ClientStatuses}
     * @memberof ClientSchema
     */
    'clientStatus': ClientStatuses;
    /**
     * 
     * @type {ClientRegistrationMethods}
     * @memberof ClientSchema
     */
    'clientRegistrationMethod': ClientRegistrationMethods;
    /**
     * 
     * @type {Array<UserCurrencyReadSchema>}
     * @memberof ClientSchema
     */
    'userCurrencies': Array<UserCurrencyReadSchema>;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof ClientSchema
     */
    'clientManager': SimpleStaffReadSchema;
    /**
     * 
     * @type {SimpleAgentReadSchema}
     * @memberof ClientSchema
     */
    'clientAgent'?: SimpleAgentReadSchema;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof ClientSchema
     */
    'clientCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof ClientSchema
     */
    'clientPriceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {ClientSourceSimpleSchema}
     * @memberof ClientSchema
     */
    'clientSource'?: ClientSourceSimpleSchema;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof ClientSchema
     */
    'clientMainContact': UserMainContactBaseReadSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof ClientSchema
     */
    'clientAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
    /**
     * 
     * @type {Array<UserDeliveryReadSchema>}
     * @memberof ClientSchema
     */
    'clientDeliveryMethods'?: Array<UserDeliveryReadSchema>;
}
/**
 * Client simple page schema.
 * @export
 * @interface ClientSimplePage
 */
export interface ClientSimplePage {
    /**
     * 
     * @type {Array<SimpleUserIsVatSchema>}
     * @memberof ClientSimplePage
     */
    'items': Array<SimpleUserIsVatSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientSimplePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientSimplePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientSimplePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientSimplePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientSimplePage
     */
    'totalPages': number;
}
/**
 * Create position schema.
 * @export
 * @interface ClientSourceCreateSchema
 */
export interface ClientSourceCreateSchema {
    /**
     * position name
     * @type {string}
     * @memberof ClientSourceCreateSchema
     */
    'name': string;
    /**
     * Is active
     * @type {boolean}
     * @memberof ClientSourceCreateSchema
     */
    'isActive': boolean;
}
/**
 * ClientSource schema.
 * @export
 * @interface ClientSourceDetailSchema
 */
export interface ClientSourceDetailSchema {
    /**
     * position name
     * @type {string}
     * @memberof ClientSourceDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClientSourceDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSourceDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientSourceDetailSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof ClientSourceDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof ClientSourceDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * ClientSource schema.
 * @export
 * @interface ClientSourceListSchema
 */
export interface ClientSourceListSchema {
    /**
     * position name
     * @type {string}
     * @memberof ClientSourceListSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClientSourceListSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSourceListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientSourceListSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof ClientSourceListSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof ClientSourceListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * ClientSource page schema.
 * @export
 * @interface ClientSourcePage
 */
export interface ClientSourcePage {
    /**
     * 
     * @type {Array<ClientSourceListSchema>}
     * @memberof ClientSourcePage
     */
    'items': Array<ClientSourceListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientSourcePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ClientSourcePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ClientSourcePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ClientSourcePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ClientSourcePage
     */
    'totalPages': number;
}
/**
 * Client source query params.
 * @export
 * @enum {string}
 */

export const ClientSourceQueryOrder = {
    Id: 'id',
    Name: 'name',
    DateCreated: 'dateCreated',
    Status: 'status'
} as const;

export type ClientSourceQueryOrder = typeof ClientSourceQueryOrder[keyof typeof ClientSourceQueryOrder];


/**
 * ClientSource schema.
 * @export
 * @interface ClientSourceSimpleSchema
 */
export interface ClientSourceSimpleSchema {
    /**
     * position name
     * @type {string}
     * @memberof ClientSourceSimpleSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClientSourceSimpleSchema
     */
    'id': number;
}
/**
 * Update position schema.
 * @export
 * @interface ClientSourceUpdateSchema
 */
export interface ClientSourceUpdateSchema {
    /**
     * position name
     * @type {string}
     * @memberof ClientSourceUpdateSchema
     */
    'name': string;
    /**
     * Is active
     * @type {boolean}
     * @memberof ClientSourceUpdateSchema
     */
    'isActive': boolean;
}
/**
 * Client staff agent labels query-filter for an agent list.
 * @export
 * @enum {string}
 */

export const ClientStaffAgentTypes = {
    Client: 'client',
    Staff: 'staff',
    Agent: 'agent'
} as const;

export type ClientStaffAgentTypes = typeof ClientStaffAgentTypes[keyof typeof ClientStaffAgentTypes];


/**
 * Client statuses choices.
 * @export
 * @enum {string}
 */

export const ClientStatuses = {
    Active: 'active',
    Inactive: 'inactive',
    InProcessing: 'in_processing',
    Unconfirmed: 'unconfirmed'
} as const;

export type ClientStatuses = typeof ClientStatuses[keyof typeof ClientStatuses];


/**
 * Supplier turn schema.
 * @export
 * @interface ClientTurnSchema
 */
export interface ClientTurnSchema {
    /**
     * Currencies ids to add to user
     * @type {Array<ClientCurrencyFormsetSchema>}
     * @memberof ClientTurnSchema
     */
    'userCurrencies': Array<ClientCurrencyFormsetSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof ClientTurnSchema
     */
    'clientMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactFormsetSchema>}
     * @memberof ClientTurnSchema
     */
    'clientAdditionalContacts'?: Array<UserAdditionalContactFormsetSchema>;
    /**
     * 
     * @type {Array<UserDeliveryFormsetSchema>}
     * @memberof ClientTurnSchema
     */
    'clientDeliveryMethods'?: Array<UserDeliveryFormsetSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientTurnSchema
     */
    'clientPriceCategoryId': number;
    /**
     * 
     * @type {string}
     * @memberof ClientTurnSchema
     */
    'clientManagerId': string;
    /**
     * 
     * @type {string}
     * @memberof ClientTurnSchema
     */
    'clientAgentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientTurnSchema
     */
    'clientCategoryId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientTurnSchema
     */
    'clientSourceId'?: number;
}
/**
 * Agent client statistic schema.
 * @export
 * @interface ClientTypeInvoicesStatisticsSchema
 */
export interface ClientTypeInvoicesStatisticsSchema {
    /**
     * 
     * @type {number}
     * @memberof ClientTypeInvoicesStatisticsSchema
     */
    'activeClientsCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClientTypeInvoicesStatisticsSchema
     */
    'clientsInvoicesConductedSum': number;
    /**
     * 
     * @type {number}
     * @memberof ClientTypeInvoicesStatisticsSchema
     */
    'clientsPaymentsSum': number;
    /**
     * 
     * @type {number}
     * @memberof ClientTypeInvoicesStatisticsSchema
     */
    'clientsDebtsSum': number;
}
/**
 * Client types choices.
 * @export
 * @enum {string}
 */

export const ClientTypes = {
    Retail: 'retail',
    AutoService: 'auto_service',
    Wholesale: 'wholesale'
} as const;

export type ClientTypes = typeof ClientTypes[keyof typeof ClientTypes];


/**
 * Staff activate schema.
 * @export
 * @interface ClientUpdateEmailSchema
 */
export interface ClientUpdateEmailSchema {
    /**
     * Email
     * @type {string}
     * @memberof ClientUpdateEmailSchema
     */
    'email': string;
    /**
     * Send email about new contact phone.
     * @type {boolean}
     * @memberof ClientUpdateEmailSchema
     */
    'sendEmail'?: boolean;
}
/**
 * Client update phone schema.
 * @export
 * @interface ClientUpdatePhoneSchema
 */
export interface ClientUpdatePhoneSchema {
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof ClientUpdatePhoneSchema
     */
    'phone': string;
}
/**
 * Create Client schema.
 * @export
 * @interface ClientUpdateSchema
 */
export interface ClientUpdateSchema {
    /**
     * Name
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientUpdateSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof ClientUpdateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof ClientUpdateSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * Additional user locations
     * @type {Array<UserLocationFormsetSchema>}
     * @memberof ClientUpdateSchema
     */
    'additionalLocations'?: Array<UserLocationFormsetSchema>;
    /**
     * Country id
     * @type {number}
     * @memberof ClientUpdateSchema
     */
    'countryId': number;
    /**
     * Sites
     * @type {Array<UserSiteFormsetSchema>}
     * @memberof ClientUpdateSchema
     */
    'sites'?: Array<UserSiteFormsetSchema>;
    /**
     * Currencies ids to add to user
     * @type {Array<ClientCurrencyFormsetSchema>}
     * @memberof ClientUpdateSchema
     */
    'userCurrencies': Array<ClientCurrencyFormsetSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof ClientUpdateSchema
     */
    'clientMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactFormsetSchema>}
     * @memberof ClientUpdateSchema
     */
    'clientAdditionalContacts'?: Array<UserAdditionalContactFormsetSchema>;
    /**
     * 
     * @type {Array<UserDeliveryFormsetSchema>}
     * @memberof ClientUpdateSchema
     */
    'clientDeliveryMethods'?: Array<UserDeliveryFormsetSchema>;
    /**
     * 
     * @type {number}
     * @memberof ClientUpdateSchema
     */
    'clientPriceCategoryId': number;
    /**
     * 
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'clientManagerId': string;
    /**
     * 
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'clientAgentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientUpdateSchema
     */
    'clientCategoryId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientUpdateSchema
     */
    'clientSourceId'?: number;
    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientUpdateSchema
     */
    'clientType': ClientTypes;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof ClientUpdateSchema
     */
    'vatNumber'?: string;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof ClientUpdateSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientUpdateSchema
     */
    'isCurrenciesUpdateActive'?: boolean;
}
/**
 * Client manager
 * @export
 * @interface Clientmanager
 */
export interface Clientmanager {
    /**
     * 
     * @type {string}
     * @memberof Clientmanager
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Clientmanager
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof Clientmanager
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Clientmanager
     */
    'avatar'?: string;
}
/**
 * Common nomenclature unit choices.
 * @export
 * @enum {string}
 */

export const CommonNomenclatureUnits = {
    Piece: 'piece',
    Package: 'package',
    Kilogram: 'kilogram',
    Liter: 'liter',
    Day: 'day',
    Hour: 'hour'
} as const;

export type CommonNomenclatureUnits = typeof CommonNomenclatureUnits[keyof typeof CommonNomenclatureUnits];


/**
 * Compensation cancellation schema.
 * @export
 * @interface CompensationCancellationSchema
 */
export interface CompensationCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof CompensationCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof CompensationCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Compensation change status choices.
 * @export
 * @enum {string}
 */

export const CompensationChangeStatuses = {
    Created: 'created',
    Conducted: 'conducted'
} as const;

export type CompensationChangeStatuses = typeof CompensationChangeStatuses[keyof typeof CompensationChangeStatuses];


/**
 * Compensation create schema.
 * @export
 * @interface CompensationCreateSchema
 */
export interface CompensationCreateSchema {
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CompensationCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CompensationCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CompensationCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * User currency id.
     * @type {number}
     * @memberof CompensationCreateSchema
     */
    'userCurrencyId': number;
    /**
     * Responsible id.
     * @type {string}
     * @memberof CompensationCreateSchema
     */
    'responsibleId': string;
    /**
     * Type.
     * @type {CompensationTypes}
     * @memberof CompensationCreateSchema
     */
    'type': CompensationTypes;
    /**
     * Allocated client invoice IDs. Only for \'invoices\' type.
     * @type {Set<number>}
     * @memberof CompensationCreateSchema
     */
    'allocatedClientInvoiceIds'?: Set<number>;
    /**
     * Allocated supplier invoice IDs. Only for \'invoices\' type.
     * @type {Set<number>}
     * @memberof CompensationCreateSchema
     */
    'allocatedSupplierInvoiceIds'?: Set<number>;
    /**
     * Allocated client product return IDs. Only for \'product_returns\' type.
     * @type {Set<number>}
     * @memberof CompensationCreateSchema
     */
    'allocatedClientProductReturnIds'?: Set<number>;
    /**
     * Allocated supplier product return IDs. Only for \'product_returns\' type.
     * @type {Set<number>}
     * @memberof CompensationCreateSchema
     */
    'allocatedSupplierProductReturnIds'?: Set<number>;
    /**
     * Contragent id.
     * @type {string}
     * @memberof CompensationCreateSchema
     */
    'contragentId': string;
}
/**
 * Compensation detail schema.
 * @export
 * @interface CompensationDetailSchema
 */
export interface CompensationDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof CompensationDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CompensationDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CompensationDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CompensationDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof CompensationDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CompensationDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof CompensationDetailSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationDetailSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompensationDetailSchema
     */
    'periodStart': string;
    /**
     * 
     * @type {string}
     * @memberof CompensationDetailSchema
     */
    'periodEnd': string;
    /**
     * 
     * @type {number}
     * @memberof CompensationDetailSchema
     */
    'amount': number;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof CompensationDetailSchema
     */
    'responsible': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {CompensationStatuses}
     * @memberof CompensationDetailSchema
     */
    'status': CompensationStatuses;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof CompensationDetailSchema
     */
    'contragent': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof CompensationDetailSchema
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {CompensationTypes}
     * @memberof CompensationDetailSchema
     */
    'type': CompensationTypes;
    /**
     * 
     * @type {Array<BaseCompensationInvoiceDetailSchema>}
     * @memberof CompensationDetailSchema
     */
    'allocatedClientInvoices': Array<BaseCompensationInvoiceDetailSchema>;
    /**
     * 
     * @type {Array<BaseCompensationInvoiceDetailSchema>}
     * @memberof CompensationDetailSchema
     */
    'allocatedSupplierInvoices': Array<BaseCompensationInvoiceDetailSchema>;
    /**
     * 
     * @type {Array<BaseCompensationProductReturnDetailSchema>}
     * @memberof CompensationDetailSchema
     */
    'allocatedClientProductReturns': Array<BaseCompensationProductReturnDetailSchema>;
    /**
     * 
     * @type {Array<BaseCompensationProductReturnDetailSchema>}
     * @memberof CompensationDetailSchema
     */
    'allocatedSupplierProductReturns': Array<BaseCompensationProductReturnDetailSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationDetailSchema
     */
    'hasConductPermission'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationDetailSchema
     */
    'hasCancelPermission'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationDetailSchema
     */
    'canConduct'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationDetailSchema
     */
    'canCancel'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationDetailSchema
     */
    'canDelete'?: boolean;
}
/**
 * Compensation list schema.
 * @export
 * @interface CompensationListSchema
 */
export interface CompensationListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof CompensationListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {number}
     * @memberof CompensationListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CompensationListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof CompensationListSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CompensationListSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompensationListSchema
     */
    'periodStart': string;
    /**
     * 
     * @type {string}
     * @memberof CompensationListSchema
     */
    'periodEnd': string;
    /**
     * 
     * @type {number}
     * @memberof CompensationListSchema
     */
    'amount': number;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof CompensationListSchema
     */
    'responsible': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {CompensationStatuses}
     * @memberof CompensationListSchema
     */
    'status': CompensationStatuses;
    /**
     * 
     * @type {BaseOrderUserSchema}
     * @memberof CompensationListSchema
     */
    'contragent': BaseOrderUserSchema;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof CompensationListSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof CompensationListSchema
     */
    'creator': BaseSimpleUserReadSchema;
}
/**
 * Compensation page schema.
 * @export
 * @interface CompensationPage
 */
export interface CompensationPage {
    /**
     * 
     * @type {Array<CompensationListSchema>}
     * @memberof CompensationPage
     */
    'items': Array<CompensationListSchema>;
    /**
     * 
     * @type {number}
     * @memberof CompensationPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof CompensationPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof CompensationPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof CompensationPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof CompensationPage
     */
    'totalPages': number;
}
/**
 * BaseInvoiceQueryOrder model.
 * @export
 * @enum {string}
 */

export const CompensationQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    DateConduction: 'dateConduction',
    Amount: 'amount'
} as const;

export type CompensationQueryOrder = typeof CompensationQueryOrder[keyof typeof CompensationQueryOrder];


/**
 * Compensation status choices.
 * @export
 * @enum {string}
 */

export const CompensationStatuses = {
    Created: 'created',
    Conducted: 'conducted',
    Deleted: 'deleted'
} as const;

export type CompensationStatuses = typeof CompensationStatuses[keyof typeof CompensationStatuses];


/**
 * Compensation type choices.
 * @export
 * @enum {string}
 */

export const CompensationTypes = {
    Invoices: 'invoices',
    ProductReturns: 'product_returns'
} as const;

export type CompensationTypes = typeof CompensationTypes[keyof typeof CompensationTypes];


/**
 * Compensation update schema.
 * @export
 * @interface CompensationUpdateSchema
 */
export interface CompensationUpdateSchema {
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CompensationUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CompensationUpdateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CompensationUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * User currency id.
     * @type {number}
     * @memberof CompensationUpdateSchema
     */
    'userCurrencyId': number;
    /**
     * Responsible id.
     * @type {string}
     * @memberof CompensationUpdateSchema
     */
    'responsibleId': string;
    /**
     * Type.
     * @type {CompensationTypes}
     * @memberof CompensationUpdateSchema
     */
    'type': CompensationTypes;
    /**
     * Allocated client invoice IDs. Only for \'invoices\' type.
     * @type {Set<number>}
     * @memberof CompensationUpdateSchema
     */
    'allocatedClientInvoiceIds'?: Set<number>;
    /**
     * Allocated supplier invoice IDs. Only for \'invoices\' type.
     * @type {Set<number>}
     * @memberof CompensationUpdateSchema
     */
    'allocatedSupplierInvoiceIds'?: Set<number>;
    /**
     * Allocated client product return IDs. Only for \'product_returns\' type.
     * @type {Set<number>}
     * @memberof CompensationUpdateSchema
     */
    'allocatedClientProductReturnIds'?: Set<number>;
    /**
     * Allocated supplier product return IDs. Only for \'product_returns\' type.
     * @type {Set<number>}
     * @memberof CompensationUpdateSchema
     */
    'allocatedSupplierProductReturnIds'?: Set<number>;
    /**
     * Status.
     * @type {CompensationChangeStatuses}
     * @memberof CompensationUpdateSchema
     */
    'status': CompensationChangeStatuses;
}
/**
 * Simple base order schema.
 * @export
 * @interface ComplexBaseOrderSchema
 */
export interface ComplexBaseOrderSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ComplexBaseOrderSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ComplexBaseOrderSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ComplexBaseOrderSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ComplexBaseOrderSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof ComplexBaseOrderSchema
     */
    'user': BaseSimpleUserReadSchema;
}
/**
 * Complex nomenclature schema.
 * @export
 * @interface ComplexNomenclatureSchema
 */
export interface ComplexNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof ComplexNomenclatureSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ComplexNomenclatureSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ComplexNomenclatureSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof ComplexNomenclatureSchema
     */
    'unit': CommonNomenclatureUnits;
    /**
     * 
     * @type {number}
     * @memberof ComplexNomenclatureSchema
     */
    'weight'?: number;
}
/**
 * Simple user currency creates schema.
 * @export
 * @interface ComplexUserCurrencyReadSchema
 */
export interface ComplexUserCurrencyReadSchema {
    /**
     * 
     * @type {number}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'id': number;
    /**
     * 
     * @type {BaseCurrencySchema}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'currency': BaseCurrencySchema;
    /**
     * 
     * @type {number}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'clientBalance': number;
    /**
     * 
     * @type {number}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'supplierBalance': number;
    /**
     * 
     * @type {UserCreditLimitSchemaReadSchema}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'clientCreditLimit': UserCreditLimitSchemaReadSchema;
    /**
     * 
     * @type {UserCreditLimitSchemaReadSchema}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'supplierCreditLimit': UserCreditLimitSchemaReadSchema;
    /**
     * 
     * @type {number}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'availableClientBalance': number;
    /**
     * 
     * @type {number}
     * @memberof ComplexUserCurrencyReadSchema
     */
    'availableSupplierBalance': number;
}
/**
 * Base user schema with supplier category.
 * @export
 * @interface ComplexUserSchema
 */
export interface ComplexUserSchema {
    /**
     * 
     * @type {string}
     * @memberof ComplexUserSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ComplexUserSchema
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof ComplexUserSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ComplexUserSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ComplexUserSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {VatRates}
     * @memberof ComplexUserSchema
     */
    'vatRate': VatRates;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof ComplexUserSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {Suppliercategory}
     * @memberof ComplexUserSchema
     */
    'supplierCategory'?: Suppliercategory;
    /**
     * 
     * @type {Suppliermanager}
     * @memberof ComplexUserSchema
     */
    'supplierManager'?: Suppliermanager;
    /**
     * 
     * @type {Clientmanager}
     * @memberof ComplexUserSchema
     */
    'clientManager'?: Clientmanager;
    /**
     * Client type
     * @type {ClientTypes}
     * @memberof ComplexUserSchema
     */
    'clientType'?: ClientTypes;
    /**
     * 
     * @type {boolean}
     * @memberof ComplexUserSchema
     */
    'isActiveSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ComplexUserSchema
     */
    'isActiveClient': boolean;
}
/**
 * 
 * @export
 * @interface ContentId
 */
export interface ContentId {
}
/**
 * ContractDetailSchema schema.
 * @export
 * @interface ContractDetailSchema
 */
export interface ContractDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'dateStart': string;
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'dateEnd': string;
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ContractDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ContractDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ContractDetailSchema
     */
    'dateSign'?: string;
    /**
     * 
     * @type {ContractStatuses}
     * @memberof ContractDetailSchema
     */
    'status': ContractStatuses;
    /**
     * 
     * @type {ContractTypes}
     * @memberof ContractDetailSchema
     */
    'type': ContractTypes;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ContractDetailSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractDetailSchema
     */
    'language': ContractTemplateLanguage;
    /**
     * 
     * @type {Array<AccountCashboxSimpleSchema>}
     * @memberof ContractDetailSchema
     */
    'accountCashboxes': Array<AccountCashboxSimpleSchema>;
    /**
     * 
     * @type {SimpleIncotermSchema}
     * @memberof ContractDetailSchema
     */
    'incoterm'?: SimpleIncotermSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ContractDetailSchema
     */
    'user': SimpleUserSchema;
    /**
     * 
     * @type {number}
     * @memberof ContractDetailSchema
     */
    'prepaymentPercent'?: number;
    /**
     * 
     * @type {ContractTransportModes}
     * @memberof ContractDetailSchema
     */
    'transportMode'?: ContractTransportModes;
}
/**
 * Contract export types.
 * @export
 * @enum {string}
 */

export const ContractExportType = {
    Docx: 'docx',
    Pdf: 'pdf'
} as const;

export type ContractExportType = typeof ContractExportType[keyof typeof ContractExportType];


/**
 * UserContractLanguage model.
 * @export
 * @enum {string}
 */

export const ContractLanguage = {
    Ru: 'ru',
    En: 'en',
    Sl: 'sl',
    Uk: 'uk'
} as const;

export type ContractLanguage = typeof ContractLanguage[keyof typeof ContractLanguage];


/**
 * ContractLanguageInfoBaseSchema schema.
 * @export
 * @interface ContractLanguageInfoBaseSchema
 */
export interface ContractLanguageInfoBaseSchema {
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'cityForSignature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'buyerCompanyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'buyerDirectorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'sellerCompanyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'sellerDirectorName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'amountWords'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'disputePlace'?: string;
    /**
     * 
     * @type {ContractLanguage}
     * @memberof ContractLanguageInfoBaseSchema
     */
    'language': ContractLanguage;
}
/**
 * ContractLanguageInfoUpdateOrCreateSchema schema.
 * @export
 * @interface ContractLanguageInfoReadSchema
 */
export interface ContractLanguageInfoReadSchema {
    /**
     * 
     * @type {Array<ContractLanguageInfoBaseSchema>}
     * @memberof ContractLanguageInfoReadSchema
     */
    'items': Array<ContractLanguageInfoBaseSchema>;
    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractLanguageInfoReadSchema
     */
    'language': ContractTemplateLanguage;
}
/**
 * ContractLanguageInfoUpdateOrCreateSchema schema.
 * @export
 * @interface ContractLanguageInfoUpdateSchema
 */
export interface ContractLanguageInfoUpdateSchema {
    /**
     * 
     * @type {Array<ContractLanguageInfoBaseSchema>}
     * @memberof ContractLanguageInfoUpdateSchema
     */
    'items': Array<ContractLanguageInfoBaseSchema>;
    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractLanguageInfoUpdateSchema
     */
    'language': ContractTemplateLanguage;
}
/**
 * ContractListSchema schema.
 * @export
 * @interface ContractListSchema
 */
export interface ContractListSchema {
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'dateStart': string;
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'dateEnd': string;
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ContractListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ContractListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ContractListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ContractListSchema
     */
    'dateSign'?: string;
    /**
     * 
     * @type {ContractStatuses}
     * @memberof ContractListSchema
     */
    'status': ContractStatuses;
    /**
     * 
     * @type {ContractTypes}
     * @memberof ContractListSchema
     */
    'type': ContractTypes;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof ContractListSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractListSchema
     */
    'language': ContractTemplateLanguage;
    /**
     * 
     * @type {ComplexUserSchema}
     * @memberof ContractListSchema
     */
    'user': ComplexUserSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ContractListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof ContractListSchema
     */
    'labelList'?: Array<LabelListSchema>;
}
/**
 * Contract order.
 * @export
 * @enum {string}
 */

export const ContractQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    DateSign: 'dateSign'
} as const;

export type ContractQueryOrder = typeof ContractQueryOrder[keyof typeof ContractQueryOrder];


/**
 * UserContractStatus model.
 * @export
 * @enum {string}
 */

export const ContractStatuses = {
    Created: 'created',
    Signed: 'signed',
    Cancelled: 'cancelled'
} as const;

export type ContractStatuses = typeof ContractStatuses[keyof typeof ContractStatuses];


/**
 * UserContractLanguage model.
 * @export
 * @enum {string}
 */

export const ContractTemplateLanguage = {
    Ru: 'ru',
    En: 'en',
    Sl: 'sl',
    SlRu: 'sl_ru',
    SlEn: 'sl_en',
    RuEn: 'ru_en',
    UkEn: 'uk_en'
} as const;

export type ContractTemplateLanguage = typeof ContractTemplateLanguage[keyof typeof ContractTemplateLanguage];


/**
 * ContractTemplateSchema schema.
 * @export
 * @interface ContractTemplateWithFileReadSchema
 */
export interface ContractTemplateWithFileReadSchema {
    /**
     * 
     * @type {number}
     * @memberof ContractTemplateWithFileReadSchema
     */
    'id': number;
    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractTemplateWithFileReadSchema
     */
    'language': ContractTemplateLanguage;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplateWithFileReadSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplateWithFileReadSchema
     */
    'dateUpdated': string;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplateWithFileReadSchema
     */
    'file': string;
}
/**
 * Contract transport mode.
 * @export
 * @enum {string}
 */

export const ContractTransportModes = {
    Air: 'air',
    Sea: 'sea',
    Road: 'road',
    Rail: 'rail'
} as const;

export type ContractTransportModes = typeof ContractTransportModes[keyof typeof ContractTransportModes];


/**
 * ContractType model.
 * @export
 * @enum {string}
 */

export const ContractTypes = {
    Equipment: 'equipment',
    SpareParts: 'spare_parts'
} as const;

export type ContractTypes = typeof ContractTypes[keyof typeof ContractTypes];


/**
 * ContractUpdateSchema schema.
 * @export
 * @interface ContractUpdateSchema
 */
export interface ContractUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof ContractUpdateSchema
     */
    'dateStart': string;
    /**
     * 
     * @type {string}
     * @memberof ContractUpdateSchema
     */
    'dateEnd': string;
    /**
     * 
     * @type {string}
     * @memberof ContractUpdateSchema
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractUpdateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ContractUpdateSchema
     */
    'accountCashboxIds': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ContractUpdateSchema
     */
    'userCurrencyId': number;
    /**
     * 
     * @type {number}
     * @memberof ContractUpdateSchema
     */
    'incotermId'?: number;
    /**
     * Prepayment percent. Used only for equipment contract type.
     * @type {number}
     * @memberof ContractUpdateSchema
     */
    'prepaymentPercent'?: number;
    /**
     * Transport mode. Used only for equipment contract type.
     * @type {ContractTransportModes}
     * @memberof ContractUpdateSchema
     */
    'transportMode'?: ContractTransportModes;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ContractUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof ContractUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ContractUpdateSchema
     */
    'documentNumberSuffix'?: string;
}
/**
 * Contracts page schema.
 * @export
 * @interface ContractsPage
 */
export interface ContractsPage {
    /**
     * 
     * @type {Array<ContractListSchema>}
     * @memberof ContractsPage
     */
    'items': Array<ContractListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ContractsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ContractsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ContractsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ContractsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ContractsPage
     */
    'totalPages': number;
}
/**
 * Counter agent kinds choices.
 * @export
 * @enum {string}
 */

export const CounterAgentKinds = {
    LegalEntity: 'legal_entity',
    Entrepreneur: 'entrepreneur',
    PhysicalEntity: 'physical_entity'
} as const;

export type CounterAgentKinds = typeof CounterAgentKinds[keyof typeof CounterAgentKinds];


/**
 * Schema for countries page.
 * @export
 * @interface CountriesPage
 */
export interface CountriesPage {
    /**
     * 
     * @type {Array<CountrySchema>}
     * @memberof CountriesPage
     */
    'items': Array<CountrySchema>;
    /**
     * 
     * @type {number}
     * @memberof CountriesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof CountriesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof CountriesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof CountriesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof CountriesPage
     */
    'totalPages': number;
}
/**
 * Schema for countries on register page.
 * @export
 * @interface CountriesRegisterPage
 */
export interface CountriesRegisterPage {
    /**
     * 
     * @type {Array<RegisterCountrySchema>}
     * @memberof CountriesRegisterPage
     */
    'items': Array<RegisterCountrySchema>;
    /**
     * 
     * @type {number}
     * @memberof CountriesRegisterPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof CountriesRegisterPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof CountriesRegisterPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof CountriesRegisterPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof CountriesRegisterPage
     */
    'totalPages': number;
}
/**
 * Country detail schema.
 * @export
 * @interface CountryDetailSchema
 */
export interface CountryDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof CountryDetailSchema
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountryDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryDetailSchema
     */
    'phoneCode': string;
    /**
     * 
     * @type {string}
     * @memberof CountryDetailSchema
     */
    'flag': string;
    /**
     * 
     * @type {boolean}
     * @memberof CountryDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CountryDetailSchema
     */
    'isEu': boolean;
    /**
     * 
     * @type {string}
     * @memberof CountryDetailSchema
     */
    'nameIso2': string;
    /**
     * 
     * @type {number}
     * @memberof CountryDetailSchema
     */
    'numericCode'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CountryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof CountryDetailSchema
     */
    'dateCreated': string;
}
/**
 * Country params mode enum for filtering by EU.
 * @export
 * @enum {string}
 */

export const CountryEUQueryFilter = {
    All: 'all',
    Yes: 'yes',
    No: 'no'
} as const;

export type CountryEUQueryFilter = typeof CountryEUQueryFilter[keyof typeof CountryEUQueryFilter];


/**
 * Country params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const CountryQueryOrder = {
    Id: 'id',
    Name: 'name',
    NameIso2: 'nameIso2',
    NumericCode: 'numericCode',
    IsEu: 'isEu',
    IsActive: 'isActive'
} as const;

export type CountryQueryOrder = typeof CountryQueryOrder[keyof typeof CountryQueryOrder];


/**
 * Country schema.
 * @export
 * @interface CountrySchema
 */
export interface CountrySchema {
    /**
     * 
     * @type {number}
     * @memberof CountrySchema
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountrySchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CountrySchema
     */
    'phoneCode': string;
    /**
     * 
     * @type {string}
     * @memberof CountrySchema
     */
    'flag': string;
    /**
     * 
     * @type {boolean}
     * @memberof CountrySchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CountrySchema
     */
    'isEu': boolean;
    /**
     * 
     * @type {string}
     * @memberof CountrySchema
     */
    'nameIso2': string;
    /**
     * 
     * @type {number}
     * @memberof CountrySchema
     */
    'numericCode'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CountrySchema
     */
    'isActive': boolean;
}
/**
 * Country simple schema.
 * @export
 * @interface CountrySimpleReadSchema
 */
export interface CountrySimpleReadSchema {
    /**
     * 
     * @type {number}
     * @memberof CountrySimpleReadSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CountrySimpleReadSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CountrySimpleReadSchema
     */
    'nameIso2': string;
    /**
     * 
     * @type {number}
     * @memberof CountrySimpleReadSchema
     */
    'numericCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountrySimpleReadSchema
     */
    'fullCountryString'?: string;
}
/**
 * Country update schema.
 * @export
 * @interface CountryUpdateSchema
 */
export interface CountryUpdateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof CountryUpdateSchema
     */
    'isActive': boolean;
}
/**
 * ClientProductReturn create schema.
 * @export
 * @interface CreateClientProductReturnSchema
 */
export interface CreateClientProductReturnSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateClientProductReturnSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateClientProductReturnSchema
     */
    'warehouseId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateClientProductReturnSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CreateClientProductReturnSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CreateClientProductReturnSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CreateClientProductReturnSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {Array<BaseProductReturnNomenclatureSchema>}
     * @memberof CreateClientProductReturnSchema
     */
    'clientProductReturnNomenclatures': Array<BaseProductReturnNomenclatureSchema>;
}
/**
 * ClientProforma create schema.
 * @export
 * @interface CreateClientProformaSchema
 */
export interface CreateClientProformaSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateClientProformaSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientProformaSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CreateClientProformaSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CreateClientProformaSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CreateClientProformaSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {Array<BaseProformaNomenclatureSchema>}
     * @memberof CreateClientProformaSchema
     */
    'clientProformaNomenclatures': Array<BaseProformaNomenclatureSchema>;
}
/**
 * SupplierProductReturn create schema.
 * @export
 * @interface CreateSupplierProductReturnSchema
 */
export interface CreateSupplierProductReturnSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateSupplierProductReturnSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateSupplierProductReturnSchema
     */
    'warehouseId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateSupplierProductReturnSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CreateSupplierProductReturnSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CreateSupplierProductReturnSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CreateSupplierProductReturnSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {Array<BaseProductReturnNomenclatureSchema>}
     * @memberof CreateSupplierProductReturnSchema
     */
    'supplierProductReturnNomenclatures': Array<BaseProductReturnNomenclatureSchema>;
}
/**
 * SupplierProforma create schema.
 * @export
 * @interface CreateSupplierProformaSchema
 */
export interface CreateSupplierProformaSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateSupplierProformaSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSupplierProformaSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof CreateSupplierProformaSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof CreateSupplierProformaSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof CreateSupplierProformaSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSupplierProformaSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSupplierProformaSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {Array<BaseProformaNomenclatureSchema>}
     * @memberof CreateSupplierProformaSchema
     */
    'supplierProformaNomenclatures': Array<BaseProformaNomenclatureSchema>;
}
/**
 * Creator user schema.
 * @export
 * @interface CreatorUserSchema
 */
export interface CreatorUserSchema {
    /**
     * 
     * @type {string}
     * @memberof CreatorUserSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorUserSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatorUserSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreatorUserSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatorUserSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatorUserSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatorUserSchema
     */
    'isStaff': boolean;
}
/**
 * Currency debt schema.
 * @export
 * @interface CurrencyDebtSchema
 */
export interface CurrencyDebtSchema {
    /**
     * 
     * @type {string}
     * @memberof CurrencyDebtSchema
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyDebtSchema
     */
    'totalDebtAbs': number;
}
/**
 * Currency detail schema.
 * @export
 * @interface CurrencyDetailSchema
 */
export interface CurrencyDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof CurrencyDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDetailSchema
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyDetailSchema
     */
    'rate': number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyDetailSchema
     */
    'isSyncWithNetwork': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDetailSchema
     */
    'dateUpdated': string;
}
/**
 * Schema for currency history page.
 * @export
 * @interface CurrencyHistoryPage
 */
export interface CurrencyHistoryPage {
    /**
     * 
     * @type {Array<CurrencyHistorySchema>}
     * @memberof CurrencyHistoryPage
     */
    'items': Array<CurrencyHistorySchema>;
    /**
     * 
     * @type {number}
     * @memberof CurrencyHistoryPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof CurrencyHistoryPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof CurrencyHistoryPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof CurrencyHistoryPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof CurrencyHistoryPage
     */
    'totalPages': number;
}
/**
 * Currency history schema.
 * @export
 * @interface CurrencyHistorySchema
 */
export interface CurrencyHistorySchema {
    /**
     * 
     * @type {number}
     * @memberof CurrencyHistorySchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CurrencyHistorySchema
     */
    'rate': number;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof CurrencyHistorySchema
     */
    'creator'?: SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof CurrencyHistorySchema
     */
    'dateCreated': string;
}
/**
 * Currency payment operation schema.
 * @export
 * @interface CurrencyPaymentOperationSchema
 */
export interface CurrencyPaymentOperationSchema {
    /**
     * 
     * @type {string}
     * @memberof CurrencyPaymentOperationSchema
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyPaymentOperationSchema
     */
    'totalIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrencyPaymentOperationSchema
     */
    'totalExpense'?: number;
}
/**
 * Currency params mode enum for the main page ordering.
 * @export
 * @enum {string}
 */

export const CurrencyQueryOrder = {
    Id: 'id',
    DateCreated: 'dateCreated'
} as const;

export type CurrencyQueryOrder = typeof CurrencyQueryOrder[keyof typeof CurrencyQueryOrder];


/**
 * Currency schema.
 * @export
 * @interface CurrencySchema
 */
export interface CurrencySchema {
    /**
     * 
     * @type {number}
     * @memberof CurrencySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CurrencySchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencySchema
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencySchema
     */
    'rate': number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencySchema
     */
    'isSyncWithNetwork': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencySchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencySchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrencySchema
     */
    'dateCreated': string;
}
/**
 * Currency update schema.
 * @export
 * @interface CurrencyUpdateSchema
 */
export interface CurrencyUpdateSchema {
    /**
     * Rate
     * @type {number}
     * @memberof CurrencyUpdateSchema
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyUpdateSchema
     */
    'isSyncWithNetwork': boolean;
}
/**
 * Data export types.
 * @export
 * @enum {string}
 */

export const DataExportType = {
    Xlsx: 'xlsx',
    Pdf: 'pdf'
} as const;

export type DataExportType = typeof DataExportType[keyof typeof DataExportType];


/**
 * Date payment label schema.
 * @export
 * @interface DatePaymentLabel
 */
export interface DatePaymentLabel {
    /**
     * 
     * @type {string}
     * @memberof DatePaymentLabel
     */
    'datePaymentText'?: string;
    /**
     * 
     * @type {LabelLevel}
     * @memberof DatePaymentLabel
     */
    'datePaymentLevel'?: LabelLevel;
}
/**
 * Deactivate staff schema.
 * @export
 * @interface DeactivateStaffSchema
 */
export interface DeactivateStaffSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof DeactivateStaffSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof DeactivateStaffSchema
     */
    'cancellationReasonId'?: number;
    /**
     * 
     * @type {ChangeUnclosedDocumentResponsibleListSchema}
     * @memberof DeactivateStaffSchema
     */
    'unclosedDocuments': ChangeUnclosedDocumentResponsibleListSchema;
    /**
     * Staff user automatic activation date. If not specified, staff should be activated manually.
     * @type {string}
     * @memberof DeactivateStaffSchema
     */
    'autoActivateDate'?: string;
}
/**
 * Debt or overpayment schema.
 * @export
 * @interface DebtOrOverpaymentSchema
 */
export interface DebtOrOverpaymentSchema {
    /**
     * 
     * @type {number}
     * @memberof DebtOrOverpaymentSchema
     */
    'sum': number;
    /**
     * 
     * @type {CurrencySchema}
     * @memberof DebtOrOverpaymentSchema
     */
    'currency': CurrencySchema;
}
/**
 * Debt schema.
 * @export
 * @interface DebtSchema
 */
export interface DebtSchema {
    /**
     * 
     * @type {number}
     * @memberof DebtSchema
     */
    'sum': number;
    /**
     * 
     * @type {string}
     * @memberof DebtSchema
     */
    'dateUntil': string;
    /**
     * 
     * @type {OrderDebtDocumentSchema}
     * @memberof DebtSchema
     */
    'document': OrderDebtDocumentSchema;
}
/**
 * Default profit report query order enum.
 * @export
 * @enum {string}
 */

export const DefaultProfitReportQueryOrder = {
    Id: 'id',
    Name: 'name',
    Turnover: 'turnover',
    Cost: 'cost',
    Profit: 'profit',
    Percentage: 'percentage'
} as const;

export type DefaultProfitReportQueryOrder = typeof DefaultProfitReportQueryOrder[keyof typeof DefaultProfitReportQueryOrder];


/**
 * User delivery method choices.
 * @export
 * @enum {string}
 */

export const DeliveryMethods = {
    Dhl: 'dhl',
    NovaPoshta: 'nova_poshta',
    Gunsel: 'gunsel',
    SelfDelivery: 'self_delivery'
} as const;

export type DeliveryMethods = typeof DeliveryMethods[keyof typeof DeliveryMethods];


/**
 * Discount markup change schema.
 * @export
 * @interface DiscountMarkupChangeSchema
 */
export interface DiscountMarkupChangeSchema {
    /**
     * Discount if True. Markup if False.
     * @type {boolean}
     * @memberof DiscountMarkupChangeSchema
     */
    'isDiscount': boolean;
    /**
     * Type choices.
     * @type {DiscountMarkupTypes}
     * @memberof DiscountMarkupChangeSchema
     */
    'type': DiscountMarkupTypes;
    /**
     * Value field.
     * @type {number}
     * @memberof DiscountMarkupChangeSchema
     */
    'value': number;
}
/**
 * Discount markup detail schema.
 * @export
 * @interface DiscountMarkupDetailSchema
 */
export interface DiscountMarkupDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof DiscountMarkupDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof DiscountMarkupDetailSchema
     */
    'isDiscount': boolean;
    /**
     * 
     * @type {DiscountMarkupTypes}
     * @memberof DiscountMarkupDetailSchema
     */
    'type': DiscountMarkupTypes;
    /**
     * 
     * @type {number}
     * @memberof DiscountMarkupDetailSchema
     */
    'value': number;
}
/**
 * OrderStatus model.
 * @export
 * @enum {string}
 */

export const DiscountMarkupTypes = {
    PercentPerItem: 'percent_per_item',
    TotalAmount: 'total_amount',
    AmountPerItem: 'amount_per_item'
} as const;

export type DiscountMarkupTypes = typeof DiscountMarkupTypes[keyof typeof DiscountMarkupTypes];


/**
 * User languages choices.
 * @export
 * @enum {string}
 */

export const DocumentLanguages = {
    Ru: 'ru',
    En: 'en',
    Sl: 'sl'
} as const;

export type DocumentLanguages = typeof DocumentLanguages[keyof typeof DocumentLanguages];


/**
 * Document list schema.
 * @export
 * @interface DocumentListSchema
 */
export interface DocumentListSchema {
    /**
     * 
     * @type {string}
     * @memberof DocumentListSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentListSchema
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof DocumentListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof DocumentListSchema
     */
    'creatorKind': UserTypes;
}
/**
 * Nomenclature movement schema.
 * @export
 * @interface DocumentNomenclatureSchema
 */
export interface DocumentNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof DocumentNomenclatureSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentNomenclatureSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentNomenclatureSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {Array<VendorCodeListSchema>}
     * @memberof DocumentNomenclatureSchema
     */
    'vendorCodes'?: Array<VendorCodeListSchema>;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof DocumentNomenclatureSchema
     */
    'unit': CommonNomenclatureUnits;
    /**
     * 
     * @type {number}
     * @memberof DocumentNomenclatureSchema
     */
    'minOrderQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentNomenclatureSchema
     */
    'costPrice'?: number;
}
/**
 * Document page schema.
 * @export
 * @interface DocumentPageSchema
 */
export interface DocumentPageSchema {
    /**
     * 
     * @type {Array<DocumentListSchema>}
     * @memberof DocumentPageSchema
     */
    'items': Array<DocumentListSchema>;
    /**
     * 
     * @type {number}
     * @memberof DocumentPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof DocumentPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof DocumentPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof DocumentPageSchema
     */
    'totalPages': number;
}
/**
 * Document query order enum.
 * @export
 * @enum {string}
 */

export const DocumentQueryOrder = {
    Id: 'id',
    Name: 'name',
    DateCreated: 'date_created',
    CreatorName: 'creator_name'
} as const;

export type DocumentQueryOrder = typeof DocumentQueryOrder[keyof typeof DocumentQueryOrder];


/**
 * Document type enum.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    ClientContract: 'client_contract',
    SupplierContract: 'supplier_contract',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return',
    ClientProforma: 'client_proforma',
    SupplierProforma: 'supplier_proforma',
    Agent: 'agent',
    Client: 'client',
    Supplier: 'supplier'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * Nomenclature expected filter enum.
 * @export
 * @enum {string}
 */

export const ExpectedFilter = {
    Expected: 'expected',
    NotExpected: 'not_expected'
} as const;

export type ExpectedFilter = typeof ExpectedFilter[keyof typeof ExpectedFilter];


/**
 * Fin item additional expense create schema.
 * @export
 * @interface FinItemAdditionalExpenseChangeSchema
 */
export interface FinItemAdditionalExpenseChangeSchema {
    /**
     * If None - new financial item for allocation will be created.
     * @type {number}
     * @memberof FinItemAdditionalExpenseChangeSchema
     */
    'id'?: number;
    /**
     * Financial analysis item ID
     * @type {number}
     * @memberof FinItemAdditionalExpenseChangeSchema
     */
    'finItemId': number;
    /**
     * Additional expenses list for financial analysis item
     * @type {Array<FinItemNomenclatureAdditionalExpenseChangeSchema>}
     * @memberof FinItemAdditionalExpenseChangeSchema
     */
    'additionalExpenses': Array<FinItemNomenclatureAdditionalExpenseChangeSchema>;
    /**
     * Field for deleting client invoice.
     * @type {boolean}
     * @memberof FinItemAdditionalExpenseChangeSchema
     */
    'isDeleted'?: boolean;
}
/**
 * Fin item additional expense schema.
 * @export
 * @interface FinItemAdditionalExpenseSchema
 */
export interface FinItemAdditionalExpenseSchema {
    /**
     * 
     * @type {number}
     * @memberof FinItemAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {SimpleFinancialAnalysisItemSchema}
     * @memberof FinItemAdditionalExpenseSchema
     */
    'finItem': SimpleFinancialAnalysisItemSchema;
    /**
     * 
     * @type {Array<FinItemNomenclatureAdditionalExpenseSchema>}
     * @memberof FinItemAdditionalExpenseSchema
     */
    'additionalExpenses': Array<FinItemNomenclatureAdditionalExpenseSchema>;
}
/**
 * Fin item nomenclature additional expense create schema.
 * @export
 * @interface FinItemNomenclatureAdditionalExpenseChangeSchema
 */
export interface FinItemNomenclatureAdditionalExpenseChangeSchema {
    /**
     * If None - new additional expense will be created.
     * @type {number}
     * @memberof FinItemNomenclatureAdditionalExpenseChangeSchema
     */
    'id'?: number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof FinItemNomenclatureAdditionalExpenseChangeSchema
     */
    'priceWithoutVat': number;
    /**
     * Order nomenclature ID from supplier invoice.
     * @type {number}
     * @memberof FinItemNomenclatureAdditionalExpenseChangeSchema
     */
    'orderNomenclatureId': number;
    /**
     * Field for deleting additional expense.
     * @type {boolean}
     * @memberof FinItemNomenclatureAdditionalExpenseChangeSchema
     */
    'isDeleted': boolean;
    /**
     * Comment field.
     * @type {string}
     * @memberof FinItemNomenclatureAdditionalExpenseChangeSchema
     */
    'comment'?: string;
}
/**
 * Fin item nomenclature additional expense schema.
 * @export
 * @interface FinItemNomenclatureAdditionalExpenseSchema
 */
export interface FinItemNomenclatureAdditionalExpenseSchema {
    /**
     * 
     * @type {number}
     * @memberof FinItemNomenclatureAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof FinItemNomenclatureAdditionalExpenseSchema
     */
    'priceWithoutVat': number;
    /**
     * 
     * @type {BaseOrderNomenclatureSchema}
     * @memberof FinItemNomenclatureAdditionalExpenseSchema
     */
    'orderNomenclature': BaseOrderNomenclatureSchema;
    /**
     * 
     * @type {string}
     * @memberof FinItemNomenclatureAdditionalExpenseSchema
     */
    'comment'?: string;
}
/**
 * Financial analysis item report log schema.
 * @export
 * @interface FinItemReportLogSchema
 */
export interface FinItemReportLogSchema {
    /**
     * 
     * @type {number}
     * @memberof FinItemReportLogSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FinItemReportLogSchema
     */
    'name': string;
    /**
     * 
     * @type {SimpleFinancialAnalysisCategorySchema}
     * @memberof FinItemReportLogSchema
     */
    'category': SimpleFinancialAnalysisCategorySchema;
    /**
     * 
     * @type {AnalyticsItemTypes}
     * @memberof FinItemReportLogSchema
     */
    'type': AnalyticsItemTypes;
    /**
     * 
     * @type {AnalyticsItemActivityKinds}
     * @memberof FinItemReportLogSchema
     */
    'activityKind': AnalyticsItemActivityKinds;
    /**
     * 
     * @type {Array<CurrencyPaymentOperationSchema>}
     * @memberof FinItemReportLogSchema
     */
    'amounts'?: Array<CurrencyPaymentOperationSchema>;
}
/**
 * Financial analysis item report page schema.
 * @export
 * @interface FinItemReportPage
 */
export interface FinItemReportPage {
    /**
     * 
     * @type {Array<FinItemReportLogSchema>}
     * @memberof FinItemReportPage
     */
    'items': Array<FinItemReportLogSchema>;
    /**
     * 
     * @type {number}
     * @memberof FinItemReportPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof FinItemReportPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof FinItemReportPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof FinItemReportPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof FinItemReportPage
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<CurrencyPaymentOperationSchema>}
     * @memberof FinItemReportPage
     */
    'currencies'?: Array<CurrencyPaymentOperationSchema>;
}
/**
 * FinItemReport query order enum.
 * @export
 * @enum {string}
 */

export const FinItemReportQueryOrder = {
    Id: 'id',
    Name: 'name',
    Category: 'category',
    Type: 'type',
    ActivityKind: 'activityKind',
    IncomeAmount: 'incomeAmount',
    ExpenseAmount: 'expenseAmount'
} as const;

export type FinItemReportQueryOrder = typeof FinItemReportQueryOrder[keyof typeof FinItemReportQueryOrder];


/**
 * Create price category schema.
 * @export
 * @interface FinancialAnalysisCategoryCreateSchema
 */
export interface FinancialAnalysisCategoryCreateSchema {
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisCategoryCreateSchema
     */
    'comment': string;
    /**
     * Name
     * @type {string}
     * @memberof FinancialAnalysisCategoryCreateSchema
     */
    'name': string;
    /**
     * Category group
     * @type {CategoryGroups}
     * @memberof FinancialAnalysisCategoryCreateSchema
     */
    'group': CategoryGroups;
    /**
     * Is active
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryCreateSchema
     */
    'isActive'?: boolean;
}
/**
 * FinancialAnalysisCategory schema.
 * @export
 * @interface FinancialAnalysisCategoryDetailSchema
 */
export interface FinancialAnalysisCategoryDetailSchema {
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'comment': string;
    /**
     * Name
     * @type {string}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'name': string;
    /**
     * Category group
     * @type {CategoryGroups}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'group': CategoryGroups;
    /**
     * 
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * FinancialAnalysisCategory schema.
 * @export
 * @interface FinancialAnalysisCategoryListSchema
 */
export interface FinancialAnalysisCategoryListSchema {
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'comment': string;
    /**
     * Name
     * @type {string}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'name': string;
    /**
     * Category group
     * @type {CategoryGroups}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'group': CategoryGroups;
    /**
     * 
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * PriceCategories page schema.
 * @export
 * @interface FinancialAnalysisCategoryPage
 */
export interface FinancialAnalysisCategoryPage {
    /**
     * 
     * @type {Array<FinancialAnalysisCategoryListSchema>}
     * @memberof FinancialAnalysisCategoryPage
     */
    'items': Array<FinancialAnalysisCategoryListSchema>;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisCategoryPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisCategoryPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof FinancialAnalysisCategoryPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof FinancialAnalysisCategoryPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof FinancialAnalysisCategoryPage
     */
    'totalPages': number;
}
/**
 * FinancialAnalysisCategory schema.
 * @export
 * @interface FinancialAnalysisCategoryReadSchema
 */
export interface FinancialAnalysisCategoryReadSchema {
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisCategoryReadSchema
     */
    'comment': string;
    /**
     * Name
     * @type {string}
     * @memberof FinancialAnalysisCategoryReadSchema
     */
    'name': string;
    /**
     * Category group
     * @type {CategoryGroups}
     * @memberof FinancialAnalysisCategoryReadSchema
     */
    'group': CategoryGroups;
    /**
     * 
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryReadSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisCategoryReadSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisCategoryReadSchema
     */
    'dateCreated': string;
}
/**
 * Update price category schema.
 * @export
 * @interface FinancialAnalysisCategoryUpdateSchema
 */
export interface FinancialAnalysisCategoryUpdateSchema {
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisCategoryUpdateSchema
     */
    'comment': string;
    /**
     * Name
     * @type {string}
     * @memberof FinancialAnalysisCategoryUpdateSchema
     */
    'name': string;
    /**
     * Category group
     * @type {CategoryGroups}
     * @memberof FinancialAnalysisCategoryUpdateSchema
     */
    'group': CategoryGroups;
    /**
     * Is active
     * @type {boolean}
     * @memberof FinancialAnalysisCategoryUpdateSchema
     */
    'isActive'?: boolean;
}
/**
 * Create price Item schema.
 * @export
 * @interface FinancialAnalysisItemCreateSchema
 */
export interface FinancialAnalysisItemCreateSchema {
    /**
     * Financial analysis Item name
     * @type {string}
     * @memberof FinancialAnalysisItemCreateSchema
     */
    'name': string;
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisItemCreateSchema
     */
    'comment': string;
    /**
     * Item type
     * @type {AnalyticsItemTypes}
     * @memberof FinancialAnalysisItemCreateSchema
     */
    'type': AnalyticsItemTypes;
    /**
     * Activity kind
     * @type {AnalyticsItemActivityKinds}
     * @memberof FinancialAnalysisItemCreateSchema
     */
    'activityKind': AnalyticsItemActivityKinds;
    /**
     * Is active
     * @type {boolean}
     * @memberof FinancialAnalysisItemCreateSchema
     */
    'isActive': boolean;
    /**
     * Financial analysis Category id
     * @type {number}
     * @memberof FinancialAnalysisItemCreateSchema
     */
    'categoryId': number;
}
/**
 * FinancialAnalysisItem schema.
 * @export
 * @interface FinancialAnalysisItemDetailSchema
 */
export interface FinancialAnalysisItemDetailSchema {
    /**
     * Financial analysis Item name
     * @type {string}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'name': string;
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'comment': string;
    /**
     * Item type
     * @type {AnalyticsItemTypes}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'type': AnalyticsItemTypes;
    /**
     * Activity kind
     * @type {AnalyticsItemActivityKinds}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'activityKind': AnalyticsItemActivityKinds;
    /**
     * Is active
     * @type {boolean}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {FinancialAnalysisCategoryReadSchema}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'category': FinancialAnalysisCategoryReadSchema;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof FinancialAnalysisItemDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * FinancialAnalysisItem schema.
 * @export
 * @interface FinancialAnalysisItemListSchema
 */
export interface FinancialAnalysisItemListSchema {
    /**
     * Financial analysis Item name
     * @type {string}
     * @memberof FinancialAnalysisItemListSchema
     */
    'name': string;
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisItemListSchema
     */
    'comment': string;
    /**
     * Item type
     * @type {AnalyticsItemTypes}
     * @memberof FinancialAnalysisItemListSchema
     */
    'type': AnalyticsItemTypes;
    /**
     * Activity kind
     * @type {AnalyticsItemActivityKinds}
     * @memberof FinancialAnalysisItemListSchema
     */
    'activityKind': AnalyticsItemActivityKinds;
    /**
     * Is active
     * @type {boolean}
     * @memberof FinancialAnalysisItemListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisItemListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisItemListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {FinancialAnalysisCategoryReadSchema}
     * @memberof FinancialAnalysisItemListSchema
     */
    'category': FinancialAnalysisCategoryReadSchema;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof FinancialAnalysisItemListSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof FinancialAnalysisItemListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * PriceItems page schema.
 * @export
 * @interface FinancialAnalysisItemPage
 */
export interface FinancialAnalysisItemPage {
    /**
     * 
     * @type {Array<FinancialAnalysisItemListSchema>}
     * @memberof FinancialAnalysisItemPage
     */
    'items': Array<FinancialAnalysisItemListSchema>;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisItemPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisItemPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof FinancialAnalysisItemPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof FinancialAnalysisItemPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof FinancialAnalysisItemPage
     */
    'totalPages': number;
}
/**
 * Update price Item schema.
 * @export
 * @interface FinancialAnalysisItemUpdateSchema
 */
export interface FinancialAnalysisItemUpdateSchema {
    /**
     * Financial analysis Item name
     * @type {string}
     * @memberof FinancialAnalysisItemUpdateSchema
     */
    'name': string;
    /**
     * Comment
     * @type {string}
     * @memberof FinancialAnalysisItemUpdateSchema
     */
    'comment': string;
    /**
     * Item type
     * @type {AnalyticsItemTypes}
     * @memberof FinancialAnalysisItemUpdateSchema
     */
    'type': AnalyticsItemTypes;
    /**
     * Activity kind
     * @type {AnalyticsItemActivityKinds}
     * @memberof FinancialAnalysisItemUpdateSchema
     */
    'activityKind': AnalyticsItemActivityKinds;
    /**
     * Is active
     * @type {boolean}
     * @memberof FinancialAnalysisItemUpdateSchema
     */
    'isActive': boolean;
    /**
     * Financial analysis Category id
     * @type {number}
     * @memberof FinancialAnalysisItemUpdateSchema
     */
    'categoryId': number;
}
/**
 * Fire check status schema.
 * @export
 * @interface FireCheckStatusSchema
 */
export interface FireCheckStatusSchema {
    /**
     * Has unclosed documents
     * @type {boolean}
     * @memberof FireCheckStatusSchema
     */
    'hasUnclosedDocuments': boolean;
    /**
     * Has active clients
     * @type {boolean}
     * @memberof FireCheckStatusSchema
     */
    'hasActiveClients': boolean;
    /**
     * Can be fired
     * @type {boolean}
     * @memberof FireCheckStatusSchema
     */
    'canBeFired': boolean;
}
/**
 * Fire staff schema.
 * @export
 * @interface FireStaffSchema
 */
export interface FireStaffSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof FireStaffSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof FireStaffSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Generate temporary password schema.
 * @export
 * @interface GenerateTemporaryPasswordSchema
 */
export interface GenerateTemporaryPasswordSchema {
    /**
     * Type of change login password.
     * @type {ChangeCabinetLoginPasswordType}
     * @memberof GenerateTemporaryPasswordSchema
     */
    'changeLoginPasswordType': ChangeCabinetLoginPasswordType;
    /**
     * Send email with temporary password or note.
     * @type {boolean}
     * @memberof GenerateTemporaryPasswordSchema
     */
    'sendEmail'?: boolean;
}
/**
 * History log actions enum.
 * @export
 * @enum {string}
 */

export const HistoryLogActions = {
    Changed: 'changed',
    Deleted: 'deleted',
    Added: 'added'
} as const;

export type HistoryLogActions = typeof HistoryLogActions[keyof typeof HistoryLogActions];


/**
 * Schema for history creators page.
 * @export
 * @interface HistoryLogCreatorsPage
 */
export interface HistoryLogCreatorsPage {
    /**
     * 
     * @type {Array<SimpleUserSchema>}
     * @memberof HistoryLogCreatorsPage
     */
    'items': Array<SimpleUserSchema>;
    /**
     * 
     * @type {number}
     * @memberof HistoryLogCreatorsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof HistoryLogCreatorsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof HistoryLogCreatorsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof HistoryLogCreatorsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof HistoryLogCreatorsPage
     */
    'totalPages': number;
}
/**
 * History log list schema.
 * @export
 * @interface HistoryLogListSchema
 */
export interface HistoryLogListSchema {
    /**
     * 
     * @type {number}
     * @memberof HistoryLogListSchema
     */
    'id': number;
    /**
     * 
     * @type {SrcHistoryEnumsHistoryLogTypes}
     * @memberof HistoryLogListSchema
     */
    'type': SrcHistoryEnumsHistoryLogTypes;
    /**
     * 
     * @type {string}
     * @memberof HistoryLogListSchema
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof HistoryLogListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {HistoryLogActions}
     * @memberof HistoryLogListSchema
     */
    'action': HistoryLogActions;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof HistoryLogListSchema
     */
    'creator'?: SimpleUserSchema;
}
/**
 * Schema for history log page.
 * @export
 * @interface HistoryLogPage
 */
export interface HistoryLogPage {
    /**
     * 
     * @type {Array<HistoryLogListSchema>}
     * @memberof HistoryLogPage
     */
    'items': Array<HistoryLogListSchema>;
    /**
     * 
     * @type {number}
     * @memberof HistoryLogPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof HistoryLogPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof HistoryLogPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof HistoryLogPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof HistoryLogPage
     */
    'totalPages': number;
}
/**
 * Bank account and cashbox params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const HistoryLogQueryOrder = {
    Id: 'id',
    DateCreated: 'dateCreated',
    Text: 'text',
    Action: 'action',
    Creator: 'creator'
} as const;

export type HistoryLogQueryOrder = typeof HistoryLogQueryOrder[keyof typeof HistoryLogQueryOrder];


/**
 * History type choices.
 * @export
 * @enum {string}
 */

export const HistoryTypes = {
    ClientOrder: 'client_order',
    ClientProforma: 'client_proforma',
    ClientInvoice: 'client_invoice',
    ClientReturnProduct: 'client_return_product',
    ClientContract: 'client_contract',
    SupplierOrder: 'supplier_order',
    SupplierProforma: 'supplier_proforma',
    SupplierInvoice: 'supplier_invoice',
    SupplierReturnProduct: 'supplier_return_product',
    SupplierContract: 'supplier_contract',
    Agent: 'agent',
    Client: 'client',
    Supplier: 'supplier',
    Staff: 'staff',
    Nomenclature: 'nomenclature',
    ProductMovement: 'product_movement'
} as const;

export type HistoryTypes = typeof HistoryTypes[keyof typeof HistoryTypes];


/**
 * Incoterm category enum.
 * @export
 * @enum {string}
 */

export const IncotermCategories = {
    C: 'category_c',
    D: 'category_d',
    E: 'category_e',
    F: 'category_f'
} as const;

export type IncotermCategories = typeof IncotermCategories[keyof typeof IncotermCategories];


/**
 * Incoterm category filter enum.
 * @export
 * @enum {string}
 */

export const IncotermCategoryFilter = {
    C: 'category_c',
    D: 'category_d',
    E: 'category_e',
    F: 'category_f'
} as const;

export type IncotermCategoryFilter = typeof IncotermCategoryFilter[keyof typeof IncotermCategoryFilter];


/**
 * Incoterm create schema.
 * @export
 * @interface IncotermCreateSchema
 */
export interface IncotermCreateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof IncotermCreateSchema
     */
    'isActive': boolean;
    /**
     * Category field
     * @type {IncotermCategories}
     * @memberof IncotermCreateSchema
     */
    'category'?: IncotermCategories;
    /**
     * Delivery terms. Must be unique
     * @type {string}
     * @memberof IncotermCreateSchema
     */
    'deliveryTerms': string;
    /**
     * Category explanation
     * @type {string}
     * @memberof IncotermCreateSchema
     */
    'categoryExplanation': string;
    /**
     * Delivery terms explanation
     * @type {IncotermDeliveryTermsExplanations}
     * @memberof IncotermCreateSchema
     */
    'deliveryTermsExplanation'?: IncotermDeliveryTermsExplanations;
    /**
     * Term
     * @type {string}
     * @memberof IncotermCreateSchema
     */
    'term': string;
}
/**
 * Incoterm delivery terms explanations enum.
 * @export
 * @enum {string}
 */

export const IncotermDeliveryTermsExplanations = {
    AnyTransportation: 'any_transportation',
    SeaTransportation: 'sea_transportation'
} as const;

export type IncotermDeliveryTermsExplanations = typeof IncotermDeliveryTermsExplanations[keyof typeof IncotermDeliveryTermsExplanations];


/**
 * Incoterm detail schema.
 * @export
 * @interface IncotermDetailSchema
 */
export interface IncotermDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof IncotermDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IncotermDetailSchema
     */
    'deliveryTerms': string;
    /**
     * 
     * @type {IncotermCategories}
     * @memberof IncotermDetailSchema
     */
    'category': IncotermCategories;
    /**
     * 
     * @type {string}
     * @memberof IncotermDetailSchema
     */
    'categoryExplanation': string;
    /**
     * 
     * @type {IncotermDeliveryTermsExplanations}
     * @memberof IncotermDetailSchema
     */
    'deliveryTermsExplanation': IncotermDeliveryTermsExplanations;
    /**
     * 
     * @type {string}
     * @memberof IncotermDetailSchema
     */
    'term': string;
    /**
     * 
     * @type {boolean}
     * @memberof IncotermDetailSchema
     */
    'isActive': boolean;
}
/**
 * Base incoterm schema for list.
 * @export
 * @interface IncotermListSchema
 */
export interface IncotermListSchema {
    /**
     * 
     * @type {number}
     * @memberof IncotermListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IncotermListSchema
     */
    'deliveryTerms': string;
    /**
     * 
     * @type {IncotermCategories}
     * @memberof IncotermListSchema
     */
    'category': IncotermCategories;
    /**
     * 
     * @type {string}
     * @memberof IncotermListSchema
     */
    'categoryExplanation': string;
    /**
     * 
     * @type {IncotermDeliveryTermsExplanations}
     * @memberof IncotermListSchema
     */
    'deliveryTermsExplanation': IncotermDeliveryTermsExplanations;
    /**
     * 
     * @type {string}
     * @memberof IncotermListSchema
     */
    'term': string;
    /**
     * 
     * @type {boolean}
     * @memberof IncotermListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IncotermListSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IncotermListSchema
     */
    'hasReferences'?: boolean;
}
/**
 * Incoterm params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const IncotermQueryOrder = {
    Id: 'id',
    DeliveryTerms: 'deliveryTerms',
    Category: 'category',
    IsActive: 'isActive'
} as const;

export type IncotermQueryOrder = typeof IncotermQueryOrder[keyof typeof IncotermQueryOrder];


/**
 * Incoterm update schema.
 * @export
 * @interface IncotermUpdateSchema
 */
export interface IncotermUpdateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof IncotermUpdateSchema
     */
    'isActive': boolean;
    /**
     * Category field
     * @type {IncotermCategories}
     * @memberof IncotermUpdateSchema
     */
    'category'?: IncotermCategories;
    /**
     * Delivery terms. Must be unique
     * @type {string}
     * @memberof IncotermUpdateSchema
     */
    'deliveryTerms': string;
    /**
     * Category explanation
     * @type {string}
     * @memberof IncotermUpdateSchema
     */
    'categoryExplanation': string;
    /**
     * Delivery terms explanation
     * @type {IncotermDeliveryTermsExplanations}
     * @memberof IncotermUpdateSchema
     */
    'deliveryTermsExplanation'?: IncotermDeliveryTermsExplanations;
    /**
     * Term
     * @type {string}
     * @memberof IncotermUpdateSchema
     */
    'term': string;
}
/**
 * Schema for incoterms page.
 * @export
 * @interface IncotermsPage
 */
export interface IncotermsPage {
    /**
     * 
     * @type {Array<IncotermListSchema>}
     * @memberof IncotermsPage
     */
    'items': Array<IncotermListSchema>;
    /**
     * 
     * @type {number}
     * @memberof IncotermsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof IncotermsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof IncotermsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof IncotermsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof IncotermsPage
     */
    'totalPages': number;
}
/**
 * Invoice delivery status choices.
 * @export
 * @enum {string}
 */

export const InvoiceDeliveryStatuses = {
    OnWay: 'on_way',
    Delivered: 'delivered',
    Shipped: 'shipped',
    Cancelled: 'cancelled'
} as const;

export type InvoiceDeliveryStatuses = typeof InvoiceDeliveryStatuses[keyof typeof InvoiceDeliveryStatuses];


/**
 * Client invoice nomenclature detail schema.
 * @export
 * @interface InvoiceNomenclatureForProductReturnsSchema
 */
export interface InvoiceNomenclatureForProductReturnsSchema {
    /**
     * 
     * @type {number}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'currentPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'productReturnNomenclaturesQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'availableQuantityForReturn'?: number;
    /**
     * 
     * @type {BaseOrderNomenclatureForDocumentSchema}
     * @memberof InvoiceNomenclatureForProductReturnsSchema
     */
    'orderNomenclature': BaseOrderNomenclatureForDocumentSchema;
}
/**
 * Invoice schema for additional expense.
 * @export
 * @interface InvoiceSchemaForAdditionalExpense
 */
export interface InvoiceSchemaForAdditionalExpense {
    /**
     * Document number.
     * @type {string}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'dateCreated': string;
    /**
     * 
     * @type {ComplexBaseOrderSchema}
     * @memberof InvoiceSchemaForAdditionalExpense
     */
    'order': ComplexBaseOrderSchema;
}
/**
 * Invoice schema for compensation product return.
 * @export
 * @interface InvoiceSchemaForCompensationProductReturn
 */
export interface InvoiceSchemaForCompensationProductReturn {
    /**
     * Document number.
     * @type {string}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'dateCreated': string;
    /**
     * 
     * @type {BaseOrderForFinancesSchema}
     * @memberof InvoiceSchemaForCompensationProductReturn
     */
    'order': BaseOrderForFinancesSchema;
}
/**
 * Invoice status choices.
 * @export
 * @enum {string}
 */

export const InvoiceStatuses = {
    Created: 'created',
    Conducted: 'conducted',
    Deleted: 'deleted'
} as const;

export type InvoiceStatuses = typeof InvoiceStatuses[keyof typeof InvoiceStatuses];


/**
 * OrderStatus model.
 * @export
 * @enum {string}
 */

export const InvoiceUpdateStatuses = {
    Created: 'created',
    Conducted: 'conducted'
} as const;

export type InvoiceUpdateStatuses = typeof InvoiceUpdateStatuses[keyof typeof InvoiceUpdateStatuses];


/**
 * Label level.
 * @export
 * @enum {string}
 */

export const LabelLevel = {
    Primary: 'primary',
    Success: 'success',
    Info: 'info',
    Warning: 'warning',
    Danger: 'danger'
} as const;

export type LabelLevel = typeof LabelLevel[keyof typeof LabelLevel];


/**
 * Label list schema.
 * @export
 * @interface LabelListSchema
 */
export interface LabelListSchema {
    /**
     * 
     * @type {string}
     * @memberof LabelListSchema
     */
    'text': string;
    /**
     * 
     * @type {LabelLevel}
     * @memberof LabelListSchema
     */
    'level': LabelLevel;
}
/**
 * Label schema.
 * @export
 * @interface LabelSchema
 */
export interface LabelSchema {
    /**
     * 
     * @type {boolean}
     * @memberof LabelSchema
     */
    'hasReserve': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LabelSchema
     */
    'hasOrderRelationship': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LabelSchema
     */
    'hasProductPartialReturn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LabelSchema
     */
    'hasProductFullReturn': boolean;
}
/**
 * Latest message schema.
 * @export
 * @interface LatestMessageSchema
 */
export interface LatestMessageSchema {
    /**
     * 
     * @type {string}
     * @memberof LatestMessageSchema
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {Array<SimpleMessageMediaSchema>}
     * @memberof LatestMessageSchema
     */
    'media'?: Array<SimpleMessageMediaSchema>;
}
/**
 * Limited list of accepted languages.
 * @export
 * @enum {string}
 */

export const LimitedAcceptLanguage = {
    En: 'en',
    Sl: 'sl'
} as const;

export type LimitedAcceptLanguage = typeof LimitedAcceptLanguage[keyof typeof LimitedAcceptLanguage];


/**
 * Warehouse nomenclature query order enum.
 * @export
 * @enum {string}
 */

export const LimitedWarehouseNomenclatureQueryOrder = {
    Id: 'id',
    Name: 'name',
    Brand: 'brand',
    IncomeQuantity: 'income_quantity',
    ExpenseQuantity: 'expense_quantity',
    StockStart: 'stock_start',
    StockEnd: 'stock_end',
    SumCostPriceStart: 'sum_cost_price_start',
    SumCostPriceEnd: 'sum_cost_price_end',
    IncomeSumCostPrice: 'income_sum_cost_price',
    ExpenseSumCostPrice: 'expense_sum_cost_price'
} as const;

export type LimitedWarehouseNomenclatureQueryOrder = typeof LimitedWarehouseNomenclatureQueryOrder[keyof typeof LimitedWarehouseNomenclatureQueryOrder];


/**
 * Main user location
 * @export
 * @interface Mainlocation
 */
export interface Mainlocation {
    /**
     * User region
     * @type {string}
     * @memberof Mainlocation
     */
    'region'?: string;
    /**
     * User city
     * @type {string}
     * @memberof Mainlocation
     */
    'city'?: string;
    /**
     * User address
     * @type {string}
     * @memberof Mainlocation
     */
    'address'?: string;
}
/**
 * Schema for nomenclature categories page for markup manager.
 * @export
 * @interface MarkupManagerNomenclatureCategoriesPage
 */
export interface MarkupManagerNomenclatureCategoriesPage {
    /**
     * 
     * @type {Array<NomenclatureCategoriesSchema>}
     * @memberof MarkupManagerNomenclatureCategoriesPage
     */
    'items': Array<NomenclatureCategoriesSchema>;
    /**
     * 
     * @type {number}
     * @memberof MarkupManagerNomenclatureCategoriesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof MarkupManagerNomenclatureCategoriesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof MarkupManagerNomenclatureCategoriesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof MarkupManagerNomenclatureCategoriesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof MarkupManagerNomenclatureCategoriesPage
     */
    'totalPages': number;
}
/**
 * Markup update by brand schema.
 * @export
 * @interface MarkupUpdateByBrandSchema
 */
export interface MarkupUpdateByBrandSchema {
    /**
     * 
     * @type {number}
     * @memberof MarkupUpdateByBrandSchema
     */
    'id': number;
}
/**
 * Markup update by category schema.
 * @export
 * @interface MarkupUpdateByCategorySchema
 */
export interface MarkupUpdateByCategorySchema {
    /**
     * 
     * @type {number}
     * @memberof MarkupUpdateByCategorySchema
     */
    'id': number;
    /**
     * 
     * @type {Array<MarkupUpdateBySubcategorySchema>}
     * @memberof MarkupUpdateByCategorySchema
     */
    'subcategories': Array<MarkupUpdateBySubcategorySchema>;
}
/**
 * Markup update by subcategory schema.
 * @export
 * @interface MarkupUpdateBySubcategorySchema
 */
export interface MarkupUpdateBySubcategorySchema {
    /**
     * 
     * @type {number}
     * @memberof MarkupUpdateBySubcategorySchema
     */
    'id': number;
}
/**
 * Markup update nomenclature price schema.
 * @export
 * @interface MarkupUpdateNomenclaturePriceSchema
 */
export interface MarkupUpdateNomenclaturePriceSchema {
    /**
     * 
     * @type {number}
     * @memberof MarkupUpdateNomenclaturePriceSchema
     */
    'id': number;
    /**
     * Value field. Will be filled for price nomenclature markup
     * @type {number}
     * @memberof MarkupUpdateNomenclaturePriceSchema
     */
    'value'?: number;
}
/**
 * Message detail schema.
 * @export
 * @interface MessageDetailSchema
 */
export interface MessageDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof MessageDetailSchema
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {number}
     * @memberof MessageDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {CreatorUserSchema}
     * @memberof MessageDetailSchema
     */
    'creator': CreatorUserSchema;
    /**
     * 
     * @type {Array<MessageMediaDetailSchema>}
     * @memberof MessageDetailSchema
     */
    'media'?: Array<MessageMediaDetailSchema>;
}
/**
 * Message media detail schema.
 * @export
 * @interface MessageMediaDetailSchema
 */
export interface MessageMediaDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof MessageMediaDetailSchema
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof MessageMediaDetailSchema
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof MessageMediaDetailSchema
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MessageMediaDetailSchema
     */
    'format': string;
}
/**
 * Message update schema.
 * @export
 * @interface MessageUpdateSchema
 */
export interface MessageUpdateSchema {
    /**
     * Message text.
     * @type {string}
     * @memberof MessageUpdateSchema
     */
    'text'?: string;
}
/**
 * Mutual settlement document types choices.
 * @export
 * @enum {string}
 */

export const MutualSettlementDocumentTypes = {
    PaymentOrder: 'payment_order',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return',
    Compensation: 'compensation'
} as const;

export type MutualSettlementDocumentTypes = typeof MutualSettlementDocumentTypes[keyof typeof MutualSettlementDocumentTypes];


/**
 * MutualSettlement schema.
 * @export
 * @interface MutualSettlementListSchema
 */
export interface MutualSettlementListSchema {
    /**
     * 
     * @type {number}
     * @memberof MutualSettlementListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MutualSettlementListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleClientInvoiceSchema}
     * @memberof MutualSettlementListSchema
     */
    'clientInvoice'?: SimpleClientInvoiceSchema;
    /**
     * 
     * @type {SimpleSupplierInvoiceSchema}
     * @memberof MutualSettlementListSchema
     */
    'supplierInvoice'?: SimpleSupplierInvoiceSchema;
    /**
     * 
     * @type {SimpleProductReturnSchema}
     * @memberof MutualSettlementListSchema
     */
    'clientProductReturn'?: SimpleProductReturnSchema;
    /**
     * 
     * @type {SimpleProductReturnSchema}
     * @memberof MutualSettlementListSchema
     */
    'supplierProductReturn'?: SimpleProductReturnSchema;
    /**
     * 
     * @type {SimplePaymentOrderSchema}
     * @memberof MutualSettlementListSchema
     */
    'paymentOrder'?: SimplePaymentOrderSchema;
    /**
     * 
     * @type {SimpleCompensationSchema}
     * @memberof MutualSettlementListSchema
     */
    'compensation'?: SimpleCompensationSchema;
    /**
     * 
     * @type {MutualSettlementDocumentTypes}
     * @memberof MutualSettlementListSchema
     */
    'documentType'?: MutualSettlementDocumentTypes;
    /**
     * 
     * @type {SimpleCurrencySchema}
     * @memberof MutualSettlementListSchema
     */
    'currency': SimpleCurrencySchema;
    /**
     * 
     * @type {number}
     * @memberof MutualSettlementListSchema
     */
    'amount': number;
    /**
     * 
     * @type {boolean}
     * @memberof MutualSettlementListSchema
     */
    'isIncome': boolean;
    /**
     * 
     * @type {number}
     * @memberof MutualSettlementListSchema
     */
    'clientBalance': number;
    /**
     * 
     * @type {number}
     * @memberof MutualSettlementListSchema
     */
    'supplierBalance': number;
    /**
     * 
     * @type {CabinetUserKinds}
     * @memberof MutualSettlementListSchema
     */
    'userKind': CabinetUserKinds;
}
/**
 * MutualSettlement page schema.
 * @export
 * @interface MutualSettlementPage
 */
export interface MutualSettlementPage {
    /**
     * 
     * @type {Array<MutualSettlementListSchema>}
     * @memberof MutualSettlementPage
     */
    'items': Array<MutualSettlementListSchema>;
    /**
     * 
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'totalPages': number;
    /**
     * Client opening balance for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'clientOpeningBalance'?: number;
    /**
     * Client closing balance for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'clientClosingBalance'?: number;
    /**
     * Client write off turnover for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'clientWriteOffTurnover'?: number;
    /**
     * Client replenishment turnover for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'clientReplenishmentTurnover'?: number;
    /**
     * Supplier opening balance for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'supplierOpeningBalance'?: number;
    /**
     * Supplier closing balance for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'supplierClosingBalance'?: number;
    /**
     * Supplier write off turnover for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'supplierWriteOffTurnover'?: number;
    /**
     * Supplier replenishment turnover for the selected period.
     * @type {number}
     * @memberof MutualSettlementPage
     */
    'supplierReplenishmentTurnover'?: number;
}
/**
 * Mutual settlement user kinds choices.
 * @export
 * @enum {string}
 */

export const MutualSettlementUserKinds = {
    Client: 'client',
    Supplier: 'supplier',
    Contragent: 'contragent'
} as const;

export type MutualSettlementUserKinds = typeof MutualSettlementUserKinds[keyof typeof MutualSettlementUserKinds];


/**
 * Add nomenclature schema.  Can be used for adding analogs or related parts to the nomenclature.
 * @export
 * @interface NomenclatureAddSchema
 */
export interface NomenclatureAddSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureAddSchema
     */
    'id': number;
}
/**
 * Nomenclature additional info schema.
 * @export
 * @interface NomenclatureAdditionalInfoSchema
 */
export interface NomenclatureAdditionalInfoSchema {
    /**
     * 
     * @type {Array<NomenclatureImageDetailSchema>}
     * @memberof NomenclatureAdditionalInfoSchema
     */
    'images'?: Array<NomenclatureImageDetailSchema>;
    /**
     * 
     * @type {Array<NomenclatureVideoLinkDetailSchema>}
     * @memberof NomenclatureAdditionalInfoSchema
     */
    'videoLinks'?: Array<NomenclatureVideoLinkDetailSchema>;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureAdditionalInfoSchema
     */
    'description'?: string;
}
/**
 * Nomenclature analog schema for analog list endpoint.
 * @export
 * @interface NomenclatureAnalogListSchema
 */
export interface NomenclatureAnalogListSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureAnalogListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureAnalogListSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureAnalogListSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {Array<VendorCodeListSchema>}
     * @memberof NomenclatureAnalogListSchema
     */
    'vendorCodes'?: Array<VendorCodeListSchema>;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof NomenclatureAnalogListSchema
     */
    'unit': CommonNomenclatureUnits;
    /**
     * 
     * @type {BaseBrandSchema}
     * @memberof NomenclatureAnalogListSchema
     */
    'brand'?: BaseBrandSchema;
    /**
     * 
     * @type {SelectCountryListSchema}
     * @memberof NomenclatureAnalogListSchema
     */
    'country'?: SelectCountryListSchema;
    /**
     * 
     * @type {SelectNomenclatureCategorySchema}
     * @memberof NomenclatureAnalogListSchema
     */
    'category'?: SelectNomenclatureCategorySchema;
    /**
     * 
     * @type {NomenclatureSubcategorySelectSchema}
     * @memberof NomenclatureAnalogListSchema
     */
    'subcategory'?: NomenclatureSubcategorySelectSchema;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureAnalogListSchema
     */
    'customsCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureAnalogListSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureAnalogListSchema
     */
    'costPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureAnalogListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureAnalogListSchema
     */
    'isShow': boolean;
}
/**
 * Add an analog to the nomenclature schema.
 * @export
 * @interface NomenclatureAnalogsAddSchema
 */
export interface NomenclatureAnalogsAddSchema {
    /**
     * 
     * @type {Array<NomenclatureAddSchema>}
     * @memberof NomenclatureAnalogsAddSchema
     */
    'analogs': Array<NomenclatureAddSchema>;
}
/**
 * Schema for nomenclature analogs page.
 * @export
 * @interface NomenclatureAnalogsPage
 */
export interface NomenclatureAnalogsPage {
    /**
     * 
     * @type {Array<NomenclatureAnalogListSchema>}
     * @memberof NomenclatureAnalogsPage
     */
    'items': Array<NomenclatureAnalogListSchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureAnalogsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureAnalogsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NomenclatureAnalogsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NomenclatureAnalogsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NomenclatureAnalogsPage
     */
    'totalPages': number;
}
/**
 * Schema for nomenclature categories page.
 * @export
 * @interface NomenclatureCategoriesPage
 */
export interface NomenclatureCategoriesPage {
    /**
     * 
     * @type {Array<BaseNomenclatureCategorySchema>}
     * @memberof NomenclatureCategoriesPage
     */
    'items': Array<BaseNomenclatureCategorySchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureCategoriesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureCategoriesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NomenclatureCategoriesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NomenclatureCategoriesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NomenclatureCategoriesPage
     */
    'totalPages': number;
}
/**
 * Nomenclature category for markup manager schema.
 * @export
 * @interface NomenclatureCategoriesSchema
 */
export interface NomenclatureCategoriesSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureCategoriesSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureCategoriesSchema
     */
    'name': string;
    /**
     * 
     * @type {Array<NomenclatureSubcategorySelectSchema>}
     * @memberof NomenclatureCategoriesSchema
     */
    'subcategories': Array<NomenclatureSubcategorySelectSchema>;
}
/**
 * Nomenclature category create schema.
 * @export
 * @interface NomenclatureCategoryCreateSchema
 */
export interface NomenclatureCategoryCreateSchema {
    /**
     * Name of the category. Must be unique within the nomenclature categories.
     * @type {string}
     * @memberof NomenclatureCategoryCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCategoryCreateSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {Array<NomenclatureSubcategoryCreateSchema>}
     * @memberof NomenclatureCategoryCreateSchema
     */
    'subcategories': Array<NomenclatureSubcategoryCreateSchema>;
}
/**
 * Nomenclature category detail schema.
 * @export
 * @interface NomenclatureCategoryDetailSchema
 */
export interface NomenclatureCategoryDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {Array<NomenclatureSubcategoryDetailSchema>}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'subcategories': Array<NomenclatureSubcategoryDetailSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCategoryDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Nomenclature category params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const NomenclatureCategoryQueryOrder = {
    Id: 'id',
    DateCreated: 'dateCreated',
    Name: 'name',
    IsActive: 'isActive'
} as const;

export type NomenclatureCategoryQueryOrder = typeof NomenclatureCategoryQueryOrder[keyof typeof NomenclatureCategoryQueryOrder];


/**
 * Nomenclature category schema.
 * @export
 * @interface NomenclatureCategorySchema
 */
export interface NomenclatureCategorySchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureCategorySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureCategorySchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCategorySchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureCategorySchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {Array<BaseNomenclatureSubcategorySchema>}
     * @memberof NomenclatureCategorySchema
     */
    'subcategories': Array<BaseNomenclatureSubcategorySchema>;
}
/**
 * Nomenclature category update schema.
 * @export
 * @interface NomenclatureCategoryUpdateSchema
 */
export interface NomenclatureCategoryUpdateSchema {
    /**
     * Name of the category. Must be unique within the nomenclature categories.
     * @type {string}
     * @memberof NomenclatureCategoryUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCategoryUpdateSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {Array<NomenclatureSubcategoryUpdateSchema>}
     * @memberof NomenclatureCategoryUpdateSchema
     */
    'subcategories': Array<NomenclatureSubcategoryUpdateSchema>;
}
/**
 * Nomenclature create schema.
 * @export
 * @interface NomenclatureCreateSchema
 */
export interface NomenclatureCreateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCreateSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCreateSchema
     */
    'isShow': boolean;
    /**
     * Nomenclature category ID.
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'categoryId': number;
    /**
     * Nomenclature subcategory ID.
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'subcategoryId': number;
    /**
     * Brand ID.
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'brandId'?: number;
    /**
     * Country ID.
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'countryId'?: number;
    /**
     * 
     * @type {Array<VendorCodeCreateSchema>}
     * @memberof NomenclatureCreateSchema
     */
    'vendorCodes': Array<VendorCodeCreateSchema>;
    /**
     * Customs code. 8 or 10 digit number
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'customsCode'?: number;
    /**
     * Name in English.
     * @type {string}
     * @memberof NomenclatureCreateSchema
     */
    'nameEn': string;
    /**
     * Name in Russian.
     * @type {string}
     * @memberof NomenclatureCreateSchema
     */
    'nameRu': string;
    /**
     * Name in Slovenian.
     * @type {string}
     * @memberof NomenclatureCreateSchema
     */
    'nameSl': string;
    /**
     * Unit field. Default - piece. For the product can be selected: piece, package, kilogram, liter. For the service can be selected: piece, day, hour. 
     * @type {string}
     * @memberof NomenclatureCreateSchema
     */
    'unit'?: string;
    /**
     * Weight
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'weight'?: number;
    /**
     * Width
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'width'?: number;
    /**
     * Height
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'height'?: number;
    /**
     * Length
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'length'?: number;
    /**
     * Minimum number of nomenclatures to order
     * @type {number}
     * @memberof NomenclatureCreateSchema
     */
    'minOrderQuantity': number;
    /**
     * Comment
     * @type {string}
     * @memberof NomenclatureCreateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureCreateSchema
     */
    'isProduct': boolean;
}
/**
 * Nomenclature detail schema.
 * @export
 * @interface NomenclatureDetailSchema
 */
export interface NomenclatureDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureDetailSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {Array<VendorCodeDetailSchema>}
     * @memberof NomenclatureDetailSchema
     */
    'vendorCodes': Array<VendorCodeDetailSchema>;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof NomenclatureDetailSchema
     */
    'unit': CommonNomenclatureUnits;
    /**
     * 
     * @type {BaseBrandSchema}
     * @memberof NomenclatureDetailSchema
     */
    'brand'?: BaseBrandSchema;
    /**
     * 
     * @type {SelectCountryListSchema}
     * @memberof NomenclatureDetailSchema
     */
    'country'?: SelectCountryListSchema;
    /**
     * 
     * @type {SelectNomenclatureCategorySchema}
     * @memberof NomenclatureDetailSchema
     */
    'category'?: SelectNomenclatureCategorySchema;
    /**
     * 
     * @type {NomenclatureSubcategorySelectSchema}
     * @memberof NomenclatureDetailSchema
     */
    'subcategory'?: NomenclatureSubcategorySelectSchema;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'customsCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureDetailSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'costPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureDetailSchema
     */
    'isShow': boolean;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureDetailSchema
     */
    'nameEn'?: string;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureDetailSchema
     */
    'nameRu'?: string;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureDetailSchema
     */
    'nameSl'?: string;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureDetailSchema
     */
    'minOrderQuantity'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureDetailSchema
     */
    'canDelete'?: boolean;
}
/**
 * NomenclatureImage schema.
 * @export
 * @interface NomenclatureImageDetailSchema
 */
export interface NomenclatureImageDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureImageDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureImageDetailSchema
     */
    'image': string;
}
/**
 * Nomenclature schema for List endpoint.
 * @export
 * @interface NomenclatureListSchema
 */
export interface NomenclatureListSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureListSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureListSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {Array<VendorCodeListSchema>}
     * @memberof NomenclatureListSchema
     */
    'vendorCodes'?: Array<VendorCodeListSchema>;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof NomenclatureListSchema
     */
    'unit': CommonNomenclatureUnits;
    /**
     * 
     * @type {BaseBrandSchema}
     * @memberof NomenclatureListSchema
     */
    'brand'?: BaseBrandSchema;
    /**
     * 
     * @type {SelectCountryListSchema}
     * @memberof NomenclatureListSchema
     */
    'country'?: SelectCountryListSchema;
    /**
     * 
     * @type {SelectNomenclatureCategorySchema}
     * @memberof NomenclatureListSchema
     */
    'category'?: SelectNomenclatureCategorySchema;
    /**
     * 
     * @type {NomenclatureSubcategorySelectSchema}
     * @memberof NomenclatureListSchema
     */
    'subcategory'?: NomenclatureSubcategorySelectSchema;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'customsCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureListSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'costPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureListSchema
     */
    'isShow': boolean;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'minOrderQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'expectedQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'totalQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'totalReserveQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureListSchema
     */
    'fullTotalQuantityString'?: string;
    /**
     * 
     * @type {Array<WarehouseNomenclatureForDynamicColumnsSchema>}
     * @memberof NomenclatureListSchema
     */
    'activeWarehouses'?: Array<WarehouseNomenclatureForDynamicColumnsSchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'analogsQuantity'?: number;
    /**
     * 
     * @type {Array<SimpleNomenclatureSchema>}
     * @memberof NomenclatureListSchema
     */
    'analogs': Array<SimpleNomenclatureSchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'relatedNomenclaturesQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'length'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureListSchema
     */
    'hasSupplierPrices': boolean;
    /**
     * 
     * @type {Array<NomenclaturePriceCategorySchema>}
     * @memberof NomenclatureListSchema
     */
    'prices'?: Array<NomenclaturePriceCategorySchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureListSchema
     */
    'fixPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureListSchema
     */
    'isCompleted'?: boolean;
}
/**
 * Nomenclature movement schema.
 * @export
 * @interface NomenclatureMovementSchema
 */
export interface NomenclatureMovementSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureMovementSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureMovementSchema
     */
    'name': string;
    /**
     * 
     * @type {Array<VendorCodeListSchema>}
     * @memberof NomenclatureMovementSchema
     */
    'vendorCodes'?: Array<VendorCodeListSchema>;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof NomenclatureMovementSchema
     */
    'unit': CommonNomenclatureUnits;
}
/**
 * Nomenclature price category detail schema.
 * @export
 * @interface NomenclaturePriceCategoryDetailSchema
 */
export interface NomenclaturePriceCategoryDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'isMarkup': boolean;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'value'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'priceWithMarkup'?: number;
    /**
     * 
     * @type {PriceCategoryForNomenclaturePriceListSchema}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'priceCategory': PriceCategoryForNomenclaturePriceListSchema;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategoryDetailSchema
     */
    'isCompleted'?: boolean;
}
/**
 * Nomenclature price category schema.
 * @export
 * @interface NomenclaturePriceCategorySchema
 */
export interface NomenclaturePriceCategorySchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceCategorySchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategorySchema
     */
    'isMarkup': boolean;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceCategorySchema
     */
    'value'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategorySchema
     */
    'isActive': boolean;
}
/**
 * Nomenclature price category update schema.
 * @export
 * @interface NomenclaturePriceCategoryUpdateSchema
 */
export interface NomenclaturePriceCategoryUpdateSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceCategoryUpdateSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategoryUpdateSchema
     */
    'isMarkup': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceCategoryUpdateSchema
     */
    'isActive': boolean;
    /**
     * Value field. Will be filled for markup or fixed price
     * @type {number}
     * @memberof NomenclaturePriceCategoryUpdateSchema
     */
    'value'?: number;
}
/**
 * Price list schema for nomenclature.
 * @export
 * @interface NomenclaturePriceListSchema
 */
export interface NomenclaturePriceListSchema {
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceListSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceListSchema
     */
    'averageMarketPrice': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceListSchema
     */
    'costPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceListSchema
     */
    'fixPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturePriceListSchema
     */
    'isCompleted'?: boolean;
    /**
     * 
     * @type {Array<NomenclaturePriceCategoryDetailSchema>}
     * @memberof NomenclaturePriceListSchema
     */
    'prices'?: Array<NomenclaturePriceCategoryDetailSchema>;
}
/**
 * PriceNomenclature page schema.
 * @export
 * @interface NomenclaturePricePage
 */
export interface NomenclaturePricePage {
    /**
     * 
     * @type {Array<NomenclaturePriceReadSchema>}
     * @memberof NomenclaturePricePage
     */
    'items': Array<NomenclaturePriceReadSchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePricePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePricePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NomenclaturePricePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NomenclaturePricePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NomenclaturePricePage
     */
    'totalPages': number;
}
/**
 * PriceNomenclature schema.
 * @export
 * @interface NomenclaturePriceReadSchema
 */
export interface NomenclaturePriceReadSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceReadSchema
     */
    'id': number;
    /**
     * 
     * @type {BaseVendorCodeSchema}
     * @memberof NomenclaturePriceReadSchema
     */
    'nomenclatureVendorCode': BaseVendorCodeSchema;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof NomenclaturePriceReadSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {BaseCurrencySchema}
     * @memberof NomenclaturePriceReadSchema
     */
    'currency': BaseCurrencySchema;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceReadSchema
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceReadSchema
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceReadSchema
     */
    'eurCost': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturePriceReadSchema
     */
    'stock'?: number;
    /**
     * 
     * @type {PriceListSchemaWithSupplier}
     * @memberof NomenclaturePriceReadSchema
     */
    'priceList': PriceListSchemaWithSupplier;
    /**
     * 
     * @type {string}
     * @memberof NomenclaturePriceReadSchema
     */
    'dateUpdated': string;
    /**
     * 
     * @type {string}
     * @memberof NomenclaturePriceReadSchema
     */
    'dateCreated': string;
}
/**
 * Nomenclature prices schema.
 * @export
 * @interface NomenclaturePricesSchema
 */
export interface NomenclaturePricesSchema {
    /**
     * 
     * @type {Array<SimpleNomenclaturePriceSchema>}
     * @memberof NomenclaturePricesSchema
     */
    'nomenclaturePrices': Array<SimpleNomenclaturePriceSchema>;
}
/**
 * Nomenclature profit report query order enum.
 * @export
 * @enum {string}
 */

export const NomenclatureProfitReportQueryOrder = {
    Id: 'id',
    VendorCode: 'vendor_code',
    Name: 'name',
    Brand: 'brand',
    Quantity: 'quantity',
    Turnover: 'turnover',
    Cost: 'cost',
    Profit: 'profit',
    Percentage: 'percentage'
} as const;

export type NomenclatureProfitReportQueryOrder = typeof NomenclatureProfitReportQueryOrder[keyof typeof NomenclatureProfitReportQueryOrder];


/**
 * Profit nomenclature report schema.
 * @export
 * @interface NomenclatureProfitReportSchema
 */
export interface NomenclatureProfitReportSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureProfitReportSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureProfitReportSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureProfitReportSchema
     */
    'turnover': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureProfitReportSchema
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureProfitReportSchema
     */
    'profit': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureProfitReportSchema
     */
    'percentage': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureProfitReportSchema
     */
    'vendorCode'?: string;
    /**
     * 
     * @type {BaseBrandSchema}
     * @memberof NomenclatureProfitReportSchema
     */
    'brand'?: BaseBrandSchema;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureProfitReportSchema
     */
    'quantity': number;
}
/**
 * Nomenclature related nomenclature schema for analog list endpoint.
 * @export
 * @interface NomenclatureRelatedNomenclatureListSchema
 */
export interface NomenclatureRelatedNomenclatureListSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {Array<VendorCodeListSchema>}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'vendorCodes'?: Array<VendorCodeListSchema>;
    /**
     * 
     * @type {CommonNomenclatureUnits}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'unit': CommonNomenclatureUnits;
    /**
     * 
     * @type {BaseBrandSchema}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'brand'?: BaseBrandSchema;
    /**
     * 
     * @type {SelectCountryListSchema}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'country'?: SelectCountryListSchema;
    /**
     * 
     * @type {SelectNomenclatureCategorySchema}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'category'?: SelectNomenclatureCategorySchema;
    /**
     * 
     * @type {NomenclatureSubcategorySelectSchema}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'subcategory'?: NomenclatureSubcategorySelectSchema;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'customsCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'costPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureRelatedNomenclatureListSchema
     */
    'isShow': boolean;
}
/**
 * Add a related nomenclature to the nomenclature schema.
 * @export
 * @interface NomenclatureRelatedNomenclaturesAddSchema
 */
export interface NomenclatureRelatedNomenclaturesAddSchema {
    /**
     * 
     * @type {Array<NomenclatureAddSchema>}
     * @memberof NomenclatureRelatedNomenclaturesAddSchema
     */
    'relatedNomenclatures': Array<NomenclatureAddSchema>;
}
/**
 * Schema for nomenclature related nomenclatures page.
 * @export
 * @interface NomenclatureRelatedNomenclaturesPage
 */
export interface NomenclatureRelatedNomenclaturesPage {
    /**
     * 
     * @type {Array<NomenclatureRelatedNomenclatureListSchema>}
     * @memberof NomenclatureRelatedNomenclaturesPage
     */
    'items': Array<NomenclatureRelatedNomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureRelatedNomenclaturesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureRelatedNomenclaturesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NomenclatureRelatedNomenclaturesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NomenclatureRelatedNomenclaturesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NomenclatureRelatedNomenclaturesPage
     */
    'totalPages': number;
}
/**
 * Nomenclature subcategory create schema.
 * @export
 * @interface NomenclatureSubcategoryCreateSchema
 */
export interface NomenclatureSubcategoryCreateSchema {
    /**
     * Name of the subcategory. Must be unique within the nomenclature subcategories.
     * @type {string}
     * @memberof NomenclatureSubcategoryCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryCreateSchema
     */
    'isActive': boolean;
}
/**
 * Nomenclature detail subcategory schema.
 * @export
 * @interface NomenclatureSubcategoryDetailSchema
 */
export interface NomenclatureSubcategoryDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Nomenclature subcategory for select and tables schema.
 * @export
 * @interface NomenclatureSubcategorySelectSchema
 */
export interface NomenclatureSubcategorySelectSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureSubcategorySelectSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureSubcategorySelectSchema
     */
    'name': string;
}
/**
 * Nomenclature subcategory update schema.
 * @export
 * @interface NomenclatureSubcategoryUpdateSchema
 */
export interface NomenclatureSubcategoryUpdateSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureSubcategoryUpdateSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryUpdateSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryUpdateSchema
     */
    'isBase'?: boolean;
    /**
     * Name of the subcategory. Must be unique within the nomenclature subcategories.
     * @type {string}
     * @memberof NomenclatureSubcategoryUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureSubcategoryUpdateSchema
     */
    'isActive': boolean;
}
/**
 * Nomenclature total balance schema.
 * @export
 * @interface NomenclatureTotalBalanceSchema
 */
export interface NomenclatureTotalBalanceSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureTotalBalanceSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureTotalBalanceSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureTotalBalanceSchema
     */
    'isProduct': boolean;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureTotalBalanceSchema
     */
    'totalQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureTotalBalanceSchema
     */
    'totalReserveQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclatureTotalBalanceSchema
     */
    'expectedQuantity': number;
}
/**
 * Nomenclature update schema.
 * @export
 * @interface NomenclatureUpdateSchema
 */
export interface NomenclatureUpdateSchema {
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureUpdateSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclatureUpdateSchema
     */
    'isShow': boolean;
    /**
     * Nomenclature category ID.
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'categoryId': number;
    /**
     * Nomenclature subcategory ID.
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'subcategoryId': number;
    /**
     * Brand ID.
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'brandId'?: number;
    /**
     * Country ID.
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'countryId'?: number;
    /**
     * 
     * @type {Array<VendorCodeUpdateSchema>}
     * @memberof NomenclatureUpdateSchema
     */
    'vendorCodes': Array<VendorCodeUpdateSchema>;
    /**
     * Customs code. 8 or 10 digit number
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'customsCode'?: number;
    /**
     * Name in English.
     * @type {string}
     * @memberof NomenclatureUpdateSchema
     */
    'nameEn': string;
    /**
     * Name in Russian.
     * @type {string}
     * @memberof NomenclatureUpdateSchema
     */
    'nameRu': string;
    /**
     * Name in Slovenian.
     * @type {string}
     * @memberof NomenclatureUpdateSchema
     */
    'nameSl': string;
    /**
     * Unit field. Default - piece. For the product can be selected: piece, package, kilogram, liter. For the service can be selected: piece, day, hour. 
     * @type {string}
     * @memberof NomenclatureUpdateSchema
     */
    'unit'?: string;
    /**
     * Weight
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'weight'?: number;
    /**
     * Width
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'width'?: number;
    /**
     * Height
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'height'?: number;
    /**
     * Length
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'length'?: number;
    /**
     * Minimum number of nomenclatures to order
     * @type {number}
     * @memberof NomenclatureUpdateSchema
     */
    'minOrderQuantity': number;
    /**
     * Comment
     * @type {string}
     * @memberof NomenclatureUpdateSchema
     */
    'comment'?: string;
}
/**
 * Nomenclature video link detail schema.
 * @export
 * @interface NomenclatureVideoLinkDetailSchema
 */
export interface NomenclatureVideoLinkDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof NomenclatureVideoLinkDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NomenclatureVideoLinkDetailSchema
     */
    'link': string;
}
/**
 * Schema for nomenclatures page.
 * @export
 * @interface NomenclaturesPage
 */
export interface NomenclaturesPage {
    /**
     * 
     * @type {Array<NomenclatureListSchema>}
     * @memberof NomenclaturesPage
     */
    'items': Array<NomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NomenclaturesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NomenclaturesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NomenclaturesPage
     */
    'totalPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof NomenclaturesPage
     */
    'canViewCostPrice'?: boolean;
}
/**
 * Brand nomenclature for report schema.
 * @export
 * @interface NotNomenclatureForReportSchema
 */
export interface NotNomenclatureForReportSchema {
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NotNomenclatureForReportSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'incomeQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'expenseQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'stockStart': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'stockEnd': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'sumCostPriceStart': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'sumCostPriceEnd': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'incomeSumCostPrice': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureForReportSchema
     */
    'expenseSumCostPrice': number;
}
/**
 * Brand nomenclature report page schema.
 * @export
 * @interface NotNomenclatureReportPageSchema
 */
export interface NotNomenclatureReportPageSchema {
    /**
     * 
     * @type {Array<NotNomenclatureForReportSchema>}
     * @memberof NotNomenclatureReportPageSchema
     */
    'items': Array<NotNomenclatureForReportSchema>;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'stockEndTotal': number;
    /**
     * 
     * @type {number}
     * @memberof NotNomenclatureReportPageSchema
     */
    'sumCostPriceEndTotal': number;
}
/**
 * Create note schema.
 * @export
 * @interface NoteCreateSchema
 */
export interface NoteCreateSchema {
    /**
     * Text
     * @type {string}
     * @memberof NoteCreateSchema
     */
    'text': string;
}
/**
 * Note detail schema.
 * @export
 * @interface NoteDetailSchema
 */
export interface NoteDetailSchema {
    /**
     * Text
     * @type {string}
     * @memberof NoteDetailSchema
     */
    'text': string;
    /**
     * 
     * @type {number}
     * @memberof NoteDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NoteDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserWithCountrySchema}
     * @memberof NoteDetailSchema
     */
    'creator': SimpleUserWithCountrySchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof NoteDetailSchema
     */
    'creatorKind': UserTypes;
    /**
     * 
     * @type {Array<NoteFileSchema>}
     * @memberof NoteDetailSchema
     */
    'files': Array<NoteFileSchema>;
}
/**
 * Note file schema.
 * @export
 * @interface NoteFileSchema
 */
export interface NoteFileSchema {
    /**
     * 
     * @type {number}
     * @memberof NoteFileSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NoteFileSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NoteFileSchema
     */
    'file': string;
    /**
     * 
     * @type {number}
     * @memberof NoteFileSchema
     */
    'noteId': number;
}
/**
 * Note list schema.
 * @export
 * @interface NoteListSchema
 */
export interface NoteListSchema {
    /**
     * Text
     * @type {string}
     * @memberof NoteListSchema
     */
    'text': string;
    /**
     * 
     * @type {number}
     * @memberof NoteListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NoteListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserWithCountrySchema}
     * @memberof NoteListSchema
     */
    'creator': SimpleUserWithCountrySchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof NoteListSchema
     */
    'creatorKind': UserTypes;
    /**
     * 
     * @type {Array<NoteFileSchema>}
     * @memberof NoteListSchema
     */
    'files': Array<NoteFileSchema>;
}
/**
 * Note page schema.
 * @export
 * @interface NotePageSchema
 */
export interface NotePageSchema {
    /**
     * 
     * @type {Array<NoteListSchema>}
     * @memberof NotePageSchema
     */
    'items': Array<NoteListSchema>;
    /**
     * 
     * @type {number}
     * @memberof NotePageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof NotePageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof NotePageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof NotePageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof NotePageSchema
     */
    'totalPages': number;
}
/**
 * Document type enum.
 * @export
 * @enum {string}
 */

export const NoteTypes = {
    Agent: 'agent',
    Client: 'client',
    Supplier: 'supplier',
    Staff: 'staff',
    Profile: 'profile'
} as const;

export type NoteTypes = typeof NoteTypes[keyof typeof NoteTypes];


/**
 * Update note schema.
 * @export
 * @interface NoteUpdateSchema
 */
export interface NoteUpdateSchema {
    /**
     * Text
     * @type {string}
     * @memberof NoteUpdateSchema
     */
    'text': string;
}
/**
 * Notification schema.
 * @export
 * @interface NotificationSchema
 */
export interface NotificationSchema {
    /**
     * 
     * @type {NotificationTagSchema}
     * @memberof NotificationSchema
     */
    'tag': NotificationTagSchema;
    /**
     * 
     * @type {string}
     * @memberof NotificationSchema
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSchema
     */
    'textRu': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSchema
     */
    'textEn': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSchema
     */
    'textSl': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSchema
     */
    'dateCreated': string;
}
/**
 * Notification tag schema.
 * @export
 * @interface NotificationTagSchema
 */
export interface NotificationTagSchema {
    /**
     * 
     * @type {number}
     * @memberof NotificationTagSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationTagSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTagSchema
     */
    'color': string;
}
/**
 * 
 * @export
 * @interface ObjectId
 */
export interface ObjectId {
}
/**
 * Order debt document schema.
 * @export
 * @interface OrderDebtDocumentSchema
 */
export interface OrderDebtDocumentSchema {
    /**
     * 
     * @type {number}
     * @memberof OrderDebtDocumentSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDebtDocumentSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDebtDocumentSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderDebtDocumentTypes}
     * @memberof OrderDebtDocumentSchema
     */
    'documentDebtType': OrderDebtDocumentTypes;
}
/**
 * Order debt document type choices.
 * @export
 * @enum {string}
 */

export const OrderDebtDocumentTypes = {
    ClientOrder: 'client_order',
    SupplierOrder: 'supplier_order',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientPayment: 'client_payment',
    SupplierPayment: 'supplier_payment'
} as const;

export type OrderDebtDocumentTypes = typeof OrderDebtDocumentTypes[keyof typeof OrderDebtDocumentTypes];


/**
 * Order debt schema.
 * @export
 * @interface OrderDebtSchema
 */
export interface OrderDebtSchema {
    /**
     * 
     * @type {number}
     * @memberof OrderDebtSchema
     */
    'sum': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDebtSchema
     */
    'dateUntil': string;
    /**
     * 
     * @type {OrderDebtDocumentSchema}
     * @memberof OrderDebtSchema
     */
    'document': OrderDebtDocumentSchema;
    /**
     * 
     * @type {Array<DebtSchema>}
     * @memberof OrderDebtSchema
     */
    'children': Array<DebtSchema>;
}
/**
 * Order nomenclature reserve page schema.
 * @export
 * @interface OrderExpectedNomenclaturePage
 */
export interface OrderExpectedNomenclaturePage {
    /**
     * 
     * @type {Array<SupplierOrderWithExpectedNomenclatureListSchema>}
     * @memberof OrderExpectedNomenclaturePage
     */
    'items': Array<SupplierOrderWithExpectedNomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof OrderExpectedNomenclaturePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof OrderExpectedNomenclaturePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof OrderExpectedNomenclaturePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof OrderExpectedNomenclaturePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof OrderExpectedNomenclaturePage
     */
    'totalPages': number;
}
/**
 * Order nomenclature reserve page schema.
 * @export
 * @interface OrderNomenclatureReservePage
 */
export interface OrderNomenclatureReservePage {
    /**
     * 
     * @type {Array<ClientOrderWithReserveListSchema>}
     * @memberof OrderNomenclatureReservePage
     */
    'items': Array<ClientOrderWithReserveListSchema>;
    /**
     * 
     * @type {number}
     * @memberof OrderNomenclatureReservePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof OrderNomenclatureReservePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof OrderNomenclatureReservePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof OrderNomenclatureReservePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof OrderNomenclatureReservePage
     */
    'totalPages': number;
}
/**
 * Order nomenclature types model.
 * @export
 * @enum {string}
 */

export const OrderNomenclatureTypes = {
    Invoice: 'for_invoice',
    Proforma: 'for_proforma'
} as const;

export type OrderNomenclatureTypes = typeof OrderNomenclatureTypes[keyof typeof OrderNomenclatureTypes];


/**
 * OrderStatus model.
 * @export
 * @enum {string}
 */

export const OrderStatuses = {
    Ordering: 'ordering',
    Created: 'created',
    InProgress: 'in_progress',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type OrderStatuses = typeof OrderStatuses[keyof typeof OrderStatuses];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const OrderStatusesQuery = {
    Ordering: 'ordering',
    Created: 'created',
    InProgress: 'in_progress',
    Completed: 'completed',
    Cancelled: 'cancelled',
    CreatedByClient: 'created_by_client',
    CreatedByStaff: 'created_by_staff',
    CreatedByAgent: 'created_by_agent'
} as const;

export type OrderStatusesQuery = typeof OrderStatusesQuery[keyof typeof OrderStatusesQuery];


/**
 * OrderStatus model.
 * @export
 * @enum {string}
 */

export const OrderUpdateStatuses = {
    Created: 'created',
    InProgress: 'in_progress',
    Completed: 'completed'
} as const;

export type OrderUpdateStatuses = typeof OrderUpdateStatuses[keyof typeof OrderUpdateStatuses];


/**
 * Payment order base document choices.
 * @export
 * @enum {string}
 */

export const PaymentOrderBaseDocumentTypes = {
    ClientProforma: 'client_proforma',
    SupplierProforma: 'supplier_proforma',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return'
} as const;

export type PaymentOrderBaseDocumentTypes = typeof PaymentOrderBaseDocumentTypes[keyof typeof PaymentOrderBaseDocumentTypes];


/**
 * Payment order cancellation schema.
 * @export
 * @interface PaymentOrderCancellationSchema
 */
export interface PaymentOrderCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof PaymentOrderCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof PaymentOrderCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Payment order create schema.
 * @export
 * @interface PaymentOrderCreateSchema
 */
export interface PaymentOrderCreateSchema {
    /**
     * Payment order status.
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrderCreateSchema
     */
    'status': PaymentOrderStatuses;
    /**
     * Date operation.
     * @type {string}
     * @memberof PaymentOrderCreateSchema
     */
    'dateOperation': string;
    /**
     * Has auto allocation. False can be set only for supplier/client_payment types.
     * @type {boolean}
     * @memberof PaymentOrderCreateSchema
     */
    'hasAutoAllocation': boolean;
    /**
     * Financial analysis item ID. Only active items.
     * @type {number}
     * @memberof PaymentOrderCreateSchema
     */
    'finItemId': number;
    /**
     * Only proformas with status \'submitted_for_payment\' and \'partially_paid\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'supplierBaseProformas'?: Array<BaseDocumentSchema>;
    /**
     * Only invoices with status \'conducted\' and with debt.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'supplierBaseInvoices'?: Array<BaseDocumentSchema>;
    /**
     * Only product returns with status \'conducted\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'supplierBaseReturns'?: Array<BaseDocumentSchema>;
    /**
     * Only proformas with status \'submitted_for_payment\' and \'partially_paid\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'clientBaseProformas'?: Array<BaseDocumentSchema>;
    /**
     * Only invoices with status \'conducted\' and with debt.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'clientBaseInvoices'?: Array<BaseDocumentSchema>;
    /**
     * Only product returns with status \'completed\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'clientBaseReturns'?: Array<BaseDocumentSchema>;
    /**
     * Payment sum.
     * @type {number}
     * @memberof PaymentOrderCreateSchema
     */
    'sum': number;
    /**
     * Is VAT.
     * @type {boolean}
     * @memberof PaymentOrderCreateSchema
     */
    'isVat': boolean;
    /**
     * VAT rate.
     * @type {VatRates}
     * @memberof PaymentOrderCreateSchema
     */
    'vatRate'?: VatRates;
    /**
     * Purpose of payment (comment)
     * @type {string}
     * @memberof PaymentOrderCreateSchema
     */
    'comment'?: string;
    /**
     * This field will be used only if has_auto_allocation=False. Only client/supplier invoices with status \'conducted\' and with debt.
     * @type {Array<BaseInvoicePaymentChangeSchema>}
     * @memberof PaymentOrderCreateSchema
     */
    'invoicePayments'?: Array<BaseInvoicePaymentChangeSchema>;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof PaymentOrderCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof PaymentOrderCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof PaymentOrderCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Document type.
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrderCreateSchema
     */
    'documentType': PaymentOrderDocumentTypes;
    /**
     * Bank account ID or cashbox ID. Only active items.
     * @type {number}
     * @memberof PaymentOrderCreateSchema
     */
    'sourceId': number;
    /**
     * Payment order type.
     * @type {PaymentOrderTypes}
     * @memberof PaymentOrderCreateSchema
     */
    'type': PaymentOrderTypes;
    /**
     * Contragent ID. Only active clients/suppliers.
     * @type {string}
     * @memberof PaymentOrderCreateSchema
     */
    'contragentId'?: string;
    /**
     * User kind. Only client/supplier
     * @type {CabinetUserKinds}
     * @memberof PaymentOrderCreateSchema
     */
    'userKind'?: CabinetUserKinds;
}
/**
 * Payment order detail schema.
 * @export
 * @interface PaymentOrderDetailSchema
 */
export interface PaymentOrderDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderDetailSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentOrderDetailSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {Array<SimpleProformaSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'supplierBaseProformas': Array<SimpleProformaSchema>;
    /**
     * 
     * @type {Array<SimpleSupplierInvoiceSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'supplierBaseInvoices': Array<SimpleSupplierInvoiceSchema>;
    /**
     * 
     * @type {Array<SimpleProductReturnSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'supplierBaseReturns': Array<SimpleProductReturnSchema>;
    /**
     * 
     * @type {Array<SimpleProformaSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'clientBaseProformas': Array<SimpleProformaSchema>;
    /**
     * 
     * @type {Array<SimpleClientInvoiceSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'clientBaseInvoices': Array<SimpleClientInvoiceSchema>;
    /**
     * 
     * @type {Array<SimpleProductReturnSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'clientBaseReturns': Array<SimpleProductReturnSchema>;
    /**
     * 
     * @type {Array<BaseDocumentListSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'baseDocuments'?: Array<BaseDocumentListSchema>;
    /**
     * Document number.
     * @type {string}
     * @memberof PaymentOrderDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof PaymentOrderDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof PaymentOrderDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof PaymentOrderDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrderDetailSchema
     */
    'documentType': PaymentOrderDocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderDetailSchema
     */
    'dateOperation': string;
    /**
     * 
     * @type {AccountCashboxComplexSchema}
     * @memberof PaymentOrderDetailSchema
     */
    'source': AccountCashboxComplexSchema;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderDetailSchema
     */
    'sum': number;
    /**
     * 
     * @type {SimpleFinancialAnalysisItemSchema}
     * @memberof PaymentOrderDetailSchema
     */
    'finItem': SimpleFinancialAnalysisItemSchema;
    /**
     * 
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrderDetailSchema
     */
    'status': PaymentOrderStatuses;
    /**
     * 
     * @type {PaymentOrderTypes}
     * @memberof PaymentOrderDetailSchema
     */
    'type': PaymentOrderTypes;
    /**
     * 
     * @type {SimpleUserWithVat}
     * @memberof PaymentOrderDetailSchema
     */
    'contragent'?: SimpleUserWithVat;
    /**
     * 
     * @type {CabinetUserKinds}
     * @memberof PaymentOrderDetailSchema
     */
    'userKind'?: CabinetUserKinds;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof PaymentOrderDetailSchema
     */
    'userCurrency'?: ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentOrderDetailSchema
     */
    'isVat': boolean;
    /**
     * 
     * @type {VatRates}
     * @memberof PaymentOrderDetailSchema
     */
    'vatRate'?: VatRates;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentOrderDetailSchema
     */
    'hasAutoAllocation': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderDetailSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<BaseInvoicePaymentSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'supplierInvoicePayments': Array<BaseInvoicePaymentSchema>;
    /**
     * 
     * @type {Array<BaseInvoicePaymentSchema>}
     * @memberof PaymentOrderDetailSchema
     */
    'clientInvoicePayments': Array<BaseInvoicePaymentSchema>;
}
/**
 * Payment order document choices.
 * @export
 * @enum {string}
 */

export const PaymentOrderDocumentTypes = {
    IncomingPaymentOrder: 'incoming_payment_order',
    OutgoingPaymentOrder: 'outgoing_payment_order',
    IncomingCashOrder: 'incoming_cash_order',
    OutgoingCashOrder: 'outgoing_cash_order'
} as const;

export type PaymentOrderDocumentTypes = typeof PaymentOrderDocumentTypes[keyof typeof PaymentOrderDocumentTypes];


/**
 * PaymentOrder list schema.
 * @export
 * @interface PaymentOrderListSchema
 */
export interface PaymentOrderListSchema {
    /**
     * 
     * @type {Array<SimpleProformaSchema>}
     * @memberof PaymentOrderListSchema
     */
    'supplierBaseProformas': Array<SimpleProformaSchema>;
    /**
     * 
     * @type {Array<SimpleSupplierInvoiceSchema>}
     * @memberof PaymentOrderListSchema
     */
    'supplierBaseInvoices': Array<SimpleSupplierInvoiceSchema>;
    /**
     * 
     * @type {Array<SimpleProductReturnSchema>}
     * @memberof PaymentOrderListSchema
     */
    'supplierBaseReturns': Array<SimpleProductReturnSchema>;
    /**
     * 
     * @type {Array<SimpleProformaSchema>}
     * @memberof PaymentOrderListSchema
     */
    'clientBaseProformas': Array<SimpleProformaSchema>;
    /**
     * 
     * @type {Array<SimpleClientInvoiceSchema>}
     * @memberof PaymentOrderListSchema
     */
    'clientBaseInvoices': Array<SimpleClientInvoiceSchema>;
    /**
     * 
     * @type {Array<SimpleProductReturnSchema>}
     * @memberof PaymentOrderListSchema
     */
    'clientBaseReturns': Array<SimpleProductReturnSchema>;
    /**
     * 
     * @type {Array<BaseDocumentListSchema>}
     * @memberof PaymentOrderListSchema
     */
    'baseDocuments'?: Array<BaseDocumentListSchema>;
    /**
     * Document number.
     * @type {string}
     * @memberof PaymentOrderListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof PaymentOrderListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof PaymentOrderListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof PaymentOrderListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrderListSchema
     */
    'documentType': PaymentOrderDocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderListSchema
     */
    'dateOperation': string;
    /**
     * 
     * @type {AccountCashboxForPaymentOrderSchema}
     * @memberof PaymentOrderListSchema
     */
    'source': AccountCashboxForPaymentOrderSchema;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderListSchema
     */
    'sum': number;
    /**
     * 
     * @type {SimpleFinancialAnalysisItemSchema}
     * @memberof PaymentOrderListSchema
     */
    'finItem': SimpleFinancialAnalysisItemSchema;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof PaymentOrderListSchema
     */
    'creator': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrderListSchema
     */
    'status': PaymentOrderStatuses;
    /**
     * 
     * @type {PaymentOrderTypes}
     * @memberof PaymentOrderListSchema
     */
    'type': PaymentOrderTypes;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof PaymentOrderListSchema
     */
    'contragent'?: SimpleUserSchema;
}
/**
 * Payment order object choices.
 * @export
 * @enum {string}
 */

export const PaymentOrderObjectTypes = {
    Client: 'client',
    Supplier: 'supplier',
    ClientOrder: 'client_order',
    SupplierOrder: 'supplier_order',
    ClientProforma: 'client_proforma',
    SupplierProforma: 'supplier_proforma',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return'
} as const;

export type PaymentOrderObjectTypes = typeof PaymentOrderObjectTypes[keyof typeof PaymentOrderObjectTypes];


/**
 * PaymentOrder page schema.
 * @export
 * @interface PaymentOrderPage
 */
export interface PaymentOrderPage {
    /**
     * 
     * @type {Array<PaymentOrderListSchema>}
     * @memberof PaymentOrderPage
     */
    'items': Array<PaymentOrderListSchema>;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof PaymentOrderPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof PaymentOrderPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof PaymentOrderPage
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<CurrencyPaymentOperationSchema>}
     * @memberof PaymentOrderPage
     */
    'currencies'?: Array<CurrencyPaymentOperationSchema>;
}
/**
 * Payment order status choices.
 * @export
 * @enum {string}
 */

export const PaymentOrderStatuses = {
    Created: 'created',
    Conducted: 'conducted'
} as const;

export type PaymentOrderStatuses = typeof PaymentOrderStatuses[keyof typeof PaymentOrderStatuses];


/**
 * PaymentOrder sublist page schema.
 * @export
 * @interface PaymentOrderSublistPage
 */
export interface PaymentOrderSublistPage {
    /**
     * 
     * @type {Array<PaymentOrderSublistSchema>}
     * @memberof PaymentOrderSublistPage
     */
    'items': Array<PaymentOrderSublistSchema>;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderSublistPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderSublistPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof PaymentOrderSublistPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof PaymentOrderSublistPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof PaymentOrderSublistPage
     */
    'totalPages': number;
}
/**
 * PaymentOrder sublist schema.
 * @export
 * @interface PaymentOrderSublistSchema
 */
export interface PaymentOrderSublistSchema {
    /**
     * 
     * @type {Array<SimpleProformaSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'supplierBaseProformas': Array<SimpleProformaSchema>;
    /**
     * 
     * @type {Array<SimpleSupplierInvoiceSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'supplierBaseInvoices': Array<SimpleSupplierInvoiceSchema>;
    /**
     * 
     * @type {Array<SimpleProductReturnSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'supplierBaseReturns': Array<SimpleProductReturnSchema>;
    /**
     * 
     * @type {Array<SimpleProformaSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'clientBaseProformas': Array<SimpleProformaSchema>;
    /**
     * 
     * @type {Array<SimpleClientInvoiceSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'clientBaseInvoices': Array<SimpleClientInvoiceSchema>;
    /**
     * 
     * @type {Array<SimpleProductReturnSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'clientBaseReturns': Array<SimpleProductReturnSchema>;
    /**
     * 
     * @type {Array<BaseDocumentListSchema>}
     * @memberof PaymentOrderSublistSchema
     */
    'baseDocuments'?: Array<BaseDocumentListSchema>;
    /**
     * Document number.
     * @type {string}
     * @memberof PaymentOrderSublistSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof PaymentOrderSublistSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof PaymentOrderSublistSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof PaymentOrderSublistSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderSublistSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderSublistSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrderSublistSchema
     */
    'documentType': PaymentOrderDocumentTypes;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrderSublistSchema
     */
    'dateOperation': string;
    /**
     * 
     * @type {AccountCashboxForPaymentOrderSchema}
     * @memberof PaymentOrderSublistSchema
     */
    'source': AccountCashboxForPaymentOrderSchema;
    /**
     * 
     * @type {number}
     * @memberof PaymentOrderSublistSchema
     */
    'sum': number;
    /**
     * 
     * @type {SimpleFinancialAnalysisItemSchema}
     * @memberof PaymentOrderSublistSchema
     */
    'finItem': SimpleFinancialAnalysisItemSchema;
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof PaymentOrderSublistSchema
     */
    'creator': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrderSublistSchema
     */
    'status': PaymentOrderStatuses;
}
/**
 * Payment order type choices.
 * @export
 * @enum {string}
 */

export const PaymentOrderTypes = {
    SupplierPayment: 'supplier_payment',
    ClientPayment: 'client_payment',
    SupplierReturn: 'supplier_return',
    ClientReturn: 'client_return',
    WriteOffOther: 'write_off_other',
    ReplenishmentOther: 'replenishment_other',
    WriteOff: 'write_off',
    Replenishment: 'replenishment'
} as const;

export type PaymentOrderTypes = typeof PaymentOrderTypes[keyof typeof PaymentOrderTypes];


/**
 * Payment order update schema.
 * @export
 * @interface PaymentOrderUpdateSchema
 */
export interface PaymentOrderUpdateSchema {
    /**
     * Payment order status.
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrderUpdateSchema
     */
    'status': PaymentOrderStatuses;
    /**
     * Date operation.
     * @type {string}
     * @memberof PaymentOrderUpdateSchema
     */
    'dateOperation': string;
    /**
     * Has auto allocation. False can be set only for supplier/client_payment types.
     * @type {boolean}
     * @memberof PaymentOrderUpdateSchema
     */
    'hasAutoAllocation': boolean;
    /**
     * Financial analysis item ID. Only active items.
     * @type {number}
     * @memberof PaymentOrderUpdateSchema
     */
    'finItemId': number;
    /**
     * Only proformas with status \'submitted_for_payment\' and \'partially_paid\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'supplierBaseProformas'?: Array<BaseDocumentSchema>;
    /**
     * Only invoices with status \'conducted\' and with debt.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'supplierBaseInvoices'?: Array<BaseDocumentSchema>;
    /**
     * Only product returns with status \'conducted\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'supplierBaseReturns'?: Array<BaseDocumentSchema>;
    /**
     * Only proformas with status \'submitted_for_payment\' and \'partially_paid\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'clientBaseProformas'?: Array<BaseDocumentSchema>;
    /**
     * Only invoices with status \'conducted\' and with debt.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'clientBaseInvoices'?: Array<BaseDocumentSchema>;
    /**
     * Only product returns with status \'completed\'.
     * @type {Array<BaseDocumentSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'clientBaseReturns'?: Array<BaseDocumentSchema>;
    /**
     * Payment sum.
     * @type {number}
     * @memberof PaymentOrderUpdateSchema
     */
    'sum': number;
    /**
     * Is VAT.
     * @type {boolean}
     * @memberof PaymentOrderUpdateSchema
     */
    'isVat': boolean;
    /**
     * VAT rate.
     * @type {VatRates}
     * @memberof PaymentOrderUpdateSchema
     */
    'vatRate'?: VatRates;
    /**
     * Purpose of payment (comment)
     * @type {string}
     * @memberof PaymentOrderUpdateSchema
     */
    'comment'?: string;
    /**
     * This field will be used only if has_auto_allocation=False. Only client/supplier invoices with status \'conducted\' and with debt.
     * @type {Array<BaseInvoicePaymentChangeSchema>}
     * @memberof PaymentOrderUpdateSchema
     */
    'invoicePayments'?: Array<BaseInvoicePaymentChangeSchema>;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof PaymentOrderUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof PaymentOrderUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof PaymentOrderUpdateSchema
     */
    'documentNumberSuffix'?: string;
}
/**
 * Create position schema.
 * @export
 * @interface PositionCreateSchema
 */
export interface PositionCreateSchema {
    /**
     * position name
     * @type {string}
     * @memberof PositionCreateSchema
     */
    'name': string;
    /**
     * Is active
     * @type {boolean}
     * @memberof PositionCreateSchema
     */
    'isActive': boolean;
}
/**
 * Position schema.
 * @export
 * @interface PositionDetailSchema
 */
export interface PositionDetailSchema {
    /**
     * position name
     * @type {string}
     * @memberof PositionDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PositionDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PositionDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof PositionDetailSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof PositionDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof PositionDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Position schema.
 * @export
 * @interface PositionListSchema
 */
export interface PositionListSchema {
    /**
     * position name
     * @type {string}
     * @memberof PositionListSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PositionListSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PositionListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionListSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof PositionListSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof PositionListSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof PositionListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Position page schema.
 * @export
 * @interface PositionPage
 */
export interface PositionPage {
    /**
     * 
     * @type {Array<PositionListSchema>}
     * @memberof PositionPage
     */
    'items': Array<PositionListSchema>;
    /**
     * 
     * @type {number}
     * @memberof PositionPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PositionPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof PositionPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof PositionPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof PositionPage
     */
    'totalPages': number;
}
/**
 * Position query order.
 * @export
 * @enum {string}
 */

export const PositionQueryOrder = {
    Id: 'id',
    Name: 'name',
    DateCreated: 'dateCreated',
    Status: 'status'
} as const;

export type PositionQueryOrder = typeof PositionQueryOrder[keyof typeof PositionQueryOrder];


/**
 * Position simple schema.
 * @export
 * @interface PositionSimpleSchema
 */
export interface PositionSimpleSchema {
    /**
     * position name
     * @type {string}
     * @memberof PositionSimpleSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PositionSimpleSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PositionSimpleSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionSimpleSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof PositionSimpleSchema
     */
    'dateCreated': string;
}
/**
 * Update position schema.
 * @export
 * @interface PositionUpdateSchema
 */
export interface PositionUpdateSchema {
    /**
     * position name
     * @type {string}
     * @memberof PositionUpdateSchema
     */
    'name': string;
    /**
     * Is active
     * @type {boolean}
     * @memberof PositionUpdateSchema
     */
    'isActive': boolean;
}
/**
 * Create price category schema.
 * @export
 * @interface PriceCategoryCreateSchema
 */
export interface PriceCategoryCreateSchema {
    /**
     * Name
     * @type {string}
     * @memberof PriceCategoryCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryCreateSchema
     */
    'isStockShownInCabinets': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryCreateSchema
     */
    'isShownForAgents': boolean;
    /**
     * Is active
     * @type {boolean}
     * @memberof PriceCategoryCreateSchema
     */
    'isActive': boolean;
}
/**
 * PriceCategory schema.
 * @export
 * @interface PriceCategoryDetailSchema
 */
export interface PriceCategoryDetailSchema {
    /**
     * Name
     * @type {string}
     * @memberof PriceCategoryDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'isStockShownInCabinets': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'isShownForAgents': boolean;
    /**
     * 
     * @type {number}
     * @memberof PriceCategoryDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof PriceCategoryDetailSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'canBeDeleted'?: boolean;
    /**
     * Is retail price category or not.
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'isRetailPrice': boolean;
    /**
     * Can be edited. If False, Cannot be edited.
     * @type {boolean}
     * @memberof PriceCategoryDetailSchema
     */
    'canBeEdited'?: boolean;
}
/**
 * Price category for nomenclature price list schema.
 * @export
 * @interface PriceCategoryForNomenclaturePriceListSchema
 */
export interface PriceCategoryForNomenclaturePriceListSchema {
    /**
     * Name
     * @type {string}
     * @memberof PriceCategoryForNomenclaturePriceListSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PriceCategoryForNomenclaturePriceListSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryForNomenclaturePriceListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryForNomenclaturePriceListSchema
     */
    'isBase': boolean;
}
/**
 * PriceCategory schema.
 * @export
 * @interface PriceCategoryListSchema
 */
export interface PriceCategoryListSchema {
    /**
     * Name
     * @type {string}
     * @memberof PriceCategoryListSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'isStockShownInCabinets': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'isShownForAgents': boolean;
    /**
     * 
     * @type {number}
     * @memberof PriceCategoryListSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof PriceCategoryListSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'canBeDeleted'?: boolean;
    /**
     * Is retail price category or not.
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'isRetailPrice': boolean;
    /**
     * Can be edited. If False, Cannot be edited.
     * @type {boolean}
     * @memberof PriceCategoryListSchema
     */
    'canBeEdited'?: boolean;
}
/**
 * PriceCategories page schema.
 * @export
 * @interface PriceCategoryPage
 */
export interface PriceCategoryPage {
    /**
     * 
     * @type {Array<PriceCategoryListSchema>}
     * @memberof PriceCategoryPage
     */
    'items': Array<PriceCategoryListSchema>;
    /**
     * 
     * @type {number}
     * @memberof PriceCategoryPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PriceCategoryPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof PriceCategoryPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof PriceCategoryPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof PriceCategoryPage
     */
    'totalPages': number;
}
/**
 * PriceCategory simple schema.
 * @export
 * @interface PriceCategorySimpleSchema
 */
export interface PriceCategorySimpleSchema {
    /**
     * Name
     * @type {string}
     * @memberof PriceCategorySimpleSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PriceCategorySimpleSchema
     */
    'id': number;
}
/**
 * Update price category schema.
 * @export
 * @interface PriceCategoryUpdateSchema
 */
export interface PriceCategoryUpdateSchema {
    /**
     * Name
     * @type {string}
     * @memberof PriceCategoryUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryUpdateSchema
     */
    'isStockShownInCabinets': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PriceCategoryUpdateSchema
     */
    'isShownForAgents': boolean;
    /**
     * Is active
     * @type {boolean}
     * @memberof PriceCategoryUpdateSchema
     */
    'isActive': boolean;
}
/**
 * PriceListLog schema.
 * @export
 * @interface PriceListLogSchema
 */
export interface PriceListLogSchema {
    /**
     * 
     * @type {number}
     * @memberof PriceListLogSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PriceListLogSchema
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PriceListLogSchema
     */
    'isSuccessful': boolean;
}
/**
 * PriceList schema with count.
 * @export
 * @interface PriceListSchemaWithCount
 */
export interface PriceListSchemaWithCount {
    /**
     * 
     * @type {number}
     * @memberof PriceListSchemaWithCount
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PriceListSchemaWithCount
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof PriceListSchemaWithCount
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof PriceListSchemaWithCount
     */
    'priceNomenclaturesCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof PriceListSchemaWithCount
     */
    'isOutdated': boolean;
}
/**
 * PriceList schema with supplier.
 * @export
 * @interface PriceListSchemaWithSupplier
 */
export interface PriceListSchemaWithSupplier {
    /**
     * 
     * @type {number}
     * @memberof PriceListSchemaWithSupplier
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PriceListSchemaWithSupplier
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof PriceListSchemaWithSupplier
     */
    'filename': string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof PriceListSchemaWithSupplier
     */
    'supplier': SimpleUserSchema;
}
/**
 * PriceListTask schema.
 * @export
 * @interface PriceListTaskSchema
 */
export interface PriceListTaskSchema {
    /**
     * 
     * @type {number}
     * @memberof PriceListTaskSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PriceListTaskSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof PriceListTaskSchema
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof PriceListTaskSchema
     */
    'filename': string;
    /**
     * 
     * @type {Array<SupplierPriceListCellSchema>}
     * @memberof PriceListTaskSchema
     */
    'cells': Array<SupplierPriceListCellSchema>;
    /**
     * 
     * @type {Array<PriceListLogSchema>}
     * @memberof PriceListTaskSchema
     */
    'logsList': Array<PriceListLogSchema>;
    /**
     * 
     * @type {PriceListTaskStatus}
     * @memberof PriceListTaskSchema
     */
    'status': PriceListTaskStatus;
    /**
     * 
     * @type {string}
     * @memberof PriceListTaskSchema
     */
    'socketioRoom': string;
}
/**
 * PriceListTaskStatus model.
 * @export
 * @enum {string}
 */

export const PriceListTaskStatus = {
    New: 'new',
    InProgress: 'in_progress',
    Done: 'done',
    Saving: 'saving'
} as const;

export type PriceListTaskStatus = typeof PriceListTaskStatus[keyof typeof PriceListTaskStatus];


/**
 * PriceNomenclatureQueryOrder model.
 * @export
 * @enum {string}
 */

export const PriceNomenclatureQueryOrder = {
    Id: 'id',
    DateCreated: 'date_created'
} as const;

export type PriceNomenclatureQueryOrder = typeof PriceNomenclatureQueryOrder[keyof typeof PriceNomenclatureQueryOrder];


/**
 * Product movement cancellation schema.
 * @export
 * @interface ProductMovementCancellationSchema
 */
export interface ProductMovementCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof ProductMovementCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof ProductMovementCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Product movement create schema.
 * @export
 * @interface ProductMovementCreateSchema
 */
export interface ProductMovementCreateSchema {
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ProductMovementCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ProductMovementCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ProductMovementCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Warehouse ID from which the products will be moved.
     * @type {number}
     * @memberof ProductMovementCreateSchema
     */
    'sendingWarehouseId': number;
    /**
     * Warehouse ID to which the products will be received 
     * @type {number}
     * @memberof ProductMovementCreateSchema
     */
    'receivingWarehouseId': number;
    /**
     * 
     * @type {Array<ProductMovementNomenclatureCreateSchema>}
     * @memberof ProductMovementCreateSchema
     */
    'nomenclatures': Array<ProductMovementNomenclatureCreateSchema>;
    /**
     * Comment
     * @type {string}
     * @memberof ProductMovementCreateSchema
     */
    'comment'?: string;
}
/**
 * Product movement detail schema.
 * @export
 * @interface ProductMovementDetailSchema
 */
export interface ProductMovementDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof ProductMovementDetailSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ProductMovementDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ProductMovementDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ProductMovementDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductMovementDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ProductMovementDetailSchema
     */
    'sendingWarehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ProductMovementDetailSchema
     */
    'receivingWarehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ProductMovementDetailSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {ProductMovementStatuses}
     * @memberof ProductMovementDetailSchema
     */
    'status': ProductMovementStatuses;
    /**
     * 
     * @type {Array<ProductMovementNomenclatureDetailSchema>}
     * @memberof ProductMovementDetailSchema
     */
    'movementProducts': Array<ProductMovementNomenclatureDetailSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'hasChangePerm'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'hasConductPerm'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'hasCancelPerm'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'canConduct'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementDetailSchema
     */
    'canCancel'?: boolean;
}
/**
 * Product movement list schema.
 * @export
 * @interface ProductMovementListSchema
 */
export interface ProductMovementListSchema {
    /**
     * 
     * @type {string}
     * @memberof ProductMovementListSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMovementListSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ProductMovementListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ProductMovementListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ProductMovementListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductMovementListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ProductMovementListSchema
     */
    'sendingWarehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof ProductMovementListSchema
     */
    'receivingWarehouse': SimpleWarehouseSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ProductMovementListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {ProductMovementStatuses}
     * @memberof ProductMovementListSchema
     */
    'status': ProductMovementStatuses;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementListSchema
     */
    'totalQuantity': number;
}
/**
 * Product movement nomenclature create schema.
 * @export
 * @interface ProductMovementNomenclatureCreateSchema
 */
export interface ProductMovementNomenclatureCreateSchema {
    /**
     * Nomenclature ID.
     * @type {number}
     * @memberof ProductMovementNomenclatureCreateSchema
     */
    'nomenclatureId': number;
    /**
     * Quantity of products to be moved.
     * @type {number}
     * @memberof ProductMovementNomenclatureCreateSchema
     */
    'quantity': number;
}
/**
 * Base product movement nomenclature schema.
 * @export
 * @interface ProductMovementNomenclatureDetailSchema
 */
export interface ProductMovementNomenclatureDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {NomenclatureMovementSchema}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'nomenclature': NomenclatureMovementSchema;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'sendingWarehouseQuantity': number;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'sendingWarehouseReserveQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'sendingWarehouseFullQuantityString'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'receivingWarehouseQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementNomenclatureDetailSchema
     */
    'receivingWarehouseReserveQuantity'?: number;
}
/**
 * Product movement operation info choices.
 * @export
 * @enum {string}
 */

export const ProductMovementOperationInfos = {
    Income: 'income',
    Expense: 'expense',
    Movement: 'movement'
} as const;

export type ProductMovementOperationInfos = typeof ProductMovementOperationInfos[keyof typeof ProductMovementOperationInfos];


/**
 * Product movement operation list schema.
 * @export
 * @interface ProductMovementOperationListSchema
 */
export interface ProductMovementOperationListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof ProductMovementOperationListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ProductMovementOperationListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof ProductMovementOperationListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ProductMovementOperationListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementOperationListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductMovementOperationListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {ProductMovementOperationInfos}
     * @memberof ProductMovementOperationListSchema
     */
    'info': ProductMovementOperationInfos;
    /**
     * 
     * @type {ProductMovementOperationTypes}
     * @memberof ProductMovementOperationListSchema
     */
    'type': ProductMovementOperationTypes;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementOperationListSchema
     */
    'documentId': number;
    /**
     * 
     * @type {string}
     * @memberof ProductMovementOperationListSchema
     */
    'documentDateCreated': string;
    /**
     * 
     * @type {ProductNomenclatureUnits}
     * @memberof ProductMovementOperationListSchema
     */
    'unit': ProductNomenclatureUnits;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementOperationListSchema
     */
    'quantity': number;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof ProductMovementOperationListSchema
     */
    'creator': SimpleUserSchema;
}
/**
 * Product movement operation type choices.
 * @export
 * @enum {string}
 */

export const ProductMovementOperationTypes = {
    Movement: 'movement',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return'
} as const;

export type ProductMovementOperationTypes = typeof ProductMovementOperationTypes[keyof typeof ProductMovementOperationTypes];


/**
 * Product movement operations page schema.
 * @export
 * @interface ProductMovementOperationsPage
 */
export interface ProductMovementOperationsPage {
    /**
     * 
     * @type {Array<ProductMovementOperationListSchema>}
     * @memberof ProductMovementOperationsPage
     */
    'items': Array<ProductMovementOperationListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementOperationsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementOperationsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProductMovementOperationsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProductMovementOperationsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProductMovementOperationsPage
     */
    'totalPages': number;
}
/**
 * Product movement params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const ProductMovementQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    DateConduction: 'dateConduction'
} as const;

export type ProductMovementQueryOrder = typeof ProductMovementQueryOrder[keyof typeof ProductMovementQueryOrder];


/**
 * Product movement statuses choices.
 * @export
 * @enum {string}
 */

export const ProductMovementStatuses = {
    Created: 'created',
    Conducted: 'conducted',
    Deleted: 'deleted'
} as const;

export type ProductMovementStatuses = typeof ProductMovementStatuses[keyof typeof ProductMovementStatuses];


/**
 * Product movement update schema.
 * @export
 * @interface ProductMovementUpdateSchema
 */
export interface ProductMovementUpdateSchema {
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof ProductMovementUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof ProductMovementUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof ProductMovementUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Warehouse ID from which the products will be moved.
     * @type {number}
     * @memberof ProductMovementUpdateSchema
     */
    'sendingWarehouseId': number;
    /**
     * Warehouse ID to which the products will be received 
     * @type {number}
     * @memberof ProductMovementUpdateSchema
     */
    'receivingWarehouseId': number;
    /**
     * 
     * @type {Array<ProductMovementNomenclatureCreateSchema>}
     * @memberof ProductMovementUpdateSchema
     */
    'nomenclatures': Array<ProductMovementNomenclatureCreateSchema>;
    /**
     * Comment
     * @type {string}
     * @memberof ProductMovementUpdateSchema
     */
    'comment'?: string;
    /**
     * Status field. Only \'created\' and \'conducted\' statuses available.
     * @type {ProductMovementUpdateStatuses}
     * @memberof ProductMovementUpdateSchema
     */
    'status': ProductMovementUpdateStatuses;
}
/**
 * Product movement statuses choices.
 * @export
 * @enum {string}
 */

export const ProductMovementUpdateStatuses = {
    Created: 'created',
    Conducted: 'conducted'
} as const;

export type ProductMovementUpdateStatuses = typeof ProductMovementUpdateStatuses[keyof typeof ProductMovementUpdateStatuses];


/**
 * Product movement page schema.
 * @export
 * @interface ProductMovementsPage
 */
export interface ProductMovementsPage {
    /**
     * 
     * @type {Array<ProductMovementListSchema>}
     * @memberof ProductMovementsPage
     */
    'items': Array<ProductMovementListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProductMovementsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProductMovementsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProductMovementsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProductMovementsPage
     */
    'totalPages': number;
}
/**
 * Product nomenclature update schema for price list.
 * @export
 * @interface ProductNomenclaturePriceListUpdateSchema
 */
export interface ProductNomenclaturePriceListUpdateSchema {
    /**
     * 
     * @type {Array<NomenclaturePriceCategoryUpdateSchema>}
     * @memberof ProductNomenclaturePriceListUpdateSchema
     */
    'prices': Array<NomenclaturePriceCategoryUpdateSchema>;
}
/**
 * Product nomenclature unit choices.
 * @export
 * @enum {string}
 */

export const ProductNomenclatureUnits = {
    Piece: 'piece',
    Package: 'package',
    Kilogram: 'kilogram',
    Liter: 'liter'
} as const;

export type ProductNomenclatureUnits = typeof ProductNomenclatureUnits[keyof typeof ProductNomenclatureUnits];


/**
 * BaseNomenclatureProductReturn formset schema.
 * @export
 * @interface ProductReturnNomenclatureFormsetSchema
 */
export interface ProductReturnNomenclatureFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnNomenclatureFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductReturnNomenclatureFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductReturnNomenclatureFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductReturnNomenclatureFormsetSchema
     */
    'invoiceNomenclatureId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductReturnNomenclatureFormsetSchema
     */
    'quantity': number;
}
/**
 * ProductReturn query order.
 * @export
 * @enum {string}
 */

export const ProductReturnQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    SumWithVat: 'sumWithVat'
} as const;

export type ProductReturnQueryOrder = typeof ProductReturnQueryOrder[keyof typeof ProductReturnQueryOrder];


/**
 * Base proforma read schema.
 * @export
 * @interface ProductReturnSimpleListSchema
 */
export interface ProductReturnSimpleListSchema {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnSimpleListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductReturnSimpleListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ProductReturnSimpleListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof ProductReturnSimpleListSchema
     */
    'status': ProductReturnStatuses;
    /**
     * 
     * @type {boolean}
     * @memberof ProductReturnSimpleListSchema
     */
    'isEditDateExpired': boolean;
}
/**
 * Client simple page schema.
 * @export
 * @interface ProductReturnSimplePage
 */
export interface ProductReturnSimplePage {
    /**
     * 
     * @type {Array<ProductReturnSimpleListSchema>}
     * @memberof ProductReturnSimplePage
     */
    'items': Array<ProductReturnSimpleListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProductReturnSimplePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProductReturnSimplePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProductReturnSimplePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProductReturnSimplePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProductReturnSimplePage
     */
    'totalPages': number;
}
/**
 * ProductReturn statuses.
 * @export
 * @enum {string}
 */

export const ProductReturnStatuses = {
    InProcessing: 'in_processing',
    Created: 'created',
    Completed: 'completed',
    Deleted: 'deleted'
} as const;

export type ProductReturnStatuses = typeof ProductReturnStatuses[keyof typeof ProductReturnStatuses];


/**
 * Profit default report page schema.
 * @export
 * @interface ProfitDefaultReportPageSchema
 */
export interface ProfitDefaultReportPageSchema {
    /**
     * 
     * @type {Array<BaseReportSchema>}
     * @memberof ProfitDefaultReportPageSchema
     */
    'items': Array<BaseReportSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProfitDefaultReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProfitDefaultReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProfitDefaultReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProfitDefaultReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProfitDefaultReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {BaseReportTotalsSchema}
     * @memberof ProfitDefaultReportPageSchema
     */
    'totals': BaseReportTotalsSchema;
}
/**
 * Profit nomenclature report page schema.
 * @export
 * @interface ProfitNomenclatureReportPageSchema
 */
export interface ProfitNomenclatureReportPageSchema {
    /**
     * 
     * @type {Array<NomenclatureProfitReportSchema>}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'items': Array<NomenclatureProfitReportSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {BaseReportTotalsSchema}
     * @memberof ProfitNomenclatureReportPageSchema
     */
    'totals': BaseReportTotalsSchema;
}
/**
 * Profit report invoices type enum.
 * @export
 * @enum {string}
 */

export const ProfitReportInvoicesType = {
    All: 'all',
    Paid: 'paid'
} as const;

export type ProfitReportInvoicesType = typeof ProfitReportInvoicesType[keyof typeof ProfitReportInvoicesType];


/**
 * Profit report payment type enum.
 * @export
 * @enum {string}
 */

export const ProfitReportPaymentType = {
    Cash: 'cash',
    NonCash: 'non_cash',
    Any: 'any'
} as const;

export type ProfitReportPaymentType = typeof ProfitReportPaymentType[keyof typeof ProfitReportPaymentType];


/**
 * Profit user report page schema.
 * @export
 * @interface ProfitUserReportPageSchema
 */
export interface ProfitUserReportPageSchema {
    /**
     * 
     * @type {Array<UserProfitReportSchema>}
     * @memberof ProfitUserReportPageSchema
     */
    'items': Array<UserProfitReportSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProfitUserReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProfitUserReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProfitUserReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProfitUserReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProfitUserReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {BaseReportTotalsSchema}
     * @memberof ProfitUserReportPageSchema
     */
    'totals': BaseReportTotalsSchema;
}
/**
 * Proforma date payment schema.
 * @export
 * @interface ProformaDatePaymentSchema
 */
export interface ProformaDatePaymentSchema {
    /**
     * 
     * @type {string}
     * @memberof ProformaDatePaymentSchema
     */
    'datePayment': string;
}
/**
 * BaseNomenclatureProforma formset schema.
 * @export
 * @interface ProformaNomenclatureFormsetSchema
 */
export interface ProformaNomenclatureFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof ProformaNomenclatureFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProformaNomenclatureFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProformaNomenclatureFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProformaNomenclatureFormsetSchema
     */
    'orderNomenclatureId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProformaNomenclatureFormsetSchema
     */
    'quantity': number;
}
/**
 * Proforma query order.
 * @export
 * @enum {string}
 */

export const ProformaQueryOrder = {
    Id: 'id',
    DocumentNumber: 'documentNumber',
    DateCreated: 'dateCreated',
    SumWithVat: 'sumWithVat',
    SumPaid: 'sumPaid',
    SumToPay: 'sumToPay'
} as const;

export type ProformaQueryOrder = typeof ProformaQueryOrder[keyof typeof ProformaQueryOrder];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ProformaQueryStatuses = {
    Created: 'created',
    SubmittedForPayment: 'submitted_for_payment',
    PartiallyPaid: 'partially_paid',
    Paid: 'paid',
    Deleted: 'deleted',
    CreatedByClient: 'created_by_client',
    CreatedByStaff: 'created_by_staff'
} as const;

export type ProformaQueryStatuses = typeof ProformaQueryStatuses[keyof typeof ProformaQueryStatuses];


/**
 * Base proforma read schema.
 * @export
 * @interface ProformaSimpleListSchema
 */
export interface ProformaSimpleListSchema {
    /**
     * 
     * @type {number}
     * @memberof ProformaSimpleListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProformaSimpleListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProformaStatuses}
     * @memberof ProformaSimpleListSchema
     */
    'status': ProformaStatuses;
    /**
     * 
     * @type {string}
     * @memberof ProformaSimpleListSchema
     */
    'dateCreated': string;
}
/**
 * Client simple page schema.
 * @export
 * @interface ProformaSimplePage
 */
export interface ProformaSimplePage {
    /**
     * 
     * @type {Array<ProformaSimpleListSchema>}
     * @memberof ProformaSimplePage
     */
    'items': Array<ProformaSimpleListSchema>;
    /**
     * 
     * @type {number}
     * @memberof ProformaSimplePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProformaSimplePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof ProformaSimplePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof ProformaSimplePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof ProformaSimplePage
     */
    'totalPages': number;
}
/**
 * Proformas statuses.
 * @export
 * @enum {string}
 */

export const ProformaStatuses = {
    Created: 'created',
    SubmittedForPayment: 'submitted_for_payment',
    PartiallyPaid: 'partially_paid',
    Paid: 'paid',
    Deleted: 'deleted'
} as const;

export type ProformaStatuses = typeof ProformaStatuses[keyof typeof ProformaStatuses];


/**
 * Refresh token schema.
 * @export
 * @interface RefreshTokenSchema
 */
export interface RefreshTokenSchema {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenSchema
     */
    'refresh': string;
}
/**
 * Register country schema.
 * @export
 * @interface RegisterCountrySchema
 */
export interface RegisterCountrySchema {
    /**
     * 
     * @type {number}
     * @memberof RegisterCountrySchema
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RegisterCountrySchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterCountrySchema
     */
    'phoneCode': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterCountrySchema
     */
    'flag': string;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterCountrySchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterCountrySchema
     */
    'isEu': boolean;
}
/**
 * Related document list schema.
 * @export
 * @interface RelatedDocumentListSchema
 */
export interface RelatedDocumentListSchema {
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof RelatedDocumentListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {UserTypes}
     * @memberof RelatedDocumentListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof RelatedDocumentListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * Document number.
     * @type {string}
     * @memberof RelatedDocumentListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {number}
     * @memberof RelatedDocumentListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RelatedDocumentListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {AllDocumentTypes}
     * @memberof RelatedDocumentListSchema
     */
    'documentType': AllDocumentTypes;
    /**
     * 
     * @type {SimpleCurrencySchema}
     * @memberof RelatedDocumentListSchema
     */
    'currency': SimpleCurrencySchema;
    /**
     * 
     * @type {number}
     * @memberof RelatedDocumentListSchema
     */
    'sum': number;
    /**
     * 
     * @type {SrcRelatedDocumentsEnumsHistoryLogTypes}
     * @memberof RelatedDocumentListSchema
     */
    'status': SrcRelatedDocumentsEnumsHistoryLogTypes;
    /**
     * 
     * @type {boolean}
     * @memberof RelatedDocumentListSchema
     */
    'isCurrentDocument'?: boolean;
}
/**
 * Related document type choices.
 * @export
 * @enum {string}
 */

export const RelatedDocumentTypes = {
    ClientOrder: 'client_order',
    SupplierOrder: 'supplier_order',
    ClientProforma: 'client_proforma',
    SupplierProforma: 'supplier_proforma',
    ClientInvoice: 'client_invoice',
    SupplierInvoice: 'supplier_invoice',
    ClientProductReturn: 'client_product_return',
    SupplierProductReturn: 'supplier_product_return'
} as const;

export type RelatedDocumentTypes = typeof RelatedDocumentTypes[keyof typeof RelatedDocumentTypes];


/**
 * Enum for requisite languages.
 * @export
 * @enum {string}
 */

export const RequisiteLanguages = {
    Ru: 'ru',
    En: 'en',
    Sl: 'sl',
    Uk: 'uk'
} as const;

export type RequisiteLanguages = typeof RequisiteLanguages[keyof typeof RequisiteLanguages];


/**
 * Enum for requisite types.
 * @export
 * @enum {string}
 */

export const RequisiteQueryType = {
    AutoModern: 'auto_modern',
    Client: 'client',
    Supplier: 'supplier',
    Agent: 'agent'
} as const;

export type RequisiteQueryType = typeof RequisiteQueryType[keyof typeof RequisiteQueryType];


/**
 * 
 * @export
 * @interface ResponseAuthLoginToCrmAuthLoginCrmPost
 */
export interface ResponseAuthLoginToCrmAuthLoginCrmPost {
    /**
     * The user\'s email.
     * @type {string}
     * @memberof ResponseAuthLoginToCrmAuthLoginCrmPost
     */
    'email': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof ResponseAuthLoginToCrmAuthLoginCrmPost
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAuthLoginToCrmAuthLoginCrmPost
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAuthLoginToCrmAuthLoginCrmPost
     */
    'access': string;
}
/**
 * Schema for accounts and cashboxes select page.
 * @export
 * @interface SelectAccountsCashboxesPage
 */
export interface SelectAccountsCashboxesPage {
    /**
     * 
     * @type {Array<AccountCashboxComplexSchema>}
     * @memberof SelectAccountsCashboxesPage
     */
    'items': Array<AccountCashboxComplexSchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectAccountsCashboxesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectAccountsCashboxesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectAccountsCashboxesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectAccountsCashboxesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectAccountsCashboxesPage
     */
    'totalPages': number;
}
/**
 * Brand schema for select list page.
 * @export
 * @interface SelectBrandSchema
 */
export interface SelectBrandSchema {
    /**
     * 
     * @type {number}
     * @memberof SelectBrandSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectBrandSchema
     */
    'name': string;
}
/**
 * Schema for brands select widget page.  Only for endpoint response_model.
 * @export
 * @interface SelectBrandsPage
 */
export interface SelectBrandsPage {
    /**
     * 
     * @type {Array<SelectBrandSchema>}
     * @memberof SelectBrandsPage
     */
    'items': Array<SelectBrandSchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectBrandsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectBrandsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectBrandsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectBrandsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectBrandsPage
     */
    'totalPages': number;
}
/**
 * Schema for countries select widget page.  Only for endpoint response_model.
 * @export
 * @interface SelectCountriesPage
 */
export interface SelectCountriesPage {
    /**
     * 
     * @type {Array<SelectCountryListSchema>}
     * @memberof SelectCountriesPage
     */
    'items': Array<SelectCountryListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectCountriesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectCountriesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectCountriesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectCountriesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectCountriesPage
     */
    'totalPages': number;
}
/**
 * Country schema for tables.
 * @export
 * @interface SelectCountryListSchema
 */
export interface SelectCountryListSchema {
    /**
     * 
     * @type {number}
     * @memberof SelectCountryListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectCountryListSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SelectCountryListSchema
     */
    'nameIso2': string;
    /**
     * 
     * @type {number}
     * @memberof SelectCountryListSchema
     */
    'numericCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof SelectCountryListSchema
     */
    'fullCountryString'?: string;
}
/**
 * Currency for selects schema.
 * @export
 * @interface SelectCurrencySchema
 */
export interface SelectCurrencySchema {
    /**
     * 
     * @type {number}
     * @memberof SelectCurrencySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectCurrencySchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SelectCurrencySchema
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof SelectCurrencySchema
     */
    'rate': number;
    /**
     * 
     * @type {boolean}
     * @memberof SelectCurrencySchema
     */
    'isBase': boolean;
}
/**
 * Base incoterm schema for select.
 * @export
 * @interface SelectIncotermSchema
 */
export interface SelectIncotermSchema {
    /**
     * 
     * @type {number}
     * @memberof SelectIncotermSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectIncotermSchema
     */
    'deliveryTerms': string;
}
/**
 * Schema for incoterms select widget page.
 * @export
 * @interface SelectIncotermsPage
 */
export interface SelectIncotermsPage {
    /**
     * 
     * @type {Array<SelectIncotermSchema>}
     * @memberof SelectIncotermsPage
     */
    'items': Array<SelectIncotermSchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectIncotermsPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectIncotermsPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectIncotermsPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectIncotermsPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectIncotermsPage
     */
    'totalPages': number;
}
/**
 * Select invoices page schema.
 * @export
 * @interface SelectInvoicePage
 */
export interface SelectInvoicePage {
    /**
     * 
     * @type {Array<SelectInvoiceSchema>}
     * @memberof SelectInvoicePage
     */
    'items': Array<SelectInvoiceSchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectInvoicePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectInvoicePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectInvoicePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectInvoicePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectInvoicePage
     */
    'totalPages': number;
}
/**
 * Select invoice schema.
 * @export
 * @interface SelectInvoiceSchema
 */
export interface SelectInvoiceSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SelectInvoiceSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SelectInvoiceSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SelectInvoiceSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SelectInvoiceSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SelectInvoiceSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectInvoiceSchema
     */
    'dateCreated': string;
}
/**
 * Schema for nomenclature categories page for select widget.
 * @export
 * @interface SelectNomenclatureCategoriesPage
 */
export interface SelectNomenclatureCategoriesPage {
    /**
     * 
     * @type {Array<SelectNomenclatureCategorySchema>}
     * @memberof SelectNomenclatureCategoriesPage
     */
    'items': Array<SelectNomenclatureCategorySchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectNomenclatureCategoriesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectNomenclatureCategoriesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectNomenclatureCategoriesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectNomenclatureCategoriesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectNomenclatureCategoriesPage
     */
    'totalPages': number;
}
/**
 * Nomenclature category for select and tables schema.
 * @export
 * @interface SelectNomenclatureCategorySchema
 */
export interface SelectNomenclatureCategorySchema {
    /**
     * 
     * @type {number}
     * @memberof SelectNomenclatureCategorySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectNomenclatureCategorySchema
     */
    'name': string;
}
/**
 * Schema for nomenclature subcategories page for select widget.
 * @export
 * @interface SelectNomenclatureSubcategoriesPage
 */
export interface SelectNomenclatureSubcategoriesPage {
    /**
     * 
     * @type {Array<NomenclatureSubcategorySelectSchema>}
     * @memberof SelectNomenclatureSubcategoriesPage
     */
    'items': Array<NomenclatureSubcategorySelectSchema>;
    /**
     * 
     * @type {number}
     * @memberof SelectNomenclatureSubcategoriesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SelectNomenclatureSubcategoriesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SelectNomenclatureSubcategoriesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SelectNomenclatureSubcategoriesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SelectNomenclatureSubcategoriesPage
     */
    'totalPages': number;
}
/**
 * Service nomenclature update schema for price list.
 * @export
 * @interface ServiceNomenclaturePriceListUpdateSchema
 */
export interface ServiceNomenclaturePriceListUpdateSchema {
    /**
     * Fixed price
     * @type {number}
     * @memberof ServiceNomenclaturePriceListUpdateSchema
     */
    'fixPrice'?: number;
}
/**
 * SignedContractDocument read schema.
 * @export
 * @interface SignedContractDocumentReadSchema
 */
export interface SignedContractDocumentReadSchema {
    /**
     * 
     * @type {number}
     * @memberof SignedContractDocumentReadSchema
     */
    'id': number;
    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof SignedContractDocumentReadSchema
     */
    'language': ContractTemplateLanguage;
    /**
     * 
     * @type {string}
     * @memberof SignedContractDocumentReadSchema
     */
    'fileDocx': string;
    /**
     * 
     * @type {string}
     * @memberof SignedContractDocumentReadSchema
     */
    'filePdf': string;
    /**
     * 
     * @type {string}
     * @memberof SignedContractDocumentReadSchema
     */
    'dateCreated': string;
}
/**
 * Similar name schema.
 * @export
 * @interface SimilarNameSchema
 */
export interface SimilarNameSchema {
    /**
     * 
     * @type {string}
     * @memberof SimilarNameSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimilarNameSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof SimilarNameSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimilarNameSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimilarNameSchema
     */
    'isAgent': boolean;
}
/**
 * Simple agent read schema.
 * @export
 * @interface SimpleAgentReadSchema
 */
export interface SimpleAgentReadSchema {
    /**
     * 
     * @type {string}
     * @memberof SimpleAgentReadSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleAgentReadSchema
     */
    'id': string;
}
/**
 * Simple client invoice additional expense schema.
 * @export
 * @interface SimpleClientInvoiceAdditionalExpenseSchema
 */
export interface SimpleClientInvoiceAdditionalExpenseSchema {
    /**
     * 
     * @type {SupplierInvoiceForAdditionalExpenseSchema}
     * @memberof SimpleClientInvoiceAdditionalExpenseSchema
     */
    'supplierInvoice': SupplierInvoiceForAdditionalExpenseSchema;
}
/**
 * Simple client invoice schema.
 * @export
 * @interface SimpleClientInvoiceSchema
 */
export interface SimpleClientInvoiceSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SimpleClientInvoiceSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SimpleClientInvoiceSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SimpleClientInvoiceSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SimpleClientInvoiceSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SimpleClientInvoiceSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleClientInvoiceSchema
     */
    'dateCreated': string;
}
/**
 * Simple compensation schema.
 * @export
 * @interface SimpleCompensationSchema
 */
export interface SimpleCompensationSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SimpleCompensationSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {number}
     * @memberof SimpleCompensationSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleCompensationSchema
     */
    'dateCreated': string;
}
/**
 * Simple contract schema.
 * @export
 * @interface SimpleContractSchema
 */
export interface SimpleContractSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SimpleContractSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SimpleContractSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SimpleContractSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SimpleContractSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SimpleContractSchema
     */
    'id': number;
    /**
     * 
     * @type {ContractTypes}
     * @memberof SimpleContractSchema
     */
    'type': ContractTypes;
    /**
     * 
     * @type {string}
     * @memberof SimpleContractSchema
     */
    'dateCreated': string;
}
/**
 * Simple currency schema.
 * @export
 * @interface SimpleCurrencySchema
 */
export interface SimpleCurrencySchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleCurrencySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleCurrencySchema
     */
    'code': string;
}
/**
 * Simple financial analysis category schema.
 * @export
 * @interface SimpleFinancialAnalysisCategorySchema
 */
export interface SimpleFinancialAnalysisCategorySchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleFinancialAnalysisCategorySchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleFinancialAnalysisCategorySchema
     */
    'name': string;
}
/**
 * Simple financial analysis item schema.
 * @export
 * @interface SimpleFinancialAnalysisItemSchema
 */
export interface SimpleFinancialAnalysisItemSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleFinancialAnalysisItemSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleFinancialAnalysisItemSchema
     */
    'name': string;
}
/**
 * Simple incoterm schema.
 * @export
 * @interface SimpleIncotermSchema
 */
export interface SimpleIncotermSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleIncotermSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleIncotermSchema
     */
    'deliveryTerms': string;
}
/**
 * Short Message media schema.
 * @export
 * @interface SimpleMessageMediaSchema
 */
export interface SimpleMessageMediaSchema {
    /**
     * 
     * @type {string}
     * @memberof SimpleMessageMediaSchema
     */
    'filename': string;
}
/**
 * Nomenclature prices schema.
 * @export
 * @interface SimpleNomenclaturePriceSchema
 */
export interface SimpleNomenclaturePriceSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleNomenclaturePriceSchema
     */
    'nomenclatureId': number;
    /**
     * 
     * @type {number}
     * @memberof SimpleNomenclaturePriceSchema
     */
    'price'?: number;
}
/**
 * Simple nomenclature schema.
 * @export
 * @interface SimpleNomenclatureSchema
 */
export interface SimpleNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleNomenclatureSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleNomenclatureSchema
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleNomenclatureSchema
     */
    'isProduct': boolean;
}
/**
 * Simple order nomenclature schema.
 * @export
 * @interface SimpleOrderNomenclatureSchema
 */
export interface SimpleOrderNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleOrderNomenclatureSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof SimpleOrderNomenclatureSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof SimpleOrderNomenclatureSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
}
/**
 * PaymentOrder schema.
 * @export
 * @interface SimplePaymentOrderSchema
 */
export interface SimplePaymentOrderSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SimplePaymentOrderSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SimplePaymentOrderSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SimplePaymentOrderSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SimplePaymentOrderSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SimplePaymentOrderSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimplePaymentOrderSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {PaymentOrderDocumentTypes}
     * @memberof SimplePaymentOrderSchema
     */
    'documentType': PaymentOrderDocumentTypes;
}
/**
 * Simple proforma schema.
 * @export
 * @interface SimpleProductReturnSchema
 */
export interface SimpleProductReturnSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleProductReturnSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductReturnSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductReturnSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof SimpleProductReturnSchema
     */
    'status': ProductReturnStatuses;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleProductReturnSchema
     */
    'isEditDateExpired': boolean;
}
/**
 * Simple proforma schema.
 * @export
 * @interface SimpleProformaSchema
 */
export interface SimpleProformaSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleProformaSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProformaSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProformaStatuses}
     * @memberof SimpleProformaSchema
     */
    'status': ProformaStatuses;
    /**
     * 
     * @type {string}
     * @memberof SimpleProformaSchema
     */
    'dateCreated': string;
}
/**
 * Staff page schema.
 * @export
 * @interface SimpleStaffPage
 */
export interface SimpleStaffPage {
    /**
     * 
     * @type {Array<SimpleUserSchema>}
     * @memberof SimpleStaffPage
     */
    'items': Array<SimpleUserSchema>;
    /**
     * 
     * @type {number}
     * @memberof SimpleStaffPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SimpleStaffPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SimpleStaffPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SimpleStaffPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SimpleStaffPage
     */
    'totalPages': number;
}
/**
 * Simple staff read schema.
 * @export
 * @interface SimpleStaffReadSchema
 */
export interface SimpleStaffReadSchema {
    /**
     * 
     * @type {string}
     * @memberof SimpleStaffReadSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleStaffReadSchema
     */
    'name': string;
}
/**
 * Simple supplier invoice additional expense schema.
 * @export
 * @interface SimpleSupplierInvoiceAdditionalExpenseSchema
 */
export interface SimpleSupplierInvoiceAdditionalExpenseSchema {
    /**
     * 
     * @type {SupplierInvoiceForAdditionalExpenseSchema}
     * @memberof SimpleSupplierInvoiceAdditionalExpenseSchema
     */
    'parentInvoice': SupplierInvoiceForAdditionalExpenseSchema;
}
/**
 * Simple supplier invoice schema.
 * @export
 * @interface SimpleSupplierInvoiceSchema
 */
export interface SimpleSupplierInvoiceSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SimpleSupplierInvoiceSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SimpleSupplierInvoiceSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SimpleSupplierInvoiceSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SimpleSupplierInvoiceSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SimpleSupplierInvoiceSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleSupplierInvoiceSchema
     */
    'dateCreated': string;
}
/**
 * Simple User category schema.
 * @export
 * @interface SimpleUserCategoryReadSchema
 */
export interface SimpleUserCategoryReadSchema {
    /**
     * Name
     * @type {string}
     * @memberof SimpleUserCategoryReadSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SimpleUserCategoryReadSchema
     */
    'id': number;
}
/**
 * Simple user currency creates schema.
 * @export
 * @interface SimpleUserCurrencyReadSchema
 */
export interface SimpleUserCurrencyReadSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleUserCurrencyReadSchema
     */
    'id': number;
    /**
     * 
     * @type {BaseCurrencySchema}
     * @memberof SimpleUserCurrencyReadSchema
     */
    'currency': BaseCurrencySchema;
}
/**
 * Supplier simple user schema.
 * @export
 * @interface SimpleUserIsVatSchema
 */
export interface SimpleUserIsVatSchema {
    /**
     * 
     * @type {string}
     * @memberof SimpleUserIsVatSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserIsVatSchema
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof SimpleUserIsVatSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserIsVatSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleUserIsVatSchema
     */
    'isVatPayer': boolean;
}
/**
 * Base user schema.
 * @export
 * @interface SimpleUserSchema
 */
export interface SimpleUserSchema {
    /**
     * 
     * @type {string}
     * @memberof SimpleUserSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserSchema
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof SimpleUserSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserSchema
     */
    'avatar'?: string;
}
/**
 * Simple user schema for proforma.
 * @export
 * @interface SimpleUserSchemaForClientProforma
 */
export interface SimpleUserSchemaForClientProforma {
    /**
     * 
     * @type {string}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {ClientTypes}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'clientType': ClientTypes;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'clientCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'clientAgent'?: SimpleUserSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'isActiveClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {VatRates}
     * @memberof SimpleUserSchemaForClientProforma
     */
    'vatRate': VatRates;
}
/**
 * Base user schema with country.
 * @export
 * @interface SimpleUserWithCountrySchema
 */
export interface SimpleUserWithCountrySchema {
    /**
     * 
     * @type {string}
     * @memberof SimpleUserWithCountrySchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserWithCountrySchema
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof SimpleUserWithCountrySchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserWithCountrySchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof SimpleUserWithCountrySchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleUserWithCountrySchema
     */
    'isSuperuser': boolean;
}
/**
 * Base user schema with vat.
 * @export
 * @interface SimpleUserWithVat
 */
export interface SimpleUserWithVat {
    /**
     * 
     * @type {string}
     * @memberof SimpleUserWithVat
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserWithVat
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof SimpleUserWithVat
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUserWithVat
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleUserWithVat
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {VatRates}
     * @memberof SimpleUserWithVat
     */
    'vatRate': VatRates;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof SimpleUserWithVat
     */
    'country': CountrySimpleReadSchema;
}
/**
 * Simple vendor code schema.
 * @export
 * @interface SimpleVendorCodeSchema
 */
export interface SimpleVendorCodeSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleVendorCodeSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleVendorCodeSchema
     */
    'code': string;
}
/**
 * Warehouse simple schema.
 * @export
 * @interface SimpleWarehouseSchema
 */
export interface SimpleWarehouseSchema {
    /**
     * 
     * @type {number}
     * @memberof SimpleWarehouseSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SimpleWarehouseSchema
     */
    'name': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const SrcHistoryEnumsHistoryLogTypes = {
    AccessCancelled: 'access_cancelled',
    AccountCashboxChanged: 'account_cashbox_changed',
    AdditionalAddressChanged: 'additional_address_changed',
    AdditionalCityChanged: 'additional_city_changed',
    AdditionalExpenseStatusAdded: 'additional_expense_status_added',
    AdditionalExpenseStatusDeleted: 'additional_expense_status_deleted',
    AdditionalRegionChanged: 'additional_region_changed',
    AddressAdded: 'address_added',
    AddressChanged: 'address_changed',
    AddressDeleted: 'address_deleted',
    AgentAdditionalContactAdded: 'agent_additional_contact_added',
    AgentAdditionalContactEmailAdded: 'agent_additional_contact_email_added',
    AgentAdditionalContactPhoneAdded: 'agent_additional_contact_phone_added',
    AgentContactEmailChanged: 'agent_contact_email_changed',
    AgentContactNameChanged: 'agent_contact_name_changed',
    AgentContactPhoneChanged: 'agent_contact_phone_changed',
    AgentContactPositionAdded: 'agent_contact_position_added',
    AgentContactPositionChanged: 'agent_contact_position_changed',
    AgentDeleted: 'agent_deleted',
    AgentReferralCodeChanged: 'agent_referral_code_changed',
    AgentStatusChanged: 'agent_status_changed',
    AnalogAdded: 'analog_added',
    AnalogDeleted: 'analog_deleted',
    AverageMarketPriceAdded: 'average_market_price_added',
    AverageMarketPriceChanged: 'average_market_price_changed',
    AverageMarketPriceDeleted: 'average_market_price_deleted',
    BaseVendorCodeAdded: 'base_vendor_code_added',
    BaseVendorCodeChanged: 'base_vendor_code_changed',
    BaseVendorCodeDeleted: 'base_vendor_code_deleted',
    BaseVendorCodeStatusChanged: 'base_vendor_code_status_changed',
    BrandAdded: 'brand_added',
    BrandChanged: 'brand_changed',
    BrandDeleted: 'brand_deleted',
    CategoryChanged: 'category_changed',
    CityAdded: 'city_added',
    CityChanged: 'city_changed',
    CityDeleted: 'city_deleted',
    ClientAdditionalContactAdded: 'client_additional_contact_added',
    ClientAdditionalContactEmailAdded: 'client_additional_contact_email_added',
    ClientAdditionalContactPhoneAdded: 'client_additional_contact_phone_added',
    ClientAddressAdded: 'client_address_added',
    ClientAddressChanged: 'client_address_changed',
    ClientAgentAdded: 'client_agent_added',
    ClientAgentChanged: 'client_agent_changed',
    ClientCategoryAdded: 'client_category_added',
    ClientCategoryChanged: 'client_category_changed',
    ClientCategoryDeleted: 'client_category_deleted',
    ClientCityAdded: 'client_city_added',
    ClientCityChanged: 'client_city_changed',
    ClientContactEmailChanged: 'client_contact_email_changed',
    ClientContactNameChanged: 'client_contact_name_changed',
    ClientContactPhoneChanged: 'client_contact_phone_changed',
    ClientAdditionalContactPositionAdded: 'client_additional_contact_position_added',
    ClientContactPositionChanged: 'client_contact_position_changed',
    ClientCounterAgentKindChanged: 'client_counter_agent_kind_changed',
    ClientCountryChanged: 'client_country_changed',
    ClientCreditDepthAdded: 'client_credit_depth_added',
    ClientCreditDepthChanged: 'client_credit_depth_changed',
    ClientCreditDepthDeleted: 'client_credit_depth_deleted',
    ClientCreditLimitChanged: 'client_credit_limit_changed',
    ClientCreditLimitSumAdded: 'client_credit_limit_sum_added',
    ClientCreditLimitSumChanged: 'client_credit_limit_sum_changed',
    ClientCreditLimitSumDeleted: 'client_credit_limit_sum_deleted',
    ClientCurrencyAdded: 'client_currency_added',
    ClientDeliveryMethodAdded: 'client_delivery_method_added',
    ClientDeliveryMethodAddressAdded: 'client_delivery_method_address_added',
    ClientDeliveryMethodAddressChanged: 'client_delivery_method_address_changed',
    ClientDeliveryMethodChanged: 'client_delivery_method_changed',
    ClientDeliveryMethodCityAdded: 'client_delivery_method_city_added',
    ClientDeliveryMethodCityChanged: 'client_delivery_method_city_changed',
    ClientDeliveryMethodDepartmentChanged: 'client_delivery_method_department_changed',
    ClientDeliveryMethodDepartmentNumberAdded: 'client_delivery_method_department_number_added',
    ClientDocumentLanguageChanged: 'client_document_language_changed',
    ClientKindChanged: 'client_kind_changed',
    ClientManagerChanged: 'client_manager_changed',
    ClientNameChanged: 'client_name_changed',
    ClientPriceCategoryChanged: 'client_price_category_changed',
    ClientPriceTypeChanged: 'client_price_type_changed',
    ClientRegionAdded: 'client_region_added',
    ClientRegionChanged: 'client_region_changed',
    ClientRegistrationNumberAdded: 'client_registration_number_added',
    ClientRegistrationNumberChanged: 'client_registration_number_changed',
    ClientRegistrationNumberDeleted: 'client_registration_number_deleted',
    ClientSiteAdded: 'client_site_added',
    ClientSiteChanged: 'client_site_changed',
    ClientSiteDeleted: 'client_site_deleted',
    ClientSourceAdded: 'client_source_added',
    ClientSourceChanged: 'client_source_changed',
    ClientStatusChanged: 'client_status_changed',
    ClientTypeChanged: 'client_type_changed',
    ClientVatNumberAdded: 'client_vat_number_added',
    ClientVatNumberChanged: 'client_vat_number_changed',
    ClientVatNumberDeleted: 'client_vat_number_deleted',
    ClientVatPayerStatusChanged: 'client_vat_payer_status_changed',
    CompanyRequisiteChanged: 'company_requisite_changed',
    CompanyRequisiteDeleted: 'company_requisite_deleted',
    ContactPersonChanged: 'contact_person_changed',
    ContactPersonDeleted: 'contact_person_deleted',
    ContactPersonEmailChanged: 'contact_person_email_changed',
    ContactPersonEmailDeleted: 'contact_person_email_deleted',
    ContactPersonPhoneChanged: 'contact_person_phone_changed',
    ContactPersonPhoneDeleted: 'contact_person_phone_deleted',
    ContactPersonPositionChanged: 'contact_person_position_changed',
    ContactPersonPositionDeleted: 'contact_person_position_deleted',
    ContactPersonWebsiteChanged: 'contact_person_website_changed',
    ContactPersonWebsiteDeleted: 'contact_person_website_deleted',
    ContractAccountCashboxAdded: 'contract_account_cashbox_added',
    ContractAccountCashboxDeleted: 'contract_account_cashbox_deleted',
    ContractAdded: 'contract_added',
    ContractChanged: 'contract_changed',
    ContractCurrencyChanged: 'contract_currency_changed',
    ContractDateEndChanged: 'contract_date_end_changed',
    ContractDateStartChanged: 'contract_date_start_changed',
    ContractDeleted: 'contract_deleted',
    ContractDocumentAdded: 'contract_document_added',
    ContractNumberChanged: 'contract_number_changed',
    ContractStatusChanged: 'contract_status_changed',
    ContractSupplierDateAdded: 'contract_supplier_date_added',
    ContractSupplierDateChanged: 'contract_supplier_date_changed',
    ContractSupplierDateDeleted: 'contract_supplier_date_deleted',
    ContractSupplierDocumentNumberAdded: 'contract_supplier_document_number_added',
    ContractSupplierDocumentNumberChanged: 'contract_supplier_document_number_changed',
    ContractSupplierDocumentNumberDeleted: 'contract_supplier_document_number_deleted',
    CostPriceChanged: 'cost_price_changed',
    CounterAgentKindChanged: 'counter_agent_kind_changed',
    CountryAdded: 'country_added',
    CountryChanged: 'country_changed',
    CountryDeleted: 'country_deleted',
    CreditDepthAdded: 'credit_depth_added',
    CreditDepthChanged: 'credit_depth_changed',
    CreditDepthDeleted: 'credit_depth_deleted',
    CreditLimitAmountDeleted: 'credit_limit_amount_deleted',
    CreditLimitChanged: 'credit_limit_changed',
    CreditLimitDaysDeleted: 'credit_limit_days_deleted',
    CreditLimitDeleted: 'credit_limit_deleted',
    CreditLimitSumAdded: 'credit_limit_sum_added',
    CreditLimitSumChanged: 'credit_limit_sum_changed',
    CreditLimitSumDeleted: 'credit_limit_sum_deleted',
    CurrencyAdded: 'currency_added',
    CurrencyDeleted: 'currency_deleted',
    CurrencyRateChanged: 'currency_rate_changed',
    CustomsCodeAdded: 'customs_code_added',
    CustomsCodeChanged: 'customs_code_changed',
    CustomsCodeDeleted: 'customs_code_deleted',
    DatePaymentAdded: 'date_payment_added',
    DatePaymentChanged: 'date_payment_changed',
    DeliveryAddressAdded: 'delivery_address_added',
    DeliveryAddressChanged: 'delivery_address_changed',
    DeliveryAddressDeleted: 'delivery_address_deleted',
    DeliveryCityDeleted: 'delivery_city_deleted',
    DeliveryDateAdded: 'delivery_date_added',
    DeliveryDateChanged: 'delivery_date_changed',
    DeliveryDateDeleted: 'delivery_date_deleted',
    DeliveryDepartmentDeleted: 'delivery_department_deleted',
    DeliveryMethodAddressChanged: 'delivery_method_address_changed',
    DeliveryMethodAddressDeleted: 'delivery_method_address_deleted',
    DeliveryMethodChanged: 'delivery_method_changed',
    DeliveryMethodCityChanged: 'delivery_method_city_changed',
    DeliveryMethodCityDeleted: 'delivery_method_city_deleted',
    DeliveryMethodDeleted: 'delivery_method_deleted',
    DeliveryMethodOfficeChanged: 'delivery_method_office_changed',
    DeliveryMethodOfficeDeleted: 'delivery_method_office_deleted',
    DeliveryStatusAdded: 'delivery_status_added',
    DeliveryStatusChanged: 'delivery_status_changed',
    DeliveryStatusDeleted: 'delivery_status_deleted',
    DeliveryTypeAdded: 'delivery_type_added',
    DeliveryTypeChanged: 'delivery_type_changed',
    DeliveryTypeDeleted: 'delivery_type_deleted',
    DiscountMarkupAdded: 'discount_markup_added',
    DiscountMarkupDeleted: 'discount_markup_deleted',
    DiscountMarkupTypeChanged: 'discount_markup_type_changed',
    DiscountMarkupValueChanged: 'discount_markup_value_changed',
    DocumentCreated: 'document_created',
    DocumentDeleted: 'document_deleted',
    DocumentLanguageChanged: 'document_language_changed',
    DocumentNumberChanged: 'document_number_changed',
    EmailAsLoginChanged: 'email_as_login_changed',
    EmailChanged: 'email_changed',
    EmailDeleted: 'email_deleted',
    ExpenseAdded: 'expense_added',
    ExpenseDeleted: 'expense_deleted',
    FixedPriceAdded: 'fixed_price_added',
    FixedPriceChanged: 'fixed_price_changed',
    FixedPriceDeleted: 'fixed_price_deleted',
    FixPriceForPriceCategoryAdded: 'fix_price_for_price_category_added',
    FixPriceForPriceCategoryChanged: 'fix_price_for_price_category_changed',
    HeightAdded: 'height_added',
    HeightChanged: 'height_changed',
    HeightDeleted: 'height_deleted',
    IncomeAdded: 'income_added',
    IncomeDeleted: 'income_deleted',
    IncotermAdded: 'incoterm_added',
    IncotermAddressAdded: 'incoterm_address_added',
    IncotermAddressChanged: 'incoterm_address_changed',
    IncotermAddressDeleted: 'incoterm_address_deleted',
    IncotermChanged: 'incoterm_changed',
    IncotermDeleted: 'incoterm_deleted',
    IsShowChanged: 'is_show_changed',
    IsSkippedSloveniaAdded: 'is_skipped_slovenia_added',
    IsSkippedSloveniaDeleted: 'is_skipped_slovenia_deleted',
    LengthAdded: 'length_added',
    LengthChanged: 'length_changed',
    LengthDeleted: 'length_deleted',
    MainAddressChanged: 'main_address_changed',
    MainCityChanged: 'main_city_changed',
    MainRegionChanged: 'main_region_changed',
    ManagerChanged: 'manager_changed',
    MarkupForPriceCategoryAdded: 'markup_for_price_category_added',
    MarkupForPriceCategoryChanged: 'markup_for_price_category_changed',
    MinOrderQuantityChanged: 'min_order_quantity_changed',
    MovementAdded: 'movement_added',
    MovementDeleted: 'movement_deleted',
    NameChanged: 'name_changed',
    NameEnChanged: 'name_en_changed',
    NameRuChanged: 'name_ru_changed',
    NameSlChanged: 'name_sl_changed',
    NomenclatureAdded: 'nomenclature_added',
    NomenclatureDeleted: 'nomenclature_deleted',
    NomenclatureDeliveryDateAdded: 'nomenclature_delivery_date_added',
    NomenclatureDeliveryDateChanged: 'nomenclature_delivery_date_changed',
    NomenclatureDeliveryDateDeleted: 'nomenclature_delivery_date_deleted',
    NomenclaturePriceAdded: 'nomenclature_price_added',
    NomenclaturePriceChanged: 'nomenclature_price_changed',
    NomenclaturePriceDeleted: 'nomenclature_price_deleted',
    NomenclatureQuantityChanged: 'nomenclature_quantity_changed',
    NomenclatureReserveAdded: 'nomenclature_reserve_added',
    NomenclatureReserveChanged: 'nomenclature_reserve_changed',
    NomenclatureReserveDeleted: 'nomenclature_reserve_deleted',
    NomenclatureVendorCodeChanged: 'nomenclature_vendor_code_changed',
    OrganizationSiteChanged: 'organization_site_changed',
    OrganizationSiteDeleted: 'organization_site_deleted',
    PermissionAdded: 'permission_added',
    PermissionRemoved: 'permission_removed',
    PersonalEmailAdded: 'personal_email_added',
    PersonalEmailChanged: 'personal_email_changed',
    PersonalEmailDeleted: 'personal_email_deleted',
    PersonalPhoneAdded: 'personal_phone_added',
    PersonalPhoneChanged: 'personal_phone_changed',
    PersonalPhoneDeleted: 'personal_phone_deleted',
    PhoneChanged: 'phone_changed',
    PhoneDeleted: 'phone_deleted',
    PositionChanged: 'position_changed',
    PriceCategoryAdded: 'price_category_added',
    PriceCategoryStatusChanged: 'price_category_status_changed',
    PriceCategoryTypeChanged: 'price_category_type_changed',
    PriceListCostAdded: 'price_list_cost_added',
    PriceListCostChanged: 'price_list_cost_changed',
    PriceTypeChanged: 'price_type_changed',
    ReceivingWarehouseChanged: 'receiving_warehouse_changed',
    RegionAdded: 'region_added',
    RegionChanged: 'region_changed',
    RegionDeleted: 'region_deleted',
    RegistrationNumberAdded: 'registration_number_added',
    RegistrationNumberChanged: 'registration_number_changed',
    RegistrationNumberDeleted: 'registration_number_deleted',
    RelatedNomenclatureAdded: 'related_nomenclature_added',
    RelatedNomenclatureDeleted: 'related_nomenclature_deleted',
    RequisiteChanged: 'requisite_changed',
    ResponsibleChanged: 'responsible_changed',
    SendingWarehouseChanged: 'sending_warehouse_changed',
    SiteAdded: 'site_added',
    SiteChanged: 'site_changed',
    SiteDeleted: 'site_deleted',
    SourceDeleted: 'source_deleted',
    StatusChanged: 'status_changed',
    SubcategoryChanged: 'subcategory_changed',
    SupplierAdditionalContactAdded: 'supplier_additional_contact_added',
    SupplierAdditionalContactEmailAdded: 'supplier_additional_contact_email_added',
    SupplierAdditionalContactPhoneAdded: 'supplier_additional_contact_phone_added',
    SupplierAddressAdded: 'supplier_address_added',
    SupplierBankAccountChanged: 'supplier_bank_account_changed',
    SupplierBankAccountDeleted: 'supplier_bank_account_deleted',
    SupplierCategoryAdded: 'supplier_category_added',
    SupplierCategoryChanged: 'supplier_category_changed',
    SupplierCategoryDeleted: 'supplier_category_deleted',
    SupplierCityAdded: 'supplier_city_added',
    SupplierContactEmailChanged: 'supplier_contact_email_changed',
    SupplierContactNameChanged: 'supplier_contact_name_changed',
    SupplierContactPhoneChanged: 'supplier_contact_phone_changed',
    SupplierContactPositionAdded: 'supplier_contact_position_added',
    SupplierContactPositionChanged: 'supplier_contact_position_changed',
    SupplierCounterAgentKindChanged: 'supplier_counter_agent_kind_changed',
    SupplierCreditDepthAdded: 'supplier_credit_depth_added',
    SupplierCreditLimitSumAdded: 'supplier_credit_limit_sum_added',
    SupplierCurrencyAdded: 'supplier_currency_added',
    SupplierDocumentDateAdded: 'supplier_document_date_added',
    SupplierDocumentDateChanged: 'supplier_document_date_changed',
    SupplierDocumentDateDeleted: 'supplier_document_date_deleted',
    SupplierDocumentNumberAdded: 'supplier_document_number_added',
    SupplierDocumentNumberChanged: 'supplier_document_number_changed',
    SupplierDocumentNumberDeleted: 'supplier_document_number_deleted',
    SupplierManagerChanged: 'supplier_manager_changed',
    SupplierRegionAdded: 'supplier_region_added',
    SupplierRegistrationNumberAdded: 'supplier_registration_number_added',
    SupplierRegistrationNumberChanged: 'supplier_registration_number_changed',
    SupplierSiteAdded: 'supplier_site_added',
    SupplierStatusChanged: 'supplier_status_changed',
    SupplierVatNumberAdded: 'supplier_vat_number_added',
    UnitChanged: 'unit_changed',
    VatNumberAdded: 'vat_number_added',
    VatNumberChanged: 'vat_number_changed',
    VatNumberDeleted: 'vat_number_deleted',
    VatPayerStatusChanged: 'vat_payer_status_changed',
    VendorCodeAdded: 'vendor_code_added',
    VendorCodeChanged: 'vendor_code_changed',
    VendorCodeDeleted: 'vendor_code_deleted',
    VendorCodeStatusChanged: 'vendor_code_status_changed',
    WarehouseChanged: 'warehouse_changed',
    WeightAdded: 'weight_added',
    WeightChanged: 'weight_changed',
    WeightDeleted: 'weight_deleted',
    WidthAdded: 'width_added',
    WidthChanged: 'width_changed',
    WidthDeleted: 'width_deleted'
} as const;

export type SrcHistoryEnumsHistoryLogTypes = typeof SrcHistoryEnumsHistoryLogTypes[keyof typeof SrcHistoryEnumsHistoryLogTypes];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const SrcRelatedDocumentsEnumsHistoryLogTypes = {
    Cancelled: 'cancelled',
    Completed: 'completed',
    Conducted: 'conducted',
    Created: 'created',
    Deleted: 'deleted',
    InProcessing: 'in_processing',
    InProgress: 'in_progress',
    Paid: 'paid',
    PartiallyPaid: 'partially_paid',
    SubmittedForPayment: 'submitted_for_payment',
    Ordering: 'ordering'
} as const;

export type SrcRelatedDocumentsEnumsHistoryLogTypes = typeof SrcRelatedDocumentsEnumsHistoryLogTypes[keyof typeof SrcRelatedDocumentsEnumsHistoryLogTypes];


/**
 * Create staff schema.
 * @export
 * @interface StaffCreateSchema
 */
export interface StaffCreateSchema {
    /**
     * Staff email. Not used for login
     * @type {string}
     * @memberof StaffCreateSchema
     */
    'staffEmail'?: string;
    /**
     * Email
     * @type {string}
     * @memberof StaffCreateSchema
     */
    'email': string;
    /**
     * Staff phone number. Not used for login
     * @type {string}
     * @memberof StaffCreateSchema
     */
    'staffPhone'?: string;
    /**
     * Name
     * @type {string}
     * @memberof StaffCreateSchema
     */
    'name': string;
    /**
     * 
     * @type {Mainlocation}
     * @memberof StaffCreateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * Country id
     * @type {number}
     * @memberof StaffCreateSchema
     */
    'countryId': number;
    /**
     * Position id
     * @type {number}
     * @memberof StaffCreateSchema
     */
    'positionId': number;
}
/**
 * Staff Menu Sticker Schema for CRM.
 * @export
 * @interface StaffCrmMenuStickerSchema
 */
export interface StaffCrmMenuStickerSchema {
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalClientOrders': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalClientProformas': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalClientInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalClientProductReturns': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalClients': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalCompensations': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalClientContracts': number;
    /**
     * 
     * @type {number}
     * @memberof StaffCrmMenuStickerSchema
     */
    'totalAgents': number;
}
/**
 * Staff Menu Sticker Schema for Finances.
 * @export
 * @interface StaffFinancesMenuStickerSchema
 */
export interface StaffFinancesMenuStickerSchema {
    /**
     * 
     * @type {number}
     * @memberof StaffFinancesMenuStickerSchema
     */
    'totalPaymentOrders': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFinancesMenuStickerSchema
     */
    'totalCashOrders': number;
}
/**
 * Staff full info schema.
 * @export
 * @interface StaffFullInfoSchema
 */
export interface StaffFullInfoSchema {
    /**
     * Staff email. Not used for login
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'staffEmail'?: string;
    /**
     * Email
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'email': string;
    /**
     * Staff phone number. Not used for login
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'staffPhone'?: string;
    /**
     * Name
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'name': string;
    /**
     * 
     * @type {Mainlocation}
     * @memberof StaffFullInfoSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'id': string;
    /**
     * 
     * @type {StaffStatuses}
     * @memberof StaffFullInfoSchema
     */
    'staffStatus': StaffStatuses;
    /**
     * 
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'dateCreated': string;
    /**
     * Avatar
     * @type {string}
     * @memberof StaffFullInfoSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StaffFullInfoSchema
     */
    'isSuperuser': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffFullInfoSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {PositionSimpleSchema}
     * @memberof StaffFullInfoSchema
     */
    'position': PositionSimpleSchema;
    /**
     * 
     * @type {CountrySchema}
     * @memberof StaffFullInfoSchema
     */
    'country': CountrySchema;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'clientsCount': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'ordersCount': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'proformasCount': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'invoicesCount': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'returnsCount': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'notesCount': number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'myNotesCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof StaffFullInfoSchema
     */
    'chatMessagesCount': number;
}
/**
 * Staff list schema.
 * @export
 * @interface StaffListSchema
 */
export interface StaffListSchema {
    /**
     * Staff email. Not used for login
     * @type {string}
     * @memberof StaffListSchema
     */
    'staffEmail'?: string;
    /**
     * Email
     * @type {string}
     * @memberof StaffListSchema
     */
    'email': string;
    /**
     * Staff phone number. Not used for login
     * @type {string}
     * @memberof StaffListSchema
     */
    'staffPhone'?: string;
    /**
     * Name
     * @type {string}
     * @memberof StaffListSchema
     */
    'name': string;
    /**
     * 
     * @type {Mainlocation}
     * @memberof StaffListSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {string}
     * @memberof StaffListSchema
     */
    'id': string;
    /**
     * 
     * @type {StaffStatuses}
     * @memberof StaffListSchema
     */
    'staffStatus': StaffStatuses;
    /**
     * 
     * @type {string}
     * @memberof StaffListSchema
     */
    'dateCreated': string;
    /**
     * Avatar
     * @type {string}
     * @memberof StaffListSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StaffListSchema
     */
    'isSuperuser': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {PositionSimpleSchema}
     * @memberof StaffListSchema
     */
    'position': PositionSimpleSchema;
    /**
     * 
     * @type {CountrySchema}
     * @memberof StaffListSchema
     */
    'country': CountrySchema;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof StaffListSchema
     */
    'labelList'?: Array<LabelListSchema>;
}
/**
 * Staff page schema.
 * @export
 * @interface StaffPage
 */
export interface StaffPage {
    /**
     * 
     * @type {Array<StaffListSchema>}
     * @memberof StaffPage
     */
    'items': Array<StaffListSchema>;
    /**
     * 
     * @type {number}
     * @memberof StaffPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof StaffPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof StaffPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof StaffPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof StaffPage
     */
    'totalPages': number;
}
/**
 * Staff permissions schema.
 * @export
 * @interface StaffPermissionsSchema
 */
export interface StaffPermissionsSchema {
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmWarehouseViewCompensation': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmWarehouseChangeCompensation': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmWarehousePostCompensation': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmWarehouseCancelCompensation': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmWarehouseChangeCurrencyCreditLimits': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeCurrencyRate': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangePriceType': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClients': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeClients': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClientNomenclatureCost': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewOtherManagerClientAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeOtherManagerClientAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewOtherManagerClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeOtherManagerClientOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewOtherManagerClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeOtherManagerClientProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewOtherManagerClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeOtherManagerClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostOtherManagerClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelOtherManagerClientInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewOtherManagerClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeOtherManagerClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostOtherManagerClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelOtherManagerClientReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewOtherManagerClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeOtherManagerClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostOtherManagerClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelOtherManagerClientContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewAgentAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeAgentAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewAgentCommission': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeAgentCommission': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmViewAgentContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmChangeAgentContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmPostAgentContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'crmCancelAgentContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeCurrency': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewSuppliers': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeSuppliers': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewSupplierOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeSupplierOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewSupplierProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeSupplierProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewOtherManagerSupplierAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeOtherManagerSupplierAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewOtherManagerSupplierOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeOtherManagerSupplierOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewOtherManagerSupplierProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeOtherManagerSupplierProforma': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewOtherManagerSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeOtherManagerSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostOtherManagerSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelOtherManagerSupplierInvoice': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewOtherManagerSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeOtherManagerSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostOtherManagerSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelOtherManagerSupplierReturns': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewOtherManagerSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeOtherManagerSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostOtherManagerSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelOtherManagerSupplierContract': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewWarehouse': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseViewWarehouseMovements': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeWarehouseMovements': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehousePostWarehouseMovements': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseCancelWarehouseMovements': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeNomenclatureAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseChangeNomenclaturePriceAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeViewIncomingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeChangeIncomingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financePostIncomingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeCancelIncomingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeViewOutgoingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeChangeOutgoingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financePostOutgoingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeCancelOutgoingPaymentOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeViewIncomingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeChangeIncomingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financePostIncomingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeCancelIncomingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeViewOutgoingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeChangeOutgoingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financePostOutgoingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financeCancelOutgoingCashOrder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'staffView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'staffChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'currencyInSettingsView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'currencyInSettingsChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'nomenclatureCategoryView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'nomenclatureCategoryChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'brandView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'brandChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'clientCategoryView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'clientCategoryChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'supplierCategoryView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'supplierCategoryChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'clientSourceView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'clientSourceChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'priceCategoryView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'priceCategoryChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'accountCashboxView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'accountCashboxChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'vatRateView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'vatRateChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'markupManagerView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'markupManagerChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financialAnalysisItemView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financialAnalysisItemChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financialAnalysisCategoryView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'financialAnalysisCategoryChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'positionView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'positionChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseInSettingsView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'warehouseInSettingsChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'cancellationReasonGroupView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'cancellationReasonGroupChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'countryView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'countryChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'autoModernRequisiteView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'autoModernRequisiteChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'incotermView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'incotermChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'supportEmailView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'supportEmailChange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'autoDistributionClientsView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'showAsPersonalManagerView': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffPermissionsSchema
     */
    'reportsCanView': boolean;
}
/**
 * User profile schema.
 * @export
 * @interface StaffProfileSchema
 */
export interface StaffProfileSchema {
    /**
     * 
     * @type {string}
     * @memberof StaffProfileSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StaffProfileSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StaffProfileSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof StaffProfileSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {PositionSimpleSchema}
     * @memberof StaffProfileSchema
     */
    'position': PositionSimpleSchema;
    /**
     * 
     * @type {StaffPermissionsSchema}
     * @memberof StaffProfileSchema
     */
    'permissions': StaffPermissionsSchema;
}
/**
 * Staff query order choices.
 * @export
 * @enum {string}
 */

export const StaffQueryOrder = {
    DateCreated: 'dateCreated'
} as const;

export type StaffQueryOrder = typeof StaffQueryOrder[keyof typeof StaffQueryOrder];


/**
 * StaffSchema schema.
 * @export
 * @interface StaffSchema
 */
export interface StaffSchema {
    /**
     * Staff email. Not used for login
     * @type {string}
     * @memberof StaffSchema
     */
    'staffEmail'?: string;
    /**
     * Email
     * @type {string}
     * @memberof StaffSchema
     */
    'email': string;
    /**
     * Staff phone number. Not used for login
     * @type {string}
     * @memberof StaffSchema
     */
    'staffPhone'?: string;
    /**
     * Name
     * @type {string}
     * @memberof StaffSchema
     */
    'name': string;
    /**
     * 
     * @type {Mainlocation}
     * @memberof StaffSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {string}
     * @memberof StaffSchema
     */
    'id': string;
    /**
     * 
     * @type {StaffStatuses}
     * @memberof StaffSchema
     */
    'staffStatus': StaffStatuses;
    /**
     * 
     * @type {string}
     * @memberof StaffSchema
     */
    'dateCreated': string;
    /**
     * Avatar
     * @type {string}
     * @memberof StaffSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StaffSchema
     */
    'isSuperuser': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StaffSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {PositionSimpleSchema}
     * @memberof StaffSchema
     */
    'position': PositionSimpleSchema;
    /**
     * 
     * @type {CountrySchema}
     * @memberof StaffSchema
     */
    'country': CountrySchema;
}
/**
 * Staff statuses choices.
 * @export
 * @enum {string}
 */

export const StaffStatuses = {
    InProcessing: 'in_processing',
    Active: 'active',
    Inactive: 'inactive',
    Fired: 'fired'
} as const;

export type StaffStatuses = typeof StaffStatuses[keyof typeof StaffStatuses];


/**
 * Staff activate schema.
 * @export
 * @interface StaffUpdateEmailSchema
 */
export interface StaffUpdateEmailSchema {
    /**
     * Email
     * @type {string}
     * @memberof StaffUpdateEmailSchema
     */
    'email': string;
}
/**
 * Update staff schema.
 * @export
 * @interface StaffUpdateSchema
 */
export interface StaffUpdateSchema {
    /**
     * Staff email. Not used for login
     * @type {string}
     * @memberof StaffUpdateSchema
     */
    'staffEmail'?: string;
    /**
     * Email
     * @type {string}
     * @memberof StaffUpdateSchema
     */
    'email': string;
    /**
     * Staff phone number. Not used for login
     * @type {string}
     * @memberof StaffUpdateSchema
     */
    'staffPhone'?: string;
    /**
     * Name
     * @type {string}
     * @memberof StaffUpdateSchema
     */
    'name': string;
    /**
     * 
     * @type {Mainlocation}
     * @memberof StaffUpdateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * Country id
     * @type {number}
     * @memberof StaffUpdateSchema
     */
    'countryId': number;
    /**
     * Position id
     * @type {number}
     * @memberof StaffUpdateSchema
     */
    'positionId': number;
}
/**
 * Staff Menu Sticker Schema for Warehouse.
 * @export
 * @interface StaffWarehouseMenuStickerSchema
 */
export interface StaffWarehouseMenuStickerSchema {
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalSuppliers': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalSupplierOrders': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalSupplierProformas': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalSupplierInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalSupplierProductReturns': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalCompensations': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalSupplierContracts': number;
    /**
     * 
     * @type {number}
     * @memberof StaffWarehouseMenuStickerSchema
     */
    'totalProductMovements': number;
}
/**
 * StartPriceListTask schema.
 * @export
 * @interface StartPriceListTaskSchema
 */
export interface StartPriceListTaskSchema {
    /**
     * 
     * @type {number}
     * @memberof StartPriceListTaskSchema
     */
    'vendorCodeCellId': number;
    /**
     * 
     * @type {number}
     * @memberof StartPriceListTaskSchema
     */
    'costCellId': number;
    /**
     * 
     * @type {number}
     * @memberof StartPriceListTaskSchema
     */
    'currencyCellId': number;
    /**
     * 
     * @type {number}
     * @memberof StartPriceListTaskSchema
     */
    'stockCellId': number;
}
/**
 * Supplier additional invoice create schema.
 * @export
 * @interface SupplierAdditionalInvoiceCreateSchema
 */
export interface SupplierAdditionalInvoiceCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'comment'?: string;
    /**
     * Supplier ID for supplier order
     * @type {string}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'userId': string;
    /**
     * Price category ID. Only active categories or categories.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'priceCategoryId': number;
    /**
     * User currency ID. Only active client/supplier currencies.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'userCurrencyId': number;
    /**
     * Currency rate. Only \'1\' for EUR currency
     * @type {number}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'rate': number;
    /**
     * Client ID for client contract. Supplier ID - supplier contract.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'contractId'?: number;
    /**
     * 
     * @type {Array<SupplierInvoiceAdditionalNomenclatureCreateSchema>}
     * @memberof SupplierAdditionalInvoiceCreateSchema
     */
    'invoiceNomenclatures': Array<SupplierInvoiceAdditionalNomenclatureCreateSchema>;
}
/**
 * Supplier additional invoice detail schema.
 * @export
 * @interface SupplierAdditionalInvoiceDetailSchema
 */
export interface SupplierAdditionalInvoiceDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'datePayment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'isOverduePayment'?: boolean;
    /**
     * Check if request user has conduct permission.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasConductPermission'?: boolean;
    /**
     * Check if request user has cancel permission.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasCancelPermission'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasOverdueInvoices'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'isSufficientFunds'?: boolean;
    /**
     * Check if invoice has conducted supplier invoices with additional expenses.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasConductedSupplierInvoices': boolean;
    /**
     * If invoice has created or conducted returns.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasRelatedReturns': boolean;
    /**
     * Check if invoice has created return.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasCreatedReturn': boolean;
    /**
     * Check if invoice has conducted returns.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasConductedReturns': boolean;
    /**
     * Check if invoice has related payment orders.
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasRelatedPayments'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'canConduct'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'canCancel'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'canCreateReturn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {SupplierOrderDetailSchemaForSupplierInvoice}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'order': SupplierOrderDetailSchemaForSupplierInvoice;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'warehouse'?: SimpleWarehouseSchema;
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureDetailSchema>}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'invoiceNomenclatures': Array<SupplierInvoiceNomenclatureDetailSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'hasEnoughNomenclaturesForCancel'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'allocatedSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'remainingSum'?: number;
    /**
     * 
     * @type {Array<SupplierInvoiceAdditionalExpenseSchema>}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'supplierExpenses': Array<SupplierInvoiceAdditionalExpenseSchema>;
    /**
     * 
     * @type {Array<ClientInvoiceAdditionalExpenseSchema>}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'clientExpenses': Array<ClientInvoiceAdditionalExpenseSchema>;
    /**
     * 
     * @type {Array<FinItemAdditionalExpenseSchema>}
     * @memberof SupplierAdditionalInvoiceDetailSchema
     */
    'finExpenses': Array<FinItemAdditionalExpenseSchema>;
}
/**
 * Supplier additional invoice change schema.
 * @export
 * @interface SupplierAdditionalInvoiceUpdateSchema
 */
export interface SupplierAdditionalInvoiceUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'comment'?: string;
    /**
     * Invoice status
     * @type {InvoiceUpdateStatuses}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'status': InvoiceUpdateStatuses;
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureUpdateSchema>}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'invoiceNomenclatures': Array<SupplierInvoiceNomenclatureUpdateSchema>;
    /**
     * 
     * @type {Array<SupplierInvoiceAdditionalExpenseChangeSchema>}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'supplierExpenses'?: Array<SupplierInvoiceAdditionalExpenseChangeSchema>;
    /**
     * 
     * @type {Array<ClientInvoiceAdditionalExpenseChangeSchema>}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'clientExpenses'?: Array<ClientInvoiceAdditionalExpenseChangeSchema>;
    /**
     * 
     * @type {Array<FinItemAdditionalExpenseChangeSchema>}
     * @memberof SupplierAdditionalInvoiceUpdateSchema
     */
    'finExpenses'?: Array<FinItemAdditionalExpenseChangeSchema>;
}
/**
 * SupplierContractCreateSchema schema.
 * @export
 * @interface SupplierContractCreateSchema
 */
export interface SupplierContractCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'dateStart': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'dateEnd': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof SupplierContractCreateSchema
     */
    'accountCashboxIds': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof SupplierContractCreateSchema
     */
    'userCurrencyId': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierContractCreateSchema
     */
    'incotermId'?: number;
    /**
     * Prepayment percent. Used only for equipment contract type.
     * @type {number}
     * @memberof SupplierContractCreateSchema
     */
    'prepaymentPercent'?: number;
    /**
     * Transport mode. Used only for equipment contract type.
     * @type {ContractTransportModes}
     * @memberof SupplierContractCreateSchema
     */
    'transportMode'?: ContractTransportModes;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierContractCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierContractCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'userId': string;
    /**
     * 
     * @type {ContractTypes}
     * @memberof SupplierContractCreateSchema
     */
    'type': ContractTypes;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractCreateSchema
     */
    'supplierDocumentDate'?: string;
}
/**
 * SupplierContractUpdateSchema schema.
 * @export
 * @interface SupplierContractUpdateSchema
 */
export interface SupplierContractUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'dateStart': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'dateEnd': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof SupplierContractUpdateSchema
     */
    'accountCashboxIds': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof SupplierContractUpdateSchema
     */
    'userCurrencyId': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierContractUpdateSchema
     */
    'incotermId'?: number;
    /**
     * Prepayment percent. Used only for equipment contract type.
     * @type {number}
     * @memberof SupplierContractUpdateSchema
     */
    'prepaymentPercent'?: number;
    /**
     * Transport mode. Used only for equipment contract type.
     * @type {ContractTransportModes}
     * @memberof SupplierContractUpdateSchema
     */
    'transportMode'?: ContractTransportModes;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierContractUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof SupplierContractUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierContractUpdateSchema
     */
    'supplierDocumentDate'?: string;
}
/**
 * Create Supplier schema.
 * @export
 * @interface SupplierCreateSchema
 */
export interface SupplierCreateSchema {
    /**
     * Name
     * @type {string}
     * @memberof SupplierCreateSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof SupplierCreateSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof SupplierCreateSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof SupplierCreateSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SupplierCreateSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof SupplierCreateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof SupplierCreateSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * Additional user locations
     * @type {Array<UserLocationCreateSchema>}
     * @memberof SupplierCreateSchema
     */
    'additionalLocations'?: Array<UserLocationCreateSchema>;
    /**
     * Country id
     * @type {number}
     * @memberof SupplierCreateSchema
     */
    'countryId': number;
    /**
     * Sites
     * @type {Array<UserSiteCreateSchema>}
     * @memberof SupplierCreateSchema
     */
    'sites'?: Array<UserSiteCreateSchema>;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof SupplierCreateSchema
     */
    'vatNumber'?: string;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof SupplierCreateSchema
     */
    'isVatPayer': boolean;
    /**
     * Currencies ids to add to user
     * @type {Array<SupplierCurrencyCreateSchema>}
     * @memberof SupplierCreateSchema
     */
    'userCurrencies': Array<SupplierCurrencyCreateSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof SupplierCreateSchema
     */
    'supplierMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactBaseSchema>}
     * @memberof SupplierCreateSchema
     */
    'supplierAdditionalContacts'?: Array<UserAdditionalContactBaseSchema>;
    /**
     * 
     * @type {string}
     * @memberof SupplierCreateSchema
     */
    'supplierManagerId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierCreateSchema
     */
    'supplierCategoryId'?: number;
}
/**
 * Supplier currency schema.
 * @export
 * @interface SupplierCurrencyCreateSchema
 */
export interface SupplierCurrencyCreateSchema {
    /**
     * Currency id
     * @type {number}
     * @memberof SupplierCurrencyCreateSchema
     */
    'currencyId': number;
    /**
     * 
     * @type {UserCreditLimitSchemaWriteSchema}
     * @memberof SupplierCurrencyCreateSchema
     */
    'creditLimit': UserCreditLimitSchemaWriteSchema;
}
/**
 * Client currency update formset schema.
 * @export
 * @interface SupplierCurrencyFormsetSchema
 */
export interface SupplierCurrencyFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierCurrencyFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierCurrencyFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierCurrencyFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * Currency id
     * @type {number}
     * @memberof SupplierCurrencyFormsetSchema
     */
    'currencyId': number;
    /**
     * 
     * @type {UserCreditLimitSchemaWriteSchema}
     * @memberof SupplierCurrencyFormsetSchema
     */
    'creditLimit': UserCreditLimitSchemaWriteSchema;
}
/**
 * Supplier deactivation schema.
 * @export
 * @interface SupplierDeactivationSchema
 */
export interface SupplierDeactivationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof SupplierDeactivationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof SupplierDeactivationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Supplier full info schema.
 * @export
 * @interface SupplierFullInfoSchema
 */
export interface SupplierFullInfoSchema {
    /**
     * Name
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SupplierFullInfoSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof SupplierFullInfoSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof SupplierFullInfoSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof SupplierFullInfoSchema
     */
    'isVatPayer': boolean;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierFullInfoSchema
     */
    'avatar'?: string;
    /**
     * Additional user locations
     * @type {Array<UserLocationReadSchema>}
     * @memberof SupplierFullInfoSchema
     */
    'additionalLocations': Array<UserLocationReadSchema>;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof SupplierFullInfoSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * Sites
     * @type {Array<UserSiteReadSchema>}
     * @memberof SupplierFullInfoSchema
     */
    'sites': Array<UserSiteReadSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierFullInfoSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierFullInfoSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierFullInfoSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierFullInfoSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {SupplierStatuses}
     * @memberof SupplierFullInfoSchema
     */
    'supplierStatus': SupplierStatuses;
    /**
     * 
     * @type {Array<UserCurrencyReadSchema>}
     * @memberof SupplierFullInfoSchema
     */
    'userCurrencies': Array<UserCurrencyReadSchema>;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof SupplierFullInfoSchema
     */
    'supplierManager': SimpleStaffReadSchema;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof SupplierFullInfoSchema
     */
    'supplierCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof SupplierFullInfoSchema
     */
    'supplierPriceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof SupplierFullInfoSchema
     */
    'supplierMainContact': UserMainContactBaseReadSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof SupplierFullInfoSchema
     */
    'supplierAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'ordersCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'proformasCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'invoicesCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'paymentsCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'returnsCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'mutualSettlementsCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'contractsCount': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierFullInfoSchema
     */
    'notesCount': number;
    /**
     * 
     * @type {VatRates}
     * @memberof SupplierFullInfoSchema
     */
    'vatRate'?: VatRates;
}
/**
 * Supplier invoice additional expense create schema.
 * @export
 * @interface SupplierInvoiceAdditionalExpenseChangeSchema
 */
export interface SupplierInvoiceAdditionalExpenseChangeSchema {
    /**
     * If None - new supplier invoice for allocation will be created.
     * @type {number}
     * @memberof SupplierInvoiceAdditionalExpenseChangeSchema
     */
    'id'?: number;
    /**
     * Supplier invoice ID
     * @type {number}
     * @memberof SupplierInvoiceAdditionalExpenseChangeSchema
     */
    'childInvoiceId': number;
    /**
     * Additional expenses list for supplier invoice
     * @type {Array<SupplierNomenclatureAdditionalExpenseChangeSchema>}
     * @memberof SupplierInvoiceAdditionalExpenseChangeSchema
     */
    'additionalExpenses': Array<SupplierNomenclatureAdditionalExpenseChangeSchema>;
    /**
     * Field for deleting client invoice.
     * @type {boolean}
     * @memberof SupplierInvoiceAdditionalExpenseChangeSchema
     */
    'isDeleted'?: boolean;
}
/**
 * Supplier invoice additional expense schema.
 * @export
 * @interface SupplierInvoiceAdditionalExpenseSchema
 */
export interface SupplierInvoiceAdditionalExpenseSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {InvoiceSchemaForAdditionalExpense}
     * @memberof SupplierInvoiceAdditionalExpenseSchema
     */
    'childInvoice': InvoiceSchemaForAdditionalExpense;
    /**
     * 
     * @type {Array<SupplierNomenclatureAdditionalExpenseSchema>}
     * @memberof SupplierInvoiceAdditionalExpenseSchema
     */
    'additionalExpenses': Array<SupplierNomenclatureAdditionalExpenseSchema>;
}
/**
 * Supplier invoice nomenclature change schema for create/update schemas.
 * @export
 * @interface SupplierInvoiceAdditionalNomenclatureCreateSchema
 */
export interface SupplierInvoiceAdditionalNomenclatureCreateSchema {
    /**
     * Nomenclature service ID
     * @type {number}
     * @memberof SupplierInvoiceAdditionalNomenclatureCreateSchema
     */
    'orderNomenclatureId'?: number;
    /**
     * Nomenclature service ID
     * @type {number}
     * @memberof SupplierInvoiceAdditionalNomenclatureCreateSchema
     */
    'nomenclatureId': number;
    /**
     * Nomenclature vendor code ID.
     * @type {number}
     * @memberof SupplierInvoiceAdditionalNomenclatureCreateSchema
     */
    'vendorCodeId'?: number;
    /**
     * Nomenclature service quantity
     * @type {number}
     * @memberof SupplierInvoiceAdditionalNomenclatureCreateSchema
     */
    'quantity': number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof SupplierInvoiceAdditionalNomenclatureCreateSchema
     */
    'price': number;
}
/**
 * Supplier invoice cancellation schema.
 * @export
 * @interface SupplierInvoiceCancellationSchema
 */
export interface SupplierInvoiceCancellationSchema {
    /**
     * Cancellation reason text. Used for \'Other\' cancellation reason creation. Can not be specified together with cancellation_reason_id.
     * @type {string}
     * @memberof SupplierInvoiceCancellationSchema
     */
    'cancellationReasonText'?: string;
    /**
     * Cancellation reason id. Used for cancellation reason creation. If not specified, \'Other\' cancellation with custom text will be created. Get id\'s from endpoint GET /settings/cancellation-reason-group/{cancellation_reason_group_type}/select/ where cancellation_reason_group_type is \'employee_inactive_description\' or other needed cancellation reason group type. 
     * @type {number}
     * @memberof SupplierInvoiceCancellationSchema
     */
    'cancellationReasonId'?: number;
}
/**
 * Supplier invoice create schema.
 * @export
 * @interface SupplierInvoiceCreateSchema
 */
export interface SupplierInvoiceCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceCreateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceCreateSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof SupplierInvoiceCreateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof SupplierInvoiceCreateSchema
     */
    'comment'?: string;
    /**
     * Warehouse id.
     * @type {number}
     * @memberof SupplierInvoiceCreateSchema
     */
    'warehouseId': number;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Order ID. Only active orders.
     * @type {number}
     * @memberof SupplierInvoiceCreateSchema
     */
    'orderId': number;
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureChangeSchema>}
     * @memberof SupplierInvoiceCreateSchema
     */
    'invoiceNomenclatures': Array<SupplierInvoiceNomenclatureChangeSchema>;
}
/**
 * Supplier invoice detail schema.
 * @export
 * @interface SupplierInvoiceDetailSchema
 */
export interface SupplierInvoiceDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof SupplierInvoiceDetailSchema
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierInvoiceDetailSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'datePayment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'isOverduePayment'?: boolean;
    /**
     * Check if request user has conduct permission.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasConductPermission'?: boolean;
    /**
     * Check if request user has cancel permission.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasCancelPermission'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasOverdueInvoices'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'isSufficientFunds'?: boolean;
    /**
     * Check if invoice has conducted supplier invoices with additional expenses.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasConductedSupplierInvoices': boolean;
    /**
     * If invoice has created or conducted returns.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasRelatedReturns': boolean;
    /**
     * Check if invoice has created return.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasCreatedReturn': boolean;
    /**
     * Check if invoice has conducted returns.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasConductedReturns': boolean;
    /**
     * Check if invoice has related payment orders.
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasRelatedPayments'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'canConduct'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'canCancel'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'canCreateReturn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceDetailSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceDetailSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceDetailSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceDetailSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {SupplierOrderDetailSchemaForSupplierInvoice}
     * @memberof SupplierInvoiceDetailSchema
     */
    'order': SupplierOrderDetailSchemaForSupplierInvoice;
    /**
     * 
     * @type {SimpleWarehouseSchema}
     * @memberof SupplierInvoiceDetailSchema
     */
    'warehouse'?: SimpleWarehouseSchema;
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureDetailSchema>}
     * @memberof SupplierInvoiceDetailSchema
     */
    'invoiceNomenclatures': Array<SupplierInvoiceNomenclatureDetailSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceDetailSchema
     */
    'hasEnoughNomenclaturesForCancel'?: boolean;
}
/**
 * Supplier invoice for additional expense schema.
 * @export
 * @interface SupplierInvoiceForAdditionalExpenseSchema
 */
export interface SupplierInvoiceForAdditionalExpenseSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'dateConduction': string;
    /**
     * 
     * @type {BaseOrderForAdditionalExpenseSchema}
     * @memberof SupplierInvoiceForAdditionalExpenseSchema
     */
    'order': BaseOrderForAdditionalExpenseSchema;
}
/**
 * Supplier invoice for nomenclature income schema.
 * @export
 * @interface SupplierInvoiceForNomenclatureIncomeSchema
 */
export interface SupplierInvoiceForNomenclatureIncomeSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'dateConduction': string;
    /**
     * 
     * @type {SupplierOrderForNomenclatureIncomeSchema}
     * @memberof SupplierInvoiceForNomenclatureIncomeSchema
     */
    'order': SupplierOrderForNomenclatureIncomeSchema;
}
/**
 * Supplier invoice for product return read schema.
 * @export
 * @interface SupplierInvoiceForProductReturnDetailSchema
 */
export interface SupplierInvoiceForProductReturnDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SupplierOrderForProductReturnDetailSchema}
     * @memberof SupplierInvoiceForProductReturnDetailSchema
     */
    'order': SupplierOrderForProductReturnDetailSchema;
}
/**
 * Supplier invoice for product return read schema.
 * @export
 * @interface SupplierInvoiceForProductReturnListSchema
 */
export interface SupplierInvoiceForProductReturnListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SupplierOrderForProductReturnListSchema}
     * @memberof SupplierInvoiceForProductReturnListSchema
     */
    'order': SupplierOrderForProductReturnListSchema;
}
/**
 * Supplier invoice labels query-filter for supplier invoice list.
 * @export
 * @enum {string}
 */

export const SupplierInvoiceLabels = {
    PaymentDate: 'has_payment_date',
    PassedPaymentDate: 'has_passed_payment_date',
    InactiveSupplier: 'has_inactive_supplier',
    ProductReturn: 'has_product_return'
} as const;

export type SupplierInvoiceLabels = typeof SupplierInvoiceLabels[keyof typeof SupplierInvoiceLabels];


/**
 * Supplier invoice list schema.
 * @export
 * @interface SupplierInvoiceListSchema
 */
export interface SupplierInvoiceListSchema {
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierInvoiceListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof SupplierInvoiceListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof SupplierInvoiceListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceListSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceListSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof SupplierInvoiceListSchema
     */
    'status': InvoiceStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierInvoiceListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceListSchema
     */
    'dateCreated': string;
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierInvoiceListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierInvoiceListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof SupplierInvoiceListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {SupplierInvoiceTypes}
     * @memberof SupplierInvoiceListSchema
     */
    'type': SupplierInvoiceTypes;
    /**
     * 
     * @type {SupplierOrderReadSchemaForDocumentsList}
     * @memberof SupplierInvoiceListSchema
     */
    'order': SupplierOrderReadSchemaForDocumentsList;
}
/**
 * Supplier invoice nomenclature change schema for create/update schemas.
 * @export
 * @interface SupplierInvoiceNomenclatureChangeSchema
 */
export interface SupplierInvoiceNomenclatureChangeSchema {
    /**
     * Order nomenclature ID. Must be unique
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureChangeSchema
     */
    'orderNomenclatureId': number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureChangeSchema
     */
    'quantity': number;
    /**
     * Is additional expense.
     * @type {boolean}
     * @memberof SupplierInvoiceNomenclatureChangeSchema
     */
    'isAdditionalExpense'?: boolean;
}
/**
 * Supplier invoice nomenclature detail schema.
 * @export
 * @interface SupplierInvoiceNomenclatureDetailSchema
 */
export interface SupplierInvoiceNomenclatureDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'currentPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'productReturnNomenclaturesQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'availableQuantityForReturn'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {SupplierOrderNomenclatureForDocumentSchema}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'orderNomenclature': SupplierOrderNomenclatureForDocumentSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierInvoiceNomenclatureDetailSchema
     */
    'isAdditionalExpense': boolean;
}
/**
 * Supplier order nomenclature list schema.
 * @export
 * @interface SupplierInvoiceNomenclatureIncomeListSchema
 */
export interface SupplierInvoiceNomenclatureIncomeListSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'quantity': number;
    /**
     * 
     * @type {SupplierInvoiceForNomenclatureIncomeSchema}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'invoice': SupplierInvoiceForNomenclatureIncomeSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'priceWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'euroPriceWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'euroCostPricePerItem': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomeListSchema
     */
    'euroCostPrice': number;
}
/**
 * Supplier invoice nomenclature income page schema.
 * @export
 * @interface SupplierInvoiceNomenclatureIncomePage
 */
export interface SupplierInvoiceNomenclatureIncomePage {
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureIncomeListSchema>}
     * @memberof SupplierInvoiceNomenclatureIncomePage
     */
    'items': Array<SupplierInvoiceNomenclatureIncomeListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureIncomePage
     */
    'totalPages': number;
}
/**
 * Supplier order nomenclature list schema.
 * @export
 * @interface SupplierInvoiceNomenclatureListSchema
 */
export interface SupplierInvoiceNomenclatureListSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'currentPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'productReturnNomenclaturesQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'availableQuantityForReturn'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {SimpleOrderNomenclatureSchema}
     * @memberof SupplierInvoiceNomenclatureListSchema
     */
    'orderNomenclature': SimpleOrderNomenclatureSchema;
}
/**
 * Supplier invoice nomenclature page schema.
 * @export
 * @interface SupplierInvoiceNomenclaturePageSchema
 */
export interface SupplierInvoiceNomenclaturePageSchema {
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureListSchema>}
     * @memberof SupplierInvoiceNomenclaturePageSchema
     */
    'items': Array<SupplierInvoiceNomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclaturePageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoiceNomenclaturePageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierInvoiceNomenclaturePageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierInvoiceNomenclaturePageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierInvoiceNomenclaturePageSchema
     */
    'totalPages': number;
}
/**
 * Supplier invoice nomenclature update schema.
 * @export
 * @interface SupplierInvoiceNomenclatureUpdateSchema
 */
export interface SupplierInvoiceNomenclatureUpdateSchema {
    /**
     * Order nomenclature ID. Must be unique
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureUpdateSchema
     */
    'orderNomenclatureId': number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureUpdateSchema
     */
    'quantity': number;
    /**
     * Is additional expense.
     * @type {boolean}
     * @memberof SupplierInvoiceNomenclatureUpdateSchema
     */
    'isAdditionalExpense'?: boolean;
    /**
     * Field id. If None - new invoice nomenclature will be created.
     * @type {number}
     * @memberof SupplierInvoiceNomenclatureUpdateSchema
     */
    'id'?: number;
    /**
     * Field for deleting invoice nomenclature
     * @type {boolean}
     * @memberof SupplierInvoiceNomenclatureUpdateSchema
     */
    'isDeleted': boolean;
}
/**
 * Supplier invoices page schema.
 * @export
 * @interface SupplierInvoicePage
 */
export interface SupplierInvoicePage {
    /**
     * 
     * @type {Array<SupplierInvoiceListSchema>}
     * @memberof SupplierInvoicePage
     */
    'items': Array<SupplierInvoiceListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoicePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierInvoicePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierInvoicePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierInvoicePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierInvoicePage
     */
    'totalPages': number;
}
/**
 * Supplier invoice type choices.
 * @export
 * @enum {string}
 */

export const SupplierInvoiceTypes = {
    Standard: 'standard',
    Additional: 'additional'
} as const;

export type SupplierInvoiceTypes = typeof SupplierInvoiceTypes[keyof typeof SupplierInvoiceTypes];


/**
 * supplier order update schema.
 * @export
 * @interface SupplierInvoiceUpdateSchema
 */
export interface SupplierInvoiceUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'comment'?: string;
    /**
     * Warehouse id.
     * @type {number}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'warehouseId': number;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {InvoiceUpdateStatuses}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'status': InvoiceUpdateStatuses;
    /**
     * 
     * @type {Array<SupplierInvoiceNomenclatureUpdateSchema>}
     * @memberof SupplierInvoiceUpdateSchema
     */
    'invoiceNomenclatures': Array<SupplierInvoiceNomenclatureUpdateSchema>;
}
/**
 * Supplier labels query-filter for supplier list.
 * @export
 * @enum {string}
 */

export const SupplierLabels = {
    Client: 'is_client',
    Agent: 'is_agent'
} as const;

export type SupplierLabels = typeof SupplierLabels[keyof typeof SupplierLabels];


/**
 * Supplier list schema.
 * @export
 * @interface SupplierListSchema
 */
export interface SupplierListSchema {
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof SupplierListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierListSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierListSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierListSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierListSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SupplierListSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof SupplierListSchema
     */
    'supplierCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof SupplierListSchema
     */
    'supplierMainContact': UserMainContactBaseReadSchema;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof SupplierListSchema
     */
    'supplierManager': SimpleStaffReadSchema;
    /**
     * 
     * @type {SupplierStatuses}
     * @memberof SupplierListSchema
     */
    'supplierStatus': SupplierStatuses;
    /**
     * 
     * @type {CountrySchema}
     * @memberof SupplierListSchema
     */
    'country': CountrySchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {Array<DebtOrOverpaymentSchema>}
     * @memberof SupplierListSchema
     */
    'debtsOrOverpayments'?: Array<DebtOrOverpaymentSchema>;
}
/**
 * Supplier nomenclature additional expense create schema.
 * @export
 * @interface SupplierNomenclatureAdditionalExpenseChangeSchema
 */
export interface SupplierNomenclatureAdditionalExpenseChangeSchema {
    /**
     * If None - new additional expense will be created.
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseChangeSchema
     */
    'id'?: number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseChangeSchema
     */
    'priceWithoutVat': number;
    /**
     * Order nomenclature ID from supplier invoice.
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseChangeSchema
     */
    'orderNomenclatureId': number;
    /**
     * Field for deleting additional expense.
     * @type {boolean}
     * @memberof SupplierNomenclatureAdditionalExpenseChangeSchema
     */
    'isDeleted': boolean;
}
/**
 * Supplier nomenclature additional expense list schema.
 * @export
 * @interface SupplierNomenclatureAdditionalExpenseListSchema
 */
export interface SupplierNomenclatureAdditionalExpenseListSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'priceWithoutVat': number;
    /**
     * 
     * @type {BaseOrderNomenclatureSchema}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'orderNomenclature': BaseOrderNomenclatureSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'priceWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'euroSumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'euroSumWithVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'euroVatTotal'?: number;
    /**
     * 
     * @type {string}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {SimpleSupplierInvoiceAdditionalExpenseSchema}
     * @memberof SupplierNomenclatureAdditionalExpenseListSchema
     */
    'expense': SimpleSupplierInvoiceAdditionalExpenseSchema;
}
/**
 * Supplier nomenclature additional expense schema.
 * @export
 * @interface SupplierNomenclatureAdditionalExpenseSchema
 */
export interface SupplierNomenclatureAdditionalExpenseSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierNomenclatureAdditionalExpenseSchema
     */
    'priceWithoutVat': number;
    /**
     * 
     * @type {BaseOrderNomenclatureSchema}
     * @memberof SupplierNomenclatureAdditionalExpenseSchema
     */
    'orderNomenclature': BaseOrderNomenclatureSchema;
}
/**
 * Supplier order create schema.
 * @export
 * @interface SupplierOrderCreateSchema
 */
export interface SupplierOrderCreateSchema {
    /**
     * Price category ID. Only active categories or categories.
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'priceCategoryId': number;
    /**
     * Currency rate. Only \'1\' for EUR currency
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'rate': number;
    /**
     * Only signed contracts. Only contract with selected currency for order. Client contract IDs for client. Supplier contract IDs for supplier.
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'contractId'?: number;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof SupplierOrderCreateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof SupplierOrderCreateSchema
     */
    'comment'?: string;
    /**
     * User currency ID. Only active client/supplier currencies.
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'userCurrencyId': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderCreateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderCreateSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderCreateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * Client ID for client order. Supplier ID for supplier order
     * @type {string}
     * @memberof SupplierOrderCreateSchema
     */
    'userId': string;
    /**
     * Client order id. Field used for creating related orders.
     * @type {number}
     * @memberof SupplierOrderCreateSchema
     */
    'clientOrderId'?: number;
    /**
     * 
     * @type {Array<SupplierOrderNomenclatureChangeSchema>}
     * @memberof SupplierOrderCreateSchema
     */
    'orderNomenclatures': Array<SupplierOrderNomenclatureChangeSchema>;
}
/**
 * Supplier order detail schema.
 * @export
 * @interface SupplierOrderDetailSchema
 */
export interface SupplierOrderDetailSchema {
    /**
     * 
     * @type {SimpleUserWithVat}
     * @memberof SupplierOrderDetailSchema
     */
    'user': SimpleUserWithVat;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof SupplierOrderDetailSchema
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'rate'?: number;
    /**
     * 
     * @type {VatRates}
     * @memberof SupplierOrderDetailSchema
     */
    'vatRate'?: VatRates;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof SupplierOrderDetailSchema
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'comment'?: string;
    /**
     * Created or conducted(with debt) invoices. Created or \'submitted_for_payment\' proformas
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'hasUnclosedDocuments': boolean;
    /**
     * Conducted invoices or paid proformas
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'hasCompletedDocuments': boolean;
    /**
     * Only created proformas
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'hasOnlyCreatedProformas': boolean;
    /**
     * Can change currency rate in CRM
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'crmChangeCurrencyRate': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'canChangeCurrency'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'canChangeCurrencyRate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'canChangeContract'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'canComplete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'canCancel'?: boolean;
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof SupplierOrderDetailSchema
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof SupplierOrderDetailSchema
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchema
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierOrderDetailSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierOrderDetailSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof SupplierOrderDetailSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof SupplierOrderDetailSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {Array<SupplierOrderNomenclatureDetailSchema>}
     * @memberof SupplierOrderDetailSchema
     */
    'orderNomenclatures': Array<SupplierOrderNomenclatureDetailSchema>;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchema
     */
    'deliveryDate'?: string;
}
/**
 * Supplier order detail schema for proforma.
 * @export
 * @interface SupplierOrderDetailSchemaForProforma
 */
export interface SupplierOrderDetailSchemaForProforma {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {UserForSupplierProformaDetailSchema}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'user': UserForSupplierProformaDetailSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {VatRates}
     * @memberof SupplierOrderDetailSchemaForProforma
     */
    'vatRate'?: VatRates;
}
/**
 * Supplier order detail schema for supplier invoice.
 * @export
 * @interface SupplierOrderDetailSchemaForSupplierInvoice
 */
export interface SupplierOrderDetailSchemaForSupplierInvoice {
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchemaForSupplierInvoice
     */
    'id': number;
    /**
     * 
     * @type {SimpleUserWithVat}
     * @memberof SupplierOrderDetailSchemaForSupplierInvoice
     */
    'user': SimpleUserWithVat;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof SupplierOrderDetailSchemaForSupplierInvoice
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof SupplierOrderDetailSchemaForSupplierInvoice
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderDetailSchemaForSupplierInvoice
     */
    'rate': number;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof SupplierOrderDetailSchemaForSupplierInvoice
     */
    'contract'?: SimpleContractSchema;
}
/**
 * Supplier order list schema for expected nomenclatures.
 * @export
 * @interface SupplierOrderForExpectedNomenclatureListSchema
 */
export interface SupplierOrderForExpectedNomenclatureListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'deliveryDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderForExpectedNomenclatureListSchema
     */
    'isOverdue'?: boolean;
}
/**
 * Supplier invoice for nomenclature income schema.
 * @export
 * @interface SupplierOrderForNomenclatureIncomeSchema
 */
export interface SupplierOrderForNomenclatureIncomeSchema {
    /**
     * 
     * @type {BaseSimpleUserReadSchema}
     * @memberof SupplierOrderForNomenclatureIncomeSchema
     */
    'user': BaseSimpleUserReadSchema;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof SupplierOrderForNomenclatureIncomeSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderForNomenclatureIncomeSchema
     */
    'rate': number;
}
/**
 * Supplier order detail schema for proforma.
 * @export
 * @interface SupplierOrderForProductReturnDetailSchema
 */
export interface SupplierOrderForProductReturnDetailSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {UserForSupplierProformaDetailSchema}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'user': UserForSupplierProformaDetailSchema;
    /**
     * 
     * @type {ComplexUserCurrencyReadSchema}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'userCurrency': ComplexUserCurrencyReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'priceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'contract'?: SimpleContractSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderForProductReturnDetailSchema
     */
    'vatRate'?: number;
}
/**
 * Supplier order detail schema for proforma.
 * @export
 * @interface SupplierOrderForProductReturnListSchema
 */
export interface SupplierOrderForProductReturnListSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {UserForSupplierProformaListSchema}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'user': UserForSupplierProformaListSchema;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof SupplierOrderForProductReturnListSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
}
/**
 * Label schema for client order.
 * @export
 * @interface SupplierOrderLabelSchema
 */
export interface SupplierOrderLabelSchema {
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderLabelSchema
     */
    'hasOrderRelationship': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderLabelSchema
     */
    'hasProductPartialReturn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderLabelSchema
     */
    'hasProductFullReturn': boolean;
}
/**
 * Supplier order labels query-filter for supplier order list.
 * @export
 * @enum {string}
 */

export const SupplierOrderLabels = {
    OrderRelationship: 'has_order_relationship',
    InactiveSupplier: 'has_inactive_supplier',
    ProductReturn: 'has_product_return'
} as const;

export type SupplierOrderLabels = typeof SupplierOrderLabels[keyof typeof SupplierOrderLabels];


/**
 * Supplier order list schema.
 * @export
 * @interface SupplierOrderListSchema
 */
export interface SupplierOrderListSchema {
    /**
     * 
     * @type {OrderStatuses}
     * @memberof SupplierOrderListSchema
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof SupplierOrderListSchema
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderListSchema
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierOrderListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierOrderListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof SupplierOrderListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof SupplierOrderListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderListSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderListSchema
     */
    'sumPaidByConductedInvoices'?: number;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof SupplierOrderListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {SupplierOrderSupplierSchema}
     * @memberof SupplierOrderListSchema
     */
    'user': SupplierOrderSupplierSchema;
}
/**
 * Supplier order list schema for proforma.
 * @export
 * @interface SupplierOrderListSchemaForProforma
 */
export interface SupplierOrderListSchemaForProforma {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'dateCreated': string;
    /**
     * 
     * @type {OrderStatuses}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'status': OrderStatuses;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'isVat': boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {UserForSupplierProformaDetailSchema}
     * @memberof SupplierOrderListSchemaForProforma
     */
    'user': UserForSupplierProformaDetailSchema;
}
/**
 * Supplier order nomenclature change schema for create/update schemas.
 * @export
 * @interface SupplierOrderNomenclatureChangeSchema
 */
export interface SupplierOrderNomenclatureChangeSchema {
    /**
     * Nomenclature ID. Only active nomenclatures.
     * @type {number}
     * @memberof SupplierOrderNomenclatureChangeSchema
     */
    'nomenclatureId': number;
    /**
     * Nomenclature vendor code ID. Required for product nomenclatures.
     * @type {number}
     * @memberof SupplierOrderNomenclatureChangeSchema
     */
    'vendorCodeId'?: number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof SupplierOrderNomenclatureChangeSchema
     */
    'quantity': number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof SupplierOrderNomenclatureChangeSchema
     */
    'price'?: number;
    /**
     * Nomenclature delivery date.
     * @type {string}
     * @memberof SupplierOrderNomenclatureChangeSchema
     */
    'deliveryDate'?: string;
}
/**
 * Supplier order nomenclature detail schema.
 * @export
 * @interface SupplierOrderNomenclatureDetailSchema
 */
export interface SupplierOrderNomenclatureDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {DocumentNomenclatureSchema}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'nomenclature': DocumentNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'availableOrderQuantityForInvoices'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'deliveryDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierOrderNomenclatureDetailSchema
     */
    'isValidDate'?: boolean;
}
/**
 * Supplier order nomenclature detail schema.
 * @export
 * @interface SupplierOrderNomenclatureForDocumentSchema
 */
export interface SupplierOrderNomenclatureForDocumentSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureForDocumentSchema
     */
    'availableOrderQuantityForInvoices'?: number;
}
/**
 * Supplier order nomenclature list schema.
 * @export
 * @interface SupplierOrderNomenclatureListSchema
 */
export interface SupplierOrderNomenclatureListSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'id': number;
    /**
     * 
     * @type {ComplexNomenclatureSchema}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'nomenclature': ComplexNomenclatureSchema;
    /**
     * 
     * @type {SimpleVendorCodeSchema}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'vendorCode'?: SimpleVendorCodeSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'quantityUsedByProformas': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'quantityUsedByInvoices': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'availableOrderQuantityForProformas'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'availableOrderQuantityForInvoices'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclatureListSchema
     */
    'sumWithVat'?: number;
}
/**
 * Supplier order nomenclature page schema.
 * @export
 * @interface SupplierOrderNomenclaturePageSchema
 */
export interface SupplierOrderNomenclaturePageSchema {
    /**
     * 
     * @type {Array<SupplierOrderNomenclatureListSchema>}
     * @memberof SupplierOrderNomenclaturePageSchema
     */
    'items': Array<SupplierOrderNomenclatureListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclaturePageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderNomenclaturePageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierOrderNomenclaturePageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierOrderNomenclaturePageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierOrderNomenclaturePageSchema
     */
    'totalPages': number;
}
/**
 * Supplier order nomenclature create schema.
 * @export
 * @interface SupplierOrderNomenclatureUpdateSchema
 */
export interface SupplierOrderNomenclatureUpdateSchema {
    /**
     * Nomenclature ID. Only active nomenclatures.
     * @type {number}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'nomenclatureId': number;
    /**
     * Nomenclature vendor code ID. Required for product nomenclatures.
     * @type {number}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'vendorCodeId'?: number;
    /**
     * Nomenclature quantity
     * @type {number}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'quantity': number;
    /**
     * Price field. Without VAT.
     * @type {number}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'price'?: number;
    /**
     * Nomenclature delivery date.
     * @type {string}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'deliveryDate'?: string;
    /**
     * Field id. If None - new order nomenclature will be created.
     * @type {number}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'id'?: number;
    /**
     * Field for deleting order nomenclature
     * @type {boolean}
     * @memberof SupplierOrderNomenclatureUpdateSchema
     */
    'isDeleted': boolean;
}
/**
 * Supplier orders page schema.
 * @export
 * @interface SupplierOrderPage
 */
export interface SupplierOrderPage {
    /**
     * 
     * @type {Array<SupplierOrderListSchema>}
     * @memberof SupplierOrderPage
     */
    'items': Array<SupplierOrderListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierOrderPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierOrderPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierOrderPage
     */
    'totalPages': number;
}
/**
 * Supplier order read schema for supplier invoice/proforma list endpoints.
 * @export
 * @interface SupplierOrderReadSchemaForDocumentsList
 */
export interface SupplierOrderReadSchemaForDocumentsList {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'dateCreated': string;
    /**
     * 
     * @type {SupplierOrderSupplierSchema}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'user': SupplierOrderSupplierSchema;
    /**
     * 
     * @type {SimpleUserCurrencyReadSchema}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'userCurrency': SimpleUserCurrencyReadSchema;
    /**
     * 
     * @type {SimpleContractSchema}
     * @memberof SupplierOrderReadSchemaForDocumentsList
     */
    'contract'?: SimpleContractSchema;
}
/**
 * Supplier schema for supplier order list.
 * @export
 * @interface SupplierOrderSupplierSchema
 */
export interface SupplierOrderSupplierSchema {
    /**
     * Name
     * @type {string}
     * @memberof SupplierOrderSupplierSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderSupplierSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderSupplierSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof SupplierOrderSupplierSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SupplierOrderSupplierSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof SupplierOrderSupplierSchema
     */
    'supplierCategory'?: SimpleUserCategoryReadSchema;
}
/**
 * Supplier order update schema.
 * @export
 * @interface SupplierOrderUpdateSchema
 */
export interface SupplierOrderUpdateSchema {
    /**
     * Price category ID. Only active categories or categories.
     * @type {number}
     * @memberof SupplierOrderUpdateSchema
     */
    'priceCategoryId': number;
    /**
     * Currency rate. Only \'1\' for EUR currency
     * @type {number}
     * @memberof SupplierOrderUpdateSchema
     */
    'rate': number;
    /**
     * Only signed contracts. Only contract with selected currency for order. Client contract IDs for client. Supplier contract IDs for supplier.
     * @type {number}
     * @memberof SupplierOrderUpdateSchema
     */
    'contractId'?: number;
    /**
     * Staff ID. Only active and with \'edit\' document perm.
     * @type {string}
     * @memberof SupplierOrderUpdateSchema
     */
    'responsibleId': string;
    /**
     * Comment field
     * @type {string}
     * @memberof SupplierOrderUpdateSchema
     */
    'comment'?: string;
    /**
     * User currency ID. Only active client/supplier currencies.
     * @type {number}
     * @memberof SupplierOrderUpdateSchema
     */
    'userCurrencyId': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderUpdateSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierOrderUpdateSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierOrderUpdateSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof SupplierOrderUpdateSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierOrderUpdateSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {OrderUpdateStatuses}
     * @memberof SupplierOrderUpdateSchema
     */
    'status': OrderUpdateStatuses;
    /**
     * 
     * @type {Array<SupplierOrderNomenclatureUpdateSchema>}
     * @memberof SupplierOrderUpdateSchema
     */
    'orderNomenclatures': Array<SupplierOrderNomenclatureUpdateSchema>;
}
/**
 * Client order with reserve list schema.
 * @export
 * @interface SupplierOrderWithExpectedNomenclatureListSchema
 */
export interface SupplierOrderWithExpectedNomenclatureListSchema {
    /**
     * 
     * @type {SupplierOrderForExpectedNomenclatureListSchema}
     * @memberof SupplierOrderWithExpectedNomenclatureListSchema
     */
    'order': SupplierOrderForExpectedNomenclatureListSchema;
    /**
     * 
     * @type {number}
     * @memberof SupplierOrderWithExpectedNomenclatureListSchema
     */
    'expectedQuantity': number;
}
/**
 * Supplier page schema.
 * @export
 * @interface SupplierPage
 */
export interface SupplierPage {
    /**
     * 
     * @type {Array<SupplierListSchema>}
     * @memberof SupplierPage
     */
    'items': Array<SupplierListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierPage
     */
    'totalPages': number;
}
/**
 * SupplierPriceListCell schema.
 * @export
 * @interface SupplierPriceListCellSchema
 */
export interface SupplierPriceListCellSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierPriceListCellSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierPriceListCellSchema
     */
    'name': string;
    /**
     * 
     * @type {SupplierPriceListCellType}
     * @memberof SupplierPriceListCellSchema
     */
    'type'?: SupplierPriceListCellType;
}
/**
 * SupplierPriceListCellType model.
 * @export
 * @enum {string}
 */

export const SupplierPriceListCellType = {
    VendorCode: 'vendor_code',
    Cost: 'cost',
    Currency: 'currency',
    Stock: 'stock'
} as const;

export type SupplierPriceListCellType = typeof SupplierPriceListCellType[keyof typeof SupplierPriceListCellType];


/**
 * Supplier proforma labels.
 * @export
 * @enum {string}
 */

export const SupplierProductReturnLabels = {
    SupplierInactive: 'supplier_inactive'
} as const;

export type SupplierProductReturnLabels = typeof SupplierProductReturnLabels[keyof typeof SupplierProductReturnLabels];


/**
 * Base proforma read schema.
 * @export
 * @interface SupplierProductReturnListSchema
 */
export interface SupplierProductReturnListSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof SupplierProductReturnListSchema
     */
    'status': ProductReturnStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierProductReturnListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnListSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierProductReturnListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierProductReturnListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierProductReturnListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnListSchema
     */
    'dateConduction'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierProductReturnListSchema
     */
    'isEditDateExpired'?: boolean;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierProductReturnListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {CancellationSchema}
     * @memberof SupplierProductReturnListSchema
     */
    'cancellation'?: CancellationSchema;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof SupplierProductReturnListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {SupplierInvoiceForProductReturnListSchema}
     * @memberof SupplierProductReturnListSchema
     */
    'invoice': SupplierInvoiceForProductReturnListSchema;
}
/**
 * Supplier page schema.
 * @export
 * @interface SupplierProductReturnPage
 */
export interface SupplierProductReturnPage {
    /**
     * 
     * @type {Array<SupplierProductReturnListSchema>}
     * @memberof SupplierProductReturnPage
     */
    'items': Array<SupplierProductReturnListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierProductReturnPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierProductReturnPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierProductReturnPage
     */
    'totalPages': number;
}
/**
 * SupplierProductReturnSchema.
 * @export
 * @interface SupplierProductReturnSchema
 */
export interface SupplierProductReturnSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProductReturnStatuses}
     * @memberof SupplierProductReturnSchema
     */
    'status': ProductReturnStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierProductReturnSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierProductReturnSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProductReturnSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {SupplierInvoiceForProductReturnDetailSchema}
     * @memberof SupplierProductReturnSchema
     */
    'invoice': SupplierInvoiceForProductReturnDetailSchema;
    /**
     * 
     * @type {Array<ClientProductReturnNomenclatureReadSchema>}
     * @memberof SupplierProductReturnSchema
     */
    'supplierProductReturnNomenclatures': Array<ClientProductReturnNomenclatureReadSchema>;
}
/**
 * Supplier proforma labels.
 * @export
 * @enum {string}
 */

export const SupplierProformaLabels = {
    SupplierInactive: 'supplier_inactive'
} as const;

export type SupplierProformaLabels = typeof SupplierProformaLabels[keyof typeof SupplierProformaLabels];


/**
 * Base proforma read schema.
 * @export
 * @interface SupplierProformaListSchema
 */
export interface SupplierProformaListSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaListSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {ProformaStatuses}
     * @memberof SupplierProformaListSchema
     */
    'status': ProformaStatuses;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierProformaListSchema
     */
    'creator': SimpleUserSchema;
    /**
     * 
     * @type {UserTypes}
     * @memberof SupplierProformaListSchema
     */
    'creatorType': UserTypes;
    /**
     * 
     * @type {AllDocumentStatuses}
     * @memberof SupplierProformaListSchema
     */
    'statusVerbose'?: AllDocumentStatuses;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierProformaListSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierProformaListSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierProformaListSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierProformaListSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {CancellationSchema}
     * @memberof SupplierProformaListSchema
     */
    'cancellation'?: CancellationSchema;
    /**
     * 
     * @type {Array<LabelListSchema>}
     * @memberof SupplierProformaListSchema
     */
    'labelList'?: Array<LabelListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaListSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaListSchema
     */
    'sumPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaListSchema
     */
    'sumToPay'?: number;
    /**
     * 
     * @type {SupplierOrderListSchemaForProforma}
     * @memberof SupplierProformaListSchema
     */
    'order': SupplierOrderListSchemaForProforma;
}
/**
 * BaseNomenclatureProforma create schema.
 * @export
 * @interface SupplierProformaNomenclatureReadSchema
 */
export interface SupplierProformaNomenclatureReadSchema {
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'priceWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'priceWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'sumWithoutVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'sumWithVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'quantity': number;
    /**
     * 
     * @type {SupplierOrderNomenclatureForDocumentSchema}
     * @memberof SupplierProformaNomenclatureReadSchema
     */
    'orderNomenclature': SupplierOrderNomenclatureForDocumentSchema;
}
/**
 * Supplier page schema.
 * @export
 * @interface SupplierProformaPage
 */
export interface SupplierProformaPage {
    /**
     * 
     * @type {Array<SupplierProformaListSchema>}
     * @memberof SupplierProformaPage
     */
    'items': Array<SupplierProformaListSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierProformaPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierProformaPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierProformaPage
     */
    'totalPages': number;
}
/**
 * Base proforma read schema.
 * @export
 * @interface SupplierProformaSchema
 */
export interface SupplierProformaSchema {
    /**
     * Document number.
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'documentNumber': string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof SupplierProformaSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number.
     * @type {number}
     * @memberof SupplierProformaSchema
     */
    'documentNumberNumber'?: number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaSchema
     */
    'id': number;
    /**
     * 
     * @type {ProformaStatuses}
     * @memberof SupplierProformaSchema
     */
    'status': ProformaStatuses;
    /**
     * 
     * @type {SimpleUserSchema}
     * @memberof SupplierProformaSchema
     */
    'responsible': SimpleUserSchema;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'datePayment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaSchema
     */
    'vatTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaSchema
     */
    'sumWithoutVat': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierProformaSchema
     */
    'sumWithVat': number;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierProformaSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {SupplierOrderDetailSchemaForProforma}
     * @memberof SupplierProformaSchema
     */
    'order': SupplierOrderDetailSchemaForProforma;
    /**
     * 
     * @type {Array<SupplierProformaNomenclatureReadSchema>}
     * @memberof SupplierProformaSchema
     */
    'supplierProformaNomenclatures': Array<SupplierProformaNomenclatureReadSchema>;
}
/**
 * Supplier query order choices.
 * @export
 * @enum {string}
 */

export const SupplierQueryOrder = {
    DateCreated: 'dateCreated'
} as const;

export type SupplierQueryOrder = typeof SupplierQueryOrder[keyof typeof SupplierQueryOrder];


/**
 * SupplierSchema schema.
 * @export
 * @interface SupplierSchema
 */
export interface SupplierSchema {
    /**
     * Name
     * @type {string}
     * @memberof SupplierSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof SupplierSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof SupplierSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof SupplierSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SupplierSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof SupplierSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof SupplierSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof SupplierSchema
     */
    'isVatPayer': boolean;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof SupplierSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SupplierSchema
     */
    'avatar'?: string;
    /**
     * Additional user locations
     * @type {Array<UserLocationReadSchema>}
     * @memberof SupplierSchema
     */
    'additionalLocations': Array<UserLocationReadSchema>;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof SupplierSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * Sites
     * @type {Array<UserSiteReadSchema>}
     * @memberof SupplierSchema
     */
    'sites': Array<UserSiteReadSchema>;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierSchema
     */
    'isClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierSchema
     */
    'isSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierSchema
     */
    'isAgent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {SupplierStatuses}
     * @memberof SupplierSchema
     */
    'supplierStatus': SupplierStatuses;
    /**
     * 
     * @type {Array<UserCurrencyReadSchema>}
     * @memberof SupplierSchema
     */
    'userCurrencies': Array<UserCurrencyReadSchema>;
    /**
     * 
     * @type {SimpleStaffReadSchema}
     * @memberof SupplierSchema
     */
    'supplierManager': SimpleStaffReadSchema;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof SupplierSchema
     */
    'supplierCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof SupplierSchema
     */
    'supplierPriceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {UserMainContactBaseReadSchema}
     * @memberof SupplierSchema
     */
    'supplierMainContact': UserMainContactBaseReadSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactReadSchema>}
     * @memberof SupplierSchema
     */
    'supplierAdditionalContacts'?: Array<UserAdditionalContactReadSchema>;
}
/**
 * Supplier page schema.
 * @export
 * @interface SupplierSimplePage
 */
export interface SupplierSimplePage {
    /**
     * 
     * @type {Array<SimpleUserIsVatSchema>}
     * @memberof SupplierSimplePage
     */
    'items': Array<SimpleUserIsVatSchema>;
    /**
     * 
     * @type {number}
     * @memberof SupplierSimplePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof SupplierSimplePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof SupplierSimplePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof SupplierSimplePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof SupplierSimplePage
     */
    'totalPages': number;
}
/**
 * Supplier statuses choices.
 * @export
 * @enum {string}
 */

export const SupplierStatuses = {
    Active: 'active',
    Inactive: 'inactive',
    InProcessing: 'in_processing'
} as const;

export type SupplierStatuses = typeof SupplierStatuses[keyof typeof SupplierStatuses];


/**
 * Supplier turn schema.
 * @export
 * @interface SupplierTurnSchema
 */
export interface SupplierTurnSchema {
    /**
     * Currencies ids to add to user
     * @type {Array<SupplierCurrencyFormsetSchema>}
     * @memberof SupplierTurnSchema
     */
    'userCurrencies': Array<SupplierCurrencyFormsetSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof SupplierTurnSchema
     */
    'supplierMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactFormsetSchema>}
     * @memberof SupplierTurnSchema
     */
    'supplierAdditionalContacts'?: Array<UserAdditionalContactFormsetSchema>;
    /**
     * 
     * @type {string}
     * @memberof SupplierTurnSchema
     */
    'supplierManagerId': string;
    /**
     * 
     * @type {number}
     * @memberof SupplierTurnSchema
     */
    'supplierCategoryId'?: number;
}
/**
 * Staff activate schema.
 * @export
 * @interface SupplierUpdateEmailSchema
 */
export interface SupplierUpdateEmailSchema {
    /**
     * Email
     * @type {string}
     * @memberof SupplierUpdateEmailSchema
     */
    'email': string;
    /**
     * Send email about new contact phone.
     * @type {boolean}
     * @memberof SupplierUpdateEmailSchema
     */
    'sendEmail'?: boolean;
}
/**
 * Supplier update phone schema.
 * @export
 * @interface SupplierUpdatePhoneSchema
 */
export interface SupplierUpdatePhoneSchema {
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof SupplierUpdatePhoneSchema
     */
    'phone': string;
}
/**
 * Update Supplier schema.
 * @export
 * @interface SupplierUpdateSchema
 */
export interface SupplierUpdateSchema {
    /**
     * Name
     * @type {string}
     * @memberof SupplierUpdateSchema
     */
    'name': string;
    /**
     * The user\'s registration number.
     * @type {string}
     * @memberof SupplierUpdateSchema
     */
    'registrationNumber'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof SupplierUpdateSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof SupplierUpdateSchema
     */
    'email': string;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SupplierUpdateSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {Mainlocation}
     * @memberof SupplierUpdateSchema
     */
    'mainLocation': Mainlocation;
    /**
     * 
     * @type {DocumentLanguages}
     * @memberof SupplierUpdateSchema
     */
    'documentLanguage': DocumentLanguages;
    /**
     * Additional user locations
     * @type {Array<UserLocationFormsetSchema>}
     * @memberof SupplierUpdateSchema
     */
    'additionalLocations'?: Array<UserLocationFormsetSchema>;
    /**
     * Country id
     * @type {number}
     * @memberof SupplierUpdateSchema
     */
    'countryId': number;
    /**
     * Sites
     * @type {Array<UserSiteFormsetSchema>}
     * @memberof SupplierUpdateSchema
     */
    'sites'?: Array<UserSiteFormsetSchema>;
    /**
     * Currencies ids to add to user
     * @type {Array<SupplierCurrencyFormsetSchema>}
     * @memberof SupplierUpdateSchema
     */
    'userCurrencies': Array<SupplierCurrencyFormsetSchema>;
    /**
     * 
     * @type {UserMainContactBaseSchema}
     * @memberof SupplierUpdateSchema
     */
    'supplierMainContact': UserMainContactBaseSchema;
    /**
     * Currencies ids to add to user
     * @type {Array<UserAdditionalContactFormsetSchema>}
     * @memberof SupplierUpdateSchema
     */
    'supplierAdditionalContacts'?: Array<UserAdditionalContactFormsetSchema>;
    /**
     * 
     * @type {string}
     * @memberof SupplierUpdateSchema
     */
    'supplierManagerId': string;
    /**
     * 
     * @type {number}
     * @memberof SupplierUpdateSchema
     */
    'supplierCategoryId'?: number;
    /**
     * The user\'s VAT number. Vat number should be provided if user is VAT payer. If user is not VAT payer, vat number should be empty.Samples: IE6388047V, LU20260743, SI92153216
     * @type {string}
     * @memberof SupplierUpdateSchema
     */
    'vatNumber'?: string;
    /**
     * The user\'s VAT payer status.
     * @type {boolean}
     * @memberof SupplierUpdateSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupplierUpdateSchema
     */
    'isCurrenciesUpdateActive'?: boolean;
}
/**
 * Supplier category
 * @export
 * @interface Suppliercategory
 */
export interface Suppliercategory {
    /**
     * Name
     * @type {string}
     * @memberof Suppliercategory
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Suppliercategory
     */
    'id': number;
}
/**
 * Supplier manager
 * @export
 * @interface Suppliermanager
 */
export interface Suppliermanager {
    /**
     * 
     * @type {string}
     * @memberof Suppliermanager
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Suppliermanager
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof Suppliermanager
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Suppliermanager
     */
    'avatar'?: string;
}
/**
 * Support email detail schema.
 * @export
 * @interface SupportEmailDetailSchema
 */
export interface SupportEmailDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof SupportEmailDetailSchema
     */
    'email': string;
}
/**
 * Support email create schema.
 * @export
 * @interface SupportEmailUpdateSchema
 */
export interface SupportEmailUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof SupportEmailUpdateSchema
     */
    'email': string;
}
/**
 * Nomenclature type filter enum.
 * @export
 * @enum {string}
 */

export const TypeFilter = {
    Product: 'product',
    Service: 'service'
} as const;

export type TypeFilter = typeof TypeFilter[keyof typeof TypeFilter];


/**
 * Get multilanguage document name.
 * @export
 * @enum {string}
 */

export const UnclosedDocumentTypes = {
    Order: 'client_order',
    Proforma: 'client_proforma',
    Invoice: 'client_invoice',
    ProductReturn: 'client_product_return',
    Compensation: 'client_compensation'
} as const;

export type UnclosedDocumentTypes = typeof UnclosedDocumentTypes[keyof typeof UnclosedDocumentTypes];


/**
 * Unique user name response schema.
 * @export
 * @interface UniqueUserNameSchema
 */
export interface UniqueUserNameSchema {
    /**
     * 
     * @type {boolean}
     * @memberof UniqueUserNameSchema
     */
    'userWithNameAndTypeExists': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UniqueUserNameSchema
     */
    'userWithNameExists': boolean;
}
/**
 * Nomenclature unit filter enum.
 * @export
 * @enum {string}
 */

export const UnitFilter = {
    Piece: 'piece',
    Package: 'package',
    Kilogram: 'kilogram',
    Liter: 'liter',
    Day: 'day',
    Hour: 'hour'
} as const;

export type UnitFilter = typeof UnitFilter[keyof typeof UnitFilter];


/**
 * ClientProductReturn update schema.
 * @export
 * @interface UpdateClientProductReturnSchema
 */
export interface UpdateClientProductReturnSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateClientProductReturnSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateClientProductReturnSchema
     */
    'warehouseId': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateClientProductReturnSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof UpdateClientProductReturnSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof UpdateClientProductReturnSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof UpdateClientProductReturnSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {Array<ProductReturnNomenclatureFormsetSchema>}
     * @memberof UpdateClientProductReturnSchema
     */
    'clientProductReturnNomenclatures': Array<ProductReturnNomenclatureFormsetSchema>;
}
/**
 * ClientProforma create schema.
 * @export
 * @interface UpdateClientProformaSchema
 */
export interface UpdateClientProformaSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateClientProformaSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateClientProformaSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof UpdateClientProformaSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof UpdateClientProformaSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof UpdateClientProformaSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {Array<ProformaNomenclatureFormsetSchema>}
     * @memberof UpdateClientProformaSchema
     */
    'clientProformaNomenclatures': Array<ProformaNomenclatureFormsetSchema>;
    /**
     * 
     * @type {number}
     * @memberof UpdateClientProformaSchema
     */
    'incotermId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateClientProformaSchema
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateClientProformaSchema
     */
    'isSkippedSlovenia'?: boolean;
}
/**
 * Update nomenclature prices schema for markup manager.
 * @export
 * @interface UpdateNomenclaturePrices
 */
export interface UpdateNomenclaturePrices {
    /**
     * 
     * @type {Array<MarkupUpdateByBrandSchema>}
     * @memberof UpdateNomenclaturePrices
     */
    'brands'?: Array<MarkupUpdateByBrandSchema>;
    /**
     * 
     * @type {Array<MarkupUpdateByCategorySchema>}
     * @memberof UpdateNomenclaturePrices
     */
    'categories'?: Array<MarkupUpdateByCategorySchema>;
    /**
     * 
     * @type {Array<MarkupUpdateNomenclaturePriceSchema>}
     * @memberof UpdateNomenclaturePrices
     */
    'priceCategories': Array<MarkupUpdateNomenclaturePriceSchema>;
}
/**
 * SupplierProductReturn update schema.
 * @export
 * @interface UpdateSupplierProductReturnSchema
 */
export interface UpdateSupplierProductReturnSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'warehouseId': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {Array<ProductReturnNomenclatureFormsetSchema>}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'supplierProductReturnNomenclatures': Array<ProductReturnNomenclatureFormsetSchema>;
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProductReturnSchema
     */
    'supplierDocumentDate'?: string;
}
/**
 * SupplierProforma create schema.
 * @export
 * @interface UpdateSupplierProformaSchema
 */
export interface UpdateSupplierProformaSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProformaSchema
     */
    'responsibleId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProformaSchema
     */
    'comment'?: string;
    /**
     * 2 last year digits for the document number.
     * @type {number}
     * @memberof UpdateSupplierProformaSchema
     */
    'documentNumberYear': number;
    /**
     * Main number for the document number. Required for update
     * @type {number}
     * @memberof UpdateSupplierProformaSchema
     */
    'documentNumberNumber': number;
    /**
     * Main number for the document number.
     * @type {string}
     * @memberof UpdateSupplierProformaSchema
     */
    'documentNumberSuffix'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProformaSchema
     */
    'supplierDocumentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSupplierProformaSchema
     */
    'supplierDocumentDate'?: string;
    /**
     * 
     * @type {Array<ProformaNomenclatureFormsetSchema>}
     * @memberof UpdateSupplierProformaSchema
     */
    'supplierProformaNomenclatures': Array<ProformaNomenclatureFormsetSchema>;
}
/**
 * UserContact schema.
 * @export
 * @interface UserAdditionalContactBaseSchema
 */
export interface UserAdditionalContactBaseSchema {
    /**
     * 
     * @type {string}
     * @memberof UserAdditionalContactBaseSchema
     */
    'position'?: string;
    /**
     * Name
     * @type {string}
     * @memberof UserAdditionalContactBaseSchema
     */
    'name'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof UserAdditionalContactBaseSchema
     */
    'phone'?: string;
    /**
     * Email
     * @type {string}
     * @memberof UserAdditionalContactBaseSchema
     */
    'email'?: string;
}
/**
 * Base user additional contact formset schema.
 * @export
 * @interface UserAdditionalContactFormsetSchema
 */
export interface UserAdditionalContactFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'position'?: string;
    /**
     * Name
     * @type {string}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'name'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'phone'?: string;
    /**
     * Email
     * @type {string}
     * @memberof UserAdditionalContactFormsetSchema
     */
    'email'?: string;
}
/**
 * UserContact schema.
 * @export
 * @interface UserAdditionalContactReadSchema
 */
export interface UserAdditionalContactReadSchema {
    /**
     * 
     * @type {string}
     * @memberof UserAdditionalContactReadSchema
     */
    'position'?: string;
    /**
     * Name
     * @type {string}
     * @memberof UserAdditionalContactReadSchema
     */
    'name'?: string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof UserAdditionalContactReadSchema
     */
    'phone'?: string;
    /**
     * Email
     * @type {string}
     * @memberof UserAdditionalContactReadSchema
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserAdditionalContactReadSchema
     */
    'id': number;
}
/**
 * Class to check the user in the /login endpoint.
 * @export
 * @interface UserCRMLoginSchema
 */
export interface UserCRMLoginSchema {
    /**
     * The user\'s email.
     * @type {string}
     * @memberof UserCRMLoginSchema
     */
    'email': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof UserCRMLoginSchema
     */
    'password': string;
}
/**
 * Create User category schema.
 * @export
 * @interface UserCategoryCreateSchema
 */
export interface UserCategoryCreateSchema {
    /**
     * Name
     * @type {string}
     * @memberof UserCategoryCreateSchema
     */
    'name': string;
    /**
     * Is active
     * @type {boolean}
     * @memberof UserCategoryCreateSchema
     */
    'isActive': boolean;
}
/**
 * UserCategory schema.
 * @export
 * @interface UserCategoryDetailSchema
 */
export interface UserCategoryDetailSchema {
    /**
     * Name
     * @type {string}
     * @memberof UserCategoryDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UserCategoryDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserCategoryDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCategoryDetailSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof UserCategoryDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof UserCategoryDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * UserCategory schema.
 * @export
 * @interface UserCategoryListSchema
 */
export interface UserCategoryListSchema {
    /**
     * Name
     * @type {string}
     * @memberof UserCategoryListSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UserCategoryListSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserCategoryListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCategoryListSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof UserCategoryListSchema
     */
    'hasReferences': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof UserCategoryListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * UserCategories page schema.
 * @export
 * @interface UserCategoryPage
 */
export interface UserCategoryPage {
    /**
     * 
     * @type {Array<UserCategoryListSchema>}
     * @memberof UserCategoryPage
     */
    'items': Array<UserCategoryListSchema>;
    /**
     * 
     * @type {number}
     * @memberof UserCategoryPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof UserCategoryPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserCategoryPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof UserCategoryPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof UserCategoryPage
     */
    'totalPages': number;
}
/**
 * Update User category schema.
 * @export
 * @interface UserCategoryUpdateSchema
 */
export interface UserCategoryUpdateSchema {
    /**
     * Name
     * @type {string}
     * @memberof UserCategoryUpdateSchema
     */
    'name': string;
    /**
     * Is active
     * @type {boolean}
     * @memberof UserCategoryUpdateSchema
     */
    'isActive': boolean;
}
/**
 * User credit limit read schema.
 * @export
 * @interface UserCreditLimitSchemaReadSchema
 */
export interface UserCreditLimitSchemaReadSchema {
    /**
     * 
     * @type {number}
     * @memberof UserCreditLimitSchemaReadSchema
     */
    'creditDepth'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCreditLimitSchemaReadSchema
     */
    'creditSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCreditLimitSchemaReadSchema
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UserCreditLimitSchemaReadSchema
     */
    'availableCreditSum': number;
}
/**
 * User credit limit write schema.
 * @export
 * @interface UserCreditLimitSchemaWriteSchema
 */
export interface UserCreditLimitSchemaWriteSchema {
    /**
     * 
     * @type {number}
     * @memberof UserCreditLimitSchemaWriteSchema
     */
    'creditDepth'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCreditLimitSchemaWriteSchema
     */
    'creditSum'?: number;
}
/**
 * Client currency schema.
 * @export
 * @interface UserCurrencyReadSchema
 */
export interface UserCurrencyReadSchema {
    /**
     * 
     * @type {number}
     * @memberof UserCurrencyReadSchema
     */
    'id': number;
    /**
     * 
     * @type {SelectCurrencySchema}
     * @memberof UserCurrencyReadSchema
     */
    'currency': SelectCurrencySchema;
    /**
     * 
     * @type {boolean}
     * @memberof UserCurrencyReadSchema
     */
    'canBeDeleted': boolean;
    /**
     * 
     * @type {UserCreditLimitSchemaReadSchema}
     * @memberof UserCurrencyReadSchema
     */
    'clientCreditLimit': UserCreditLimitSchemaReadSchema;
    /**
     * 
     * @type {UserCreditLimitSchemaReadSchema}
     * @memberof UserCurrencyReadSchema
     */
    'supplierCreditLimit': UserCreditLimitSchemaReadSchema;
}
/**
 * Base user delivery method schema.
 * @export
 * @interface UserDeliveryFormsetSchema
 */
export interface UserDeliveryFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof UserDeliveryFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserDeliveryFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDeliveryFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * Delivery method.
     * @type {DeliveryMethods}
     * @memberof UserDeliveryFormsetSchema
     */
    'method'?: DeliveryMethods;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryFormsetSchema
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryFormsetSchema
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryFormsetSchema
     */
    'address'?: string;
}
/**
 * User delivery creates schema.
 * @export
 * @interface UserDeliveryMethodCreateSchema
 */
export interface UserDeliveryMethodCreateSchema {
    /**
     * Delivery method.
     * @type {DeliveryMethods}
     * @memberof UserDeliveryMethodCreateSchema
     */
    'method'?: DeliveryMethods;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryMethodCreateSchema
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryMethodCreateSchema
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryMethodCreateSchema
     */
    'address'?: string;
}
/**
 * User delivery read schema.
 * @export
 * @interface UserDeliveryReadSchema
 */
export interface UserDeliveryReadSchema {
    /**
     * Delivery method.
     * @type {DeliveryMethods}
     * @memberof UserDeliveryReadSchema
     */
    'method'?: DeliveryMethods;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryReadSchema
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryReadSchema
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeliveryReadSchema
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserDeliveryReadSchema
     */
    'id': number;
}
/**
 * Simple user schema for proforma.
 * @export
 * @interface UserForSupplierProformaDetailSchema
 */
export interface UserForSupplierProformaDetailSchema {
    /**
     * 
     * @type {string}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'supplierCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {PriceCategorySimpleSchema}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'supplierPriceCategory': PriceCategorySimpleSchema;
    /**
     * 
     * @type {boolean}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'isActiveSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {VatRates}
     * @memberof UserForSupplierProformaDetailSchema
     */
    'vatRate': VatRates;
}
/**
 * Simple user schema for proforma.
 * @export
 * @interface UserForSupplierProformaListSchema
 */
export interface UserForSupplierProformaListSchema {
    /**
     * 
     * @type {string}
     * @memberof UserForSupplierProformaListSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserForSupplierProformaListSchema
     */
    'name': string;
    /**
     * Vat number
     * @type {string}
     * @memberof UserForSupplierProformaListSchema
     */
    'vatNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserForSupplierProformaListSchema
     */
    'avatar'?: string;
    /**
     * 
     * @type {CountrySimpleReadSchema}
     * @memberof UserForSupplierProformaListSchema
     */
    'country': CountrySimpleReadSchema;
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof UserForSupplierProformaListSchema
     */
    'counterAgentKind': CounterAgentKinds;
    /**
     * 
     * @type {SimpleUserCategoryReadSchema}
     * @memberof UserForSupplierProformaListSchema
     */
    'supplierCategory'?: SimpleUserCategoryReadSchema;
    /**
     * 
     * @type {boolean}
     * @memberof UserForSupplierProformaListSchema
     */
    'isActiveSupplier': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserForSupplierProformaListSchema
     */
    'isVatPayer': boolean;
    /**
     * 
     * @type {VatRates}
     * @memberof UserForSupplierProformaListSchema
     */
    'vatRate': VatRates;
}
/**
 * User location schema.
 * @export
 * @interface UserLocationCreateSchema
 */
export interface UserLocationCreateSchema {
    /**
     * User region
     * @type {string}
     * @memberof UserLocationCreateSchema
     */
    'region'?: string;
    /**
     * User city
     * @type {string}
     * @memberof UserLocationCreateSchema
     */
    'city'?: string;
    /**
     * User address
     * @type {string}
     * @memberof UserLocationCreateSchema
     */
    'address'?: string;
}
/**
 * User location formset schema.
 * @export
 * @interface UserLocationFormsetSchema
 */
export interface UserLocationFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof UserLocationFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserLocationFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserLocationFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * User region
     * @type {string}
     * @memberof UserLocationFormsetSchema
     */
    'region'?: string;
    /**
     * User city
     * @type {string}
     * @memberof UserLocationFormsetSchema
     */
    'city'?: string;
    /**
     * User address
     * @type {string}
     * @memberof UserLocationFormsetSchema
     */
    'address'?: string;
}
/**
 * User location read schema.
 * @export
 * @interface UserLocationReadSchema
 */
export interface UserLocationReadSchema {
    /**
     * User region
     * @type {string}
     * @memberof UserLocationReadSchema
     */
    'region'?: string;
    /**
     * User city
     * @type {string}
     * @memberof UserLocationReadSchema
     */
    'city'?: string;
    /**
     * User address
     * @type {string}
     * @memberof UserLocationReadSchema
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserLocationReadSchema
     */
    'id': number;
}
/**
 * UserContact schema.
 * @export
 * @interface UserMainContactBaseReadSchema
 */
export interface UserMainContactBaseReadSchema {
    /**
     * 
     * @type {string}
     * @memberof UserMainContactBaseReadSchema
     */
    'position'?: string;
    /**
     * Name
     * @type {string}
     * @memberof UserMainContactBaseReadSchema
     */
    'name': string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof UserMainContactBaseReadSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof UserMainContactBaseReadSchema
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof UserMainContactBaseReadSchema
     */
    'id': number;
}
/**
 * UserContact schema.
 * @export
 * @interface UserMainContactBaseSchema
 */
export interface UserMainContactBaseSchema {
    /**
     * 
     * @type {string}
     * @memberof UserMainContactBaseSchema
     */
    'position'?: string;
    /**
     * Name
     * @type {string}
     * @memberof UserMainContactBaseSchema
     */
    'name': string;
    /**
     * Phone number field. Django-phonenumber-field used.
     * @type {string}
     * @memberof UserMainContactBaseSchema
     */
    'phone': string;
    /**
     * Email
     * @type {string}
     * @memberof UserMainContactBaseSchema
     */
    'email': string;
}
/**
 * User message page schema.
 * @export
 * @interface UserMessagePage
 */
export interface UserMessagePage {
    /**
     * 
     * @type {Array<UserMessageSchema>}
     * @memberof UserMessagePage
     */
    'items': Array<UserMessageSchema>;
    /**
     * 
     * @type {number}
     * @memberof UserMessagePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof UserMessagePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserMessagePage
     */
    'limit': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserMessagePage
     */
    'offsetId'?: number;
}
/**
 * User message schema.
 * @export
 * @interface UserMessageSchema
 */
export interface UserMessageSchema {
    /**
     * 
     * @type {number}
     * @memberof UserMessageSchema
     */
    'id': number;
    /**
     * 
     * @type {MessageDetailSchema}
     * @memberof UserMessageSchema
     */
    'message': MessageDetailSchema;
}
/**
 * UserNotification list schema.
 * @export
 * @interface UserNotificationListSchema
 */
export interface UserNotificationListSchema {
    /**
     * 
     * @type {number}
     * @memberof UserNotificationListSchema
     */
    'id': number;
    /**
     * 
     * @type {NotificationSchema}
     * @memberof UserNotificationListSchema
     */
    'notification': NotificationSchema;
    /**
     * 
     * @type {boolean}
     * @memberof UserNotificationListSchema
     */
    'isRead': boolean;
}
/**
 * UserNotification page schema.
 * @export
 * @interface UserNotificationPage
 */
export interface UserNotificationPage {
    /**
     * 
     * @type {Array<UserNotificationListSchema>}
     * @memberof UserNotificationPage
     */
    'items': Array<UserNotificationListSchema>;
    /**
     * 
     * @type {number}
     * @memberof UserNotificationPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof UserNotificationPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserNotificationPage
     */
    'limit': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserNotificationPage
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof UserNotificationPage
     */
    'totalWarningCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserNotificationPage
     */
    'totalDangerCount'?: number;
}
/**
 * UserNotification schema.
 * @export
 * @interface UserNotificationSchema
 */
export interface UserNotificationSchema {
    /**
     * 
     * @type {number}
     * @memberof UserNotificationSchema
     */
    'id': number;
    /**
     * 
     * @type {NotificationSchema}
     * @memberof UserNotificationSchema
     */
    'notification': NotificationSchema;
    /**
     * 
     * @type {boolean}
     * @memberof UserNotificationSchema
     */
    'isRead': boolean;
}
/**
 * Client page schema.
 * @export
 * @interface UserPageSchema
 */
export interface UserPageSchema {
    /**
     * 
     * @type {Array<CreatorUserSchema>}
     * @memberof UserPageSchema
     */
    'items': Array<CreatorUserSchema>;
    /**
     * 
     * @type {number}
     * @memberof UserPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof UserPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof UserPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof UserPageSchema
     */
    'totalPages': number;
}
/**
 * Profit user report schema.
 * @export
 * @interface UserProfitReportSchema
 */
export interface UserProfitReportSchema {
    /**
     * 
     * @type {string}
     * @memberof UserProfitReportSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfitReportSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UserProfitReportSchema
     */
    'turnover': number;
    /**
     * 
     * @type {number}
     * @memberof UserProfitReportSchema
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof UserProfitReportSchema
     */
    'profit': number;
    /**
     * 
     * @type {number}
     * @memberof UserProfitReportSchema
     */
    'percentage': number;
}
/**
 * User query order choices.
 * @export
 * @enum {string}
 */

export const UserQueryOrder = {
    DateCreated: 'dateCreated'
} as const;

export type UserQueryOrder = typeof UserQueryOrder[keyof typeof UserQueryOrder];


/**
 * UserSiteCreateSchema schema.
 * @export
 * @interface UserSiteCreateSchema
 */
export interface UserSiteCreateSchema {
    /**
     * 
     * @type {string}
     * @memberof UserSiteCreateSchema
     */
    'site': string;
}
/**
 * UserCreditLimitFormset schema.
 * @export
 * @interface UserSiteFormsetSchema
 */
export interface UserSiteFormsetSchema {
    /**
     * 
     * @type {number}
     * @memberof UserSiteFormsetSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSiteFormsetSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSiteFormsetSchema
     */
    'isBase'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSiteFormsetSchema
     */
    'site': string;
}
/**
 * UserSiteReadSchema schema.
 * @export
 * @interface UserSiteReadSchema
 */
export interface UserSiteReadSchema {
    /**
     * 
     * @type {string}
     * @memberof UserSiteReadSchema
     */
    'site': string;
    /**
     * 
     * @type {number}
     * @memberof UserSiteReadSchema
     */
    'id': number;
}
/**
 * Users statistic schema.
 * @export
 * @interface UserStatisticsSchema
 */
export interface UserStatisticsSchema {
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'creditLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'creditTermDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'creditAvailable': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'creditBalance': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'invoicesConductedCount': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'invoicesConductedSum': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'paymentsSum': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsSchema
     */
    'saldo': number;
    /**
     * 
     * @type {Array<OrderDebtSchema>}
     * @memberof UserStatisticsSchema
     */
    'ordersDebts': Array<OrderDebtSchema>;
}
/**
 * User total unread messages schema.
 * @export
 * @interface UserTotalUnreadMessagesSchema
 */
export interface UserTotalUnreadMessagesSchema {
    /**
     * 
     * @type {number}
     * @memberof UserTotalUnreadMessagesSchema
     */
    'totalUnreadMessages': number;
}
/**
 * User types choices.
 * @export
 * @enum {string}
 */

export const UserTypes = {
    Client: 'client',
    Supplier: 'supplier',
    Agent: 'agent',
    Staff: 'staff'
} as const;

export type UserTypes = typeof UserTypes[keyof typeof UserTypes];


/**
 * Client page schema.
 * @export
 * @interface UserUnclosedDocumentPage
 */
export interface UserUnclosedDocumentPage {
    /**
     * 
     * @type {Array<UserUnclosedDocumentSchema>}
     * @memberof UserUnclosedDocumentPage
     */
    'items': Array<UserUnclosedDocumentSchema>;
    /**
     * 
     * @type {number}
     * @memberof UserUnclosedDocumentPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof UserUnclosedDocumentPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof UserUnclosedDocumentPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof UserUnclosedDocumentPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof UserUnclosedDocumentPage
     */
    'totalPages': number;
}
/**
 * Schema for unclosed documents of a user.
 * @export
 * @interface UserUnclosedDocumentSchema
 */
export interface UserUnclosedDocumentSchema {
    /**
     * 
     * @type {number}
     * @memberof UserUnclosedDocumentSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserUnclosedDocumentSchema
     */
    'documentNumber': string;
    /**
     * 
     * @type {string}
     * @memberof UserUnclosedDocumentSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {UnclosedDocumentTypes}
     * @memberof UserUnclosedDocumentSchema
     */
    'documentType': UnclosedDocumentTypes;
}
/**
 * User unclosed documents and active clients schema.
 * @export
 * @interface UserUnclosedDocumentsAndActiveClientsSchema
 */
export interface UserUnclosedDocumentsAndActiveClientsSchema {
    /**
     * 
     * @type {boolean}
     * @memberof UserUnclosedDocumentsAndActiveClientsSchema
     */
    'hasUnclosedDocuments': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUnclosedDocumentsAndActiveClientsSchema
     */
    'hasActiveClients': boolean;
}
/**
 * All statuses for vat number field.
 * @export
 * @enum {string}
 */

export const VatFieldStatuses = {
    Required: 'required',
    Optional: 'optional',
    Disabled: 'disabled'
} as const;

export type VatFieldStatuses = typeof VatFieldStatuses[keyof typeof VatFieldStatuses];


/**
 * VAT country policy.
 * @export
 * @interface VatNumberPolicy
 */
export interface VatNumberPolicy {
    /**
     * VAT rate. Can be 0 or 22
     * @type {number}
     * @memberof VatNumberPolicy
     */
    'vatRate': number;
    /**
     * If vat field is required, optional or disabled
     * @type {VatFieldStatuses}
     * @memberof VatNumberPolicy
     */
    'vatFieldStatus': VatFieldStatuses;
}
/**
 * Vat rate detail schema.
 * @export
 * @interface VatRateDetailSchema
 */
export interface VatRateDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof VatRateDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VatRateDetailSchema
     */
    'name': string;
    /**
     * 
     * @type {BaseCountrySchema}
     * @memberof VatRateDetailSchema
     */
    'country'?: BaseCountrySchema;
    /**
     * 
     * @type {number}
     * @memberof VatRateDetailSchema
     */
    'rate': number;
    /**
     * 
     * @type {string}
     * @memberof VatRateDetailSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Vat rate list schema.
 * @export
 * @interface VatRateListSchema
 */
export interface VatRateListSchema {
    /**
     * 
     * @type {number}
     * @memberof VatRateListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VatRateListSchema
     */
    'name': string;
    /**
     * 
     * @type {BaseCountrySchema}
     * @memberof VatRateListSchema
     */
    'country'?: BaseCountrySchema;
    /**
     * 
     * @type {number}
     * @memberof VatRateListSchema
     */
    'rate': number;
    /**
     * 
     * @type {string}
     * @memberof VatRateListSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateListSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateListSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Vat rate params mode enum for main page ordering.
 * @export
 * @enum {string}
 */

export const VatRateQueryOrder = {
    Id: 'id',
    DateCreated: 'dateCreated',
    CountryName: 'countryName',
    Rate: 'rate',
    Name: 'name',
    IsActive: 'isActive'
} as const;

export type VatRateQueryOrder = typeof VatRateQueryOrder[keyof typeof VatRateQueryOrder];


/**
 * Vat rate schema.
 * @export
 * @interface VatRateSchema
 */
export interface VatRateSchema {
    /**
     * 
     * @type {number}
     * @memberof VatRateSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VatRateSchema
     */
    'name': string;
    /**
     * 
     * @type {BaseCountrySchema}
     * @memberof VatRateSchema
     */
    'country'?: BaseCountrySchema;
    /**
     * 
     * @type {number}
     * @memberof VatRateSchema
     */
    'rate': number;
    /**
     * 
     * @type {string}
     * @memberof VatRateSchema
     */
    'dateCreated': string;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VatRateSchema
     */
    'isActive': boolean;
}
/**
 * Vat rate update schema.
 * @export
 * @interface VatRateUpdateSchema
 */
export interface VatRateUpdateSchema {
    /**
     * Name of the vat rate
     * @type {string}
     * @memberof VatRateUpdateSchema
     */
    'name': string;
    /**
     * Rate, %
     * @type {number}
     * @memberof VatRateUpdateSchema
     */
    'rate': number;
    /**
     * Vat rate status. Cannot change the status of the base rate
     * @type {boolean}
     * @memberof VatRateUpdateSchema
     */
    'isActive': boolean;
}
/**
 * Vat rates choices.
 * @export
 * @enum {string}
 */

export const VatRates = {
    NUMBER_0: 0,
    NUMBER_22: 22
} as const;

export type VatRates = typeof VatRates[keyof typeof VatRates];


/**
 * Schema for vat rates page.
 * @export
 * @interface VatRatesPage
 */
export interface VatRatesPage {
    /**
     * 
     * @type {Array<VatRateListSchema>}
     * @memberof VatRatesPage
     */
    'items': Array<VatRateListSchema>;
    /**
     * 
     * @type {number}
     * @memberof VatRatesPage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof VatRatesPage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof VatRatesPage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof VatRatesPage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof VatRatesPage
     */
    'totalPages': number;
}
/**
 * VAT validator result schema.
 * @export
 * @interface VatValidatorSuccessResultSchema
 */
export interface VatValidatorSuccessResultSchema {
    /**
     * 
     * @type {string}
     * @memberof VatValidatorSuccessResultSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VatValidatorSuccessResultSchema
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof VatValidatorSuccessResultSchema
     */
    'vatNumber': string;
}
/**
 * Vendor code create schema.
 * @export
 * @interface VendorCodeCreateSchema
 */
export interface VendorCodeCreateSchema {
    /**
     * 
     * @type {number}
     * @memberof VendorCodeCreateSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeCreateSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeCreateSchema
     */
    'isBase'?: boolean;
    /**
     * Vendor code.
     * @type {string}
     * @memberof VendorCodeCreateSchema
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeCreateSchema
     */
    'isActive'?: boolean;
}
/**
 * Vendor code schema for nomenclature List endpoint.
 * @export
 * @interface VendorCodeDetailSchema
 */
export interface VendorCodeDetailSchema {
    /**
     * 
     * @type {number}
     * @memberof VendorCodeDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VendorCodeDetailSchema
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeDetailSchema
     */
    'hasReferences'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeDetailSchema
     */
    'canDelete'?: boolean;
}
/**
 * Vendor code schema for nomenclature List endpoint.
 * @export
 * @interface VendorCodeListSchema
 */
export interface VendorCodeListSchema {
    /**
     * 
     * @type {number}
     * @memberof VendorCodeListSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VendorCodeListSchema
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeListSchema
     */
    'isBase': boolean;
}
/**
 * Vendor code update schema.
 * @export
 * @interface VendorCodeUpdateSchema
 */
export interface VendorCodeUpdateSchema {
    /**
     * 
     * @type {number}
     * @memberof VendorCodeUpdateSchema
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeUpdateSchema
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeUpdateSchema
     */
    'isBase'?: boolean;
    /**
     * Vendor code.
     * @type {string}
     * @memberof VendorCodeUpdateSchema
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorCodeUpdateSchema
     */
    'isActive'?: boolean;
}
/**
 * Create warehouse schema.
 * @export
 * @interface WarehouseCreateSchema
 */
export interface WarehouseCreateSchema {
    /**
     * Warehouse name
     * @type {string}
     * @memberof WarehouseCreateSchema
     */
    'name': string;
    /**
     * Warehouse comment
     * @type {string}
     * @memberof WarehouseCreateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseCreateSchema
     */
    'isActive': boolean;
}
/**
 * Warehouse schema.
 * @export
 * @interface WarehouseDetailSchema
 */
export interface WarehouseDetailSchema {
    /**
     * Warehouse name
     * @type {string}
     * @memberof WarehouseDetailSchema
     */
    'name': string;
    /**
     * Warehouse comment
     * @type {string}
     * @memberof WarehouseDetailSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof WarehouseDetailSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseDetailSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseDetailSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof WarehouseDetailSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof WarehouseDetailSchema
     */
    'hasReferences': boolean;
    /**
     * Has warehouse nomenclature.
     * @type {boolean}
     * @memberof WarehouseDetailSchema
     */
    'hasWarehouseNomenclature': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof WarehouseDetailSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * Warehouse schema.
 * @export
 * @interface WarehouseListSchema
 */
export interface WarehouseListSchema {
    /**
     * Warehouse name
     * @type {string}
     * @memberof WarehouseListSchema
     */
    'name': string;
    /**
     * Warehouse comment
     * @type {string}
     * @memberof WarehouseListSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof WarehouseListSchema
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseListSchema
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseListSchema
     */
    'isBase': boolean;
    /**
     * 
     * @type {string}
     * @memberof WarehouseListSchema
     */
    'dateCreated': string;
    /**
     * Has references from other models.
     * @type {boolean}
     * @memberof WarehouseListSchema
     */
    'hasReferences': boolean;
    /**
     * Has warehouse nomenclature.
     * @type {boolean}
     * @memberof WarehouseListSchema
     */
    'hasWarehouseNomenclature': boolean;
    /**
     * Can be deleted. If False, Cannot be deleted.
     * @type {boolean}
     * @memberof WarehouseListSchema
     */
    'canBeDeleted'?: boolean;
}
/**
 * WarehouseNomenclature schema.
 * @export
 * @interface WarehouseNomenclatureForDynamicColumnsSchema
 */
export interface WarehouseNomenclatureForDynamicColumnsSchema {
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureForDynamicColumnsSchema
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureForDynamicColumnsSchema
     */
    'reserveQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureForDynamicColumnsSchema
     */
    'fullQuantityString'?: string;
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureForDynamicColumnsSchema
     */
    'warehouseId': number;
    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureForDynamicColumnsSchema
     */
    'warehouseName': string;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseNomenclatureForDynamicColumnsSchema
     */
    'warehouseIsBase': boolean;
}
/**
 * Warehouse nomenclature quantity schema.
 * @export
 * @interface WarehouseNomenclatureQuantitySchema
 */
export interface WarehouseNomenclatureQuantitySchema {
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureQuantitySchema
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureQuantitySchema
     */
    'reserveQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureQuantitySchema
     */
    'fullQuantityString'?: string;
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureQuantitySchema
     */
    'nomenclatureId': number;
}
/**
 * PriceCategories page schema.
 * @export
 * @interface WarehousePage
 */
export interface WarehousePage {
    /**
     * 
     * @type {Array<WarehouseListSchema>}
     * @memberof WarehousePage
     */
    'items': Array<WarehouseListSchema>;
    /**
     * 
     * @type {number}
     * @memberof WarehousePage
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof WarehousePage
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof WarehousePage
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof WarehousePage
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof WarehousePage
     */
    'totalPages': number;
}
/**
 * Warehouse query order.
 * @export
 * @enum {string}
 */

export const WarehouseQueryOrder = {
    Default: 'default',
    Id: 'id',
    Name: 'name',
    DateCreated: 'dateCreated',
    Status: 'status'
} as const;

export type WarehouseQueryOrder = typeof WarehouseQueryOrder[keyof typeof WarehouseQueryOrder];


/**
 * Warehouse report row schema.
 * @export
 * @interface WarehouseReportNomenclatureSchema
 */
export interface WarehouseReportNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'vendorCode'?: string;
    /**
     * 
     * @type {BaseBrandSchema}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'brand'?: BaseBrandSchema;
    /**
     * 
     * @type {Array<WarehouseReportWarehouseNomenclatureSchema>}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'warehouseNomenclatures': Array<WarehouseReportWarehouseNomenclatureSchema>;
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'totalQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportNomenclatureSchema
     */
    'totalCostPrice'?: number;
}
/**
 * Warehouse report page schema.
 * @export
 * @interface WarehouseReportPageSchema
 */
export interface WarehouseReportPageSchema {
    /**
     * 
     * @type {Array<WarehouseReportNomenclatureSchema>}
     * @memberof WarehouseReportPageSchema
     */
    'items': Array<WarehouseReportNomenclatureSchema>;
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportPageSchema
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportPageSchema
     */
    'totalCount': number;
    /**
     * Limit per page
     * @type {number}
     * @memberof WarehouseReportPageSchema
     */
    'pageSize': number;
    /**
     * Page number
     * @type {number}
     * @memberof WarehouseReportPageSchema
     */
    'page': number;
    /**
     * Total pages
     * @type {number}
     * @memberof WarehouseReportPageSchema
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<SimpleWarehouseSchema>}
     * @memberof WarehouseReportPageSchema
     */
    'warehouses': Array<SimpleWarehouseSchema>;
}
/**
 * Warehouse report query order enum.
 * @export
 * @enum {string}
 */

export const WarehouseReportQueryOrder = {
    Id: 'id',
    VendorCode: 'vendor_code',
    Name: 'name',
    Brand: 'brand',
    WarehouseQuantity: 'warehouse_quantity',
    WarehouseSumCostPrice: 'warehouse_sum_cost_price',
    TotalQuantity: 'total_quantity',
    TotalSumCostPrice: 'total_sum_cost_price'
} as const;

export type WarehouseReportQueryOrder = typeof WarehouseReportQueryOrder[keyof typeof WarehouseReportQueryOrder];


/**
 * Warehouse report nomenclature row schema.
 * @export
 * @interface WarehouseReportWarehouseNomenclatureSchema
 */
export interface WarehouseReportWarehouseNomenclatureSchema {
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportWarehouseNomenclatureSchema
     */
    'warehouseId': number;
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportWarehouseNomenclatureSchema
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportWarehouseNomenclatureSchema
     */
    'sumCostPrice': number;
}
/**
 * Warehouse stock balances\' schema.
 * @export
 * @interface WarehouseStockBalancesSchema
 */
export interface WarehouseStockBalancesSchema {
    /**
     * 
     * @type {Array<WarehouseNomenclatureQuantitySchema>}
     * @memberof WarehouseStockBalancesSchema
     */
    'warehouseNomenclatures': Array<WarehouseNomenclatureQuantitySchema>;
}
/**
 * Update warehouse schema.
 * @export
 * @interface WarehouseUpdateSchema
 */
export interface WarehouseUpdateSchema {
    /**
     * Warehouse name
     * @type {string}
     * @memberof WarehouseUpdateSchema
     */
    'name': string;
    /**
     * Warehouse comment
     * @type {string}
     * @memberof WarehouseUpdateSchema
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WarehouseUpdateSchema
     */
    'isActive': boolean;
}

/**
 * AccountCashboxReportsApi - axios parameter creator
 * @export
 */
export const AccountCashboxReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export account/cashbox report packaging list data.  Role check: is_staff. Permission: reports_can_view.
         * @summary Export account/cashbox report packaging list data.
         * @param {DataExportType} exportType 
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {boolean} [isCashbox] Filter by type.
         * @param {Array<number>} [accountCashboxIds] Account cashbox ids.
         * @param {Array<number>} [currencyIds] Currency ids.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet: async (exportType: DataExportType, sort?: BaseSort, order?: AccountCashboxReportQueryOrder, dateFrom?: string, dateTo?: string, isCashbox?: boolean, accountCashboxIds?: Array<number>, currencyIds?: Array<number>, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/account-cashboxes/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (isCashbox !== undefined) {
                localVarQueryParameter['isCashbox'] = isCashbox;
            }

            if (accountCashboxIds) {
                localVarQueryParameter['accountCashboxIds'] = accountCashboxIds;
            }

            if (currencyIds) {
                localVarQueryParameter['currencyIds'] = currencyIds;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current reports by bank accounts and cashboxes.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports by bank accounts and cashboxes
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {boolean} [isCashbox] Filter by type.
         * @param {Array<number>} [accountCashboxIds] Account cashbox ids.
         * @param {Array<number>} [currencyIds] Currency ids.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsAccountCashboxesListReportsAccountCashboxesGet: async (page?: number, pageSize?: number, sort?: BaseSort, order?: AccountCashboxReportQueryOrder, dateFrom?: string, dateTo?: string, isCashbox?: boolean, accountCashboxIds?: Array<number>, currencyIds?: Array<number>, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/account-cashboxes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (isCashbox !== undefined) {
                localVarQueryParameter['isCashbox'] = isCashbox;
            }

            if (accountCashboxIds) {
                localVarQueryParameter['accountCashboxIds'] = accountCashboxIds;
            }

            if (currencyIds) {
                localVarQueryParameter['currencyIds'] = currencyIds;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountCashboxReportsApi - functional programming interface
 * @export
 */
export const AccountCashboxReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountCashboxReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export account/cashbox report packaging list data.  Role check: is_staff. Permission: reports_can_view.
         * @summary Export account/cashbox report packaging list data.
         * @param {DataExportType} exportType 
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {boolean} [isCashbox] Filter by type.
         * @param {Array<number>} [accountCashboxIds] Account cashbox ids.
         * @param {Array<number>} [currencyIds] Currency ids.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet(exportType: DataExportType, sort?: BaseSort, order?: AccountCashboxReportQueryOrder, dateFrom?: string, dateTo?: string, isCashbox?: boolean, accountCashboxIds?: Array<number>, currencyIds?: Array<number>, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet(exportType, sort, order, dateFrom, dateTo, isCashbox, accountCashboxIds, currencyIds, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current reports by bank accounts and cashboxes.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports by bank accounts and cashboxes
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {boolean} [isCashbox] Filter by type.
         * @param {Array<number>} [accountCashboxIds] Account cashbox ids.
         * @param {Array<number>} [currencyIds] Currency ids.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsAccountCashboxesListReportsAccountCashboxesGet(page?: number, pageSize?: number, sort?: BaseSort, order?: AccountCashboxReportQueryOrder, dateFrom?: string, dateTo?: string, isCashbox?: boolean, accountCashboxIds?: Array<number>, currencyIds?: Array<number>, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCashboxReportPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsAccountCashboxesListReportsAccountCashboxesGet(page, pageSize, sort, order, dateFrom, dateTo, isCashbox, accountCashboxIds, currencyIds, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountCashboxReportsApi - factory interface
 * @export
 */
export const AccountCashboxReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountCashboxReportsApiFp(configuration)
    return {
        /**
         * Export account/cashbox report packaging list data.  Role check: is_staff. Permission: reports_can_view.
         * @summary Export account/cashbox report packaging list data.
         * @param {DataExportType} exportType 
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {boolean} [isCashbox] Filter by type.
         * @param {Array<number>} [accountCashboxIds] Account cashbox ids.
         * @param {Array<number>} [currencyIds] Currency ids.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet(exportType: DataExportType, sort?: BaseSort, order?: AccountCashboxReportQueryOrder, dateFrom?: string, dateTo?: string, isCashbox?: boolean, accountCashboxIds?: Array<number>, currencyIds?: Array<number>, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet(exportType, sort, order, dateFrom, dateTo, isCashbox, accountCashboxIds, currencyIds, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current reports by bank accounts and cashboxes.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports by bank accounts and cashboxes
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {boolean} [isCashbox] Filter by type.
         * @param {Array<number>} [accountCashboxIds] Account cashbox ids.
         * @param {Array<number>} [currencyIds] Currency ids.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsAccountCashboxesListReportsAccountCashboxesGet(page?: number, pageSize?: number, sort?: BaseSort, order?: AccountCashboxReportQueryOrder, dateFrom?: string, dateTo?: string, isCashbox?: boolean, accountCashboxIds?: Array<number>, currencyIds?: Array<number>, acceptLanguage?: string, options?: any): AxiosPromise<AccountCashboxReportPage> {
            return localVarFp.reportsAccountCashboxesListReportsAccountCashboxesGet(page, pageSize, sort, order, dateFrom, dateTo, isCashbox, accountCashboxIds, currencyIds, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet operation in AccountCashboxReportsApi.
 * @export
 * @interface AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGetRequest
 */
export interface AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {BaseSort}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {AccountCashboxReportQueryOrder}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly order?: AccountCashboxReportQueryOrder

    /**
     * Date from.
     * @type {string}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly dateTo?: string

    /**
     * Filter by type.
     * @type {boolean}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly isCashbox?: boolean

    /**
     * Account cashbox ids.
     * @type {Array<number>}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly accountCashboxIds?: Array<number>

    /**
     * Currency ids.
     * @type {Array<number>}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly currencyIds?: Array<number>

    /**
     * 
     * @type {string}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsAccountCashboxesListReportsAccountCashboxesGet operation in AccountCashboxReportsApi.
 * @export
 * @interface AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGetRequest
 */
export interface AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {AccountCashboxReportQueryOrder}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly order?: AccountCashboxReportQueryOrder

    /**
     * Date from.
     * @type {string}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly dateTo?: string

    /**
     * Filter by type.
     * @type {boolean}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly isCashbox?: boolean

    /**
     * Account cashbox ids.
     * @type {Array<number>}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly accountCashboxIds?: Array<number>

    /**
     * Currency ids.
     * @type {Array<number>}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly currencyIds?: Array<number>

    /**
     * 
     * @type {string}
     * @memberof AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGet
     */
    readonly acceptLanguage?: string
}

/**
 * AccountCashboxReportsApi - object-oriented interface
 * @export
 * @class AccountCashboxReportsApi
 * @extends {BaseAPI}
 */
export class AccountCashboxReportsApi extends BaseAPI {
    /**
     * Export account/cashbox report packaging list data.  Role check: is_staff. Permission: reports_can_view.
     * @summary Export account/cashbox report packaging list data.
     * @param {AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountCashboxReportsApi
     */
    public reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet(requestParameters: AccountCashboxReportsApiReportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGetRequest, options?: AxiosRequestConfig) {
        return AccountCashboxReportsApiFp(this.configuration).reportsAccountCashboxesExportPackagingListReportsAccountCashboxesExportTypeGet(requestParameters.exportType, requestParameters.sort, requestParameters.order, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.isCashbox, requestParameters.accountCashboxIds, requestParameters.currencyIds, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current reports by bank accounts and cashboxes.  Role check: is_staff Permission: reports_can_view
     * @summary Get current reports by bank accounts and cashboxes
     * @param {AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountCashboxReportsApi
     */
    public reportsAccountCashboxesListReportsAccountCashboxesGet(requestParameters: AccountCashboxReportsApiReportsAccountCashboxesListReportsAccountCashboxesGetRequest = {}, options?: AxiosRequestConfig) {
        return AccountCashboxReportsApiFp(this.configuration).reportsAccountCashboxesListReportsAccountCashboxesGet(requestParameters.page, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.isCashbox, requestParameters.accountCashboxIds, requestParameters.currencyIds, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AgentPermissionsApi - axios parameter creator
 * @export
 */
export const AgentPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get agent user permissions.  Role check: is_agent.  Permission: agent_view.
         * @summary List of agent user permissions.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentPermissionsListAgentsPermissionsAgentIdGet: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentPermissionsListAgentsPermissionsAgentIdGet', 'agentId', agentId)
            const localVarPath = `/agents/permissions/{agent_id}/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent user permissions.  Role check: is_agent.  Permission: agent_change.  Superuser permission can\'t be changed (404 error will be raised). Inactive agent user permissions can\'t be changed (404 error will be raised).
         * @summary Update agent user permissions.
         * @param {string} agentId 
         * @param {AgentPermissionsSchema} agentPermissionsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut: async (agentId: string, agentPermissionsSchema: AgentPermissionsSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut', 'agentId', agentId)
            // verify required parameter 'agentPermissionsSchema' is not null or undefined
            assertParamExists('usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut', 'agentPermissionsSchema', agentPermissionsSchema)
            const localVarPath = `/agents/permissions/{agent_id}/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentPermissionsSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentPermissionsApi - functional programming interface
 * @export
 */
export const AgentPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get agent user permissions.  Role check: is_agent.  Permission: agent_view.
         * @summary List of agent user permissions.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentPermissionsListAgentsPermissionsAgentIdGet(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentPermissionsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentPermissionsListAgentsPermissionsAgentIdGet(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agent user permissions.  Role check: is_agent.  Permission: agent_change.  Superuser permission can\'t be changed (404 error will be raised). Inactive agent user permissions can\'t be changed (404 error will be raised).
         * @summary Update agent user permissions.
         * @param {string} agentId 
         * @param {AgentPermissionsSchema} agentPermissionsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut(agentId: string, agentPermissionsSchema: AgentPermissionsSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentPermissionsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut(agentId, agentPermissionsSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AgentPermissionsApi - factory interface
 * @export
 */
export const AgentPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentPermissionsApiFp(configuration)
    return {
        /**
         * Get agent user permissions.  Role check: is_agent.  Permission: agent_view.
         * @summary List of agent user permissions.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentPermissionsListAgentsPermissionsAgentIdGet(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<AgentPermissionsSchema> {
            return localVarFp.usersAgentPermissionsListAgentsPermissionsAgentIdGet(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent user permissions.  Role check: is_agent.  Permission: agent_change.  Superuser permission can\'t be changed (404 error will be raised). Inactive agent user permissions can\'t be changed (404 error will be raised).
         * @summary Update agent user permissions.
         * @param {string} agentId 
         * @param {AgentPermissionsSchema} agentPermissionsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut(agentId: string, agentPermissionsSchema: AgentPermissionsSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentPermissionsSchema> {
            return localVarFp.usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut(agentId, agentPermissionsSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersAgentPermissionsListAgentsPermissionsAgentIdGet operation in AgentPermissionsApi.
 * @export
 * @interface AgentPermissionsApiUsersAgentPermissionsListAgentsPermissionsAgentIdGetRequest
 */
export interface AgentPermissionsApiUsersAgentPermissionsListAgentsPermissionsAgentIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentPermissionsApiUsersAgentPermissionsListAgentsPermissionsAgentIdGet
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentPermissionsApiUsersAgentPermissionsListAgentsPermissionsAgentIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut operation in AgentPermissionsApi.
 * @export
 * @interface AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPutRequest
 */
export interface AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentPermissionsSchema}
     * @memberof AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPut
     */
    readonly agentPermissionsSchema: AgentPermissionsSchema

    /**
     * 
     * @type {string}
     * @memberof AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * AgentPermissionsApi - object-oriented interface
 * @export
 * @class AgentPermissionsApi
 * @extends {BaseAPI}
 */
export class AgentPermissionsApi extends BaseAPI {
    /**
     * Get agent user permissions.  Role check: is_agent.  Permission: agent_view.
     * @summary List of agent user permissions.
     * @param {AgentPermissionsApiUsersAgentPermissionsListAgentsPermissionsAgentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentPermissionsApi
     */
    public usersAgentPermissionsListAgentsPermissionsAgentIdGet(requestParameters: AgentPermissionsApiUsersAgentPermissionsListAgentsPermissionsAgentIdGetRequest, options?: AxiosRequestConfig) {
        return AgentPermissionsApiFp(this.configuration).usersAgentPermissionsListAgentsPermissionsAgentIdGet(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent user permissions.  Role check: is_agent.  Permission: agent_change.  Superuser permission can\'t be changed (404 error will be raised). Inactive agent user permissions can\'t be changed (404 error will be raised).
     * @summary Update agent user permissions.
     * @param {AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentPermissionsApi
     */
    public usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut(requestParameters: AgentPermissionsApiUsersAgentPermissionsUpdateAgentsPermissionsAgentIdPutRequest, options?: AxiosRequestConfig) {
        return AgentPermissionsApiFp(this.configuration).usersAgentPermissionsUpdateAgentsPermissionsAgentIdPut(requestParameters.agentId, requestParameters.agentPermissionsSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if agent has unclosed documents and active clients.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Check if agent has unclosed documents and active clients
         * @param {string} userId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet: async (userId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet', 'userId', userId)
            const localVarPath = `/agents/unclosed-documents-and-active-clients/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Activate staff user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsActivateAgentsAgentIdActivatePut: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsActivateAgentsAgentIdActivatePut', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/activate/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change agent user login.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Change agent user login.
         * @param {string} agentId 
         * @param {AgentUpdateEmailSchema} agentUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsChangeLoginAgentsAgentIdChangeLoginPut: async (agentId: string, agentUpdateEmailSchema: AgentUpdateEmailSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsChangeLoginAgentsAgentIdChangeLoginPut', 'agentId', agentId)
            // verify required parameter 'agentUpdateEmailSchema' is not null or undefined
            assertParamExists('usersAgentsChangeLoginAgentsAgentIdChangeLoginPut', 'agentUpdateEmailSchema', agentUpdateEmailSchema)
            const localVarPath = `/agents/{agent_id}/change-login/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentUpdateEmailSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change agent user phone.  Role check: is_staff.  Permission: crm_change_agent_access  Can be changed only if the status in AgentStatuses.ACTIVE, AgentStatuses.INACTIVE  Send an email with a new phone to an agent.
         * @summary Change agent user phone.
         * @param {string} agentId 
         * @param {AgentUpdatePhoneSchema} agentUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsChangePhoneAgentsAgentIdChangePhonePut: async (agentId: string, agentUpdatePhoneSchema: AgentUpdatePhoneSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsChangePhoneAgentsAgentIdChangePhonePut', 'agentId', agentId)
            // verify required parameter 'agentUpdatePhoneSchema' is not null or undefined
            assertParamExists('usersAgentsChangePhoneAgentsAgentIdChangePhonePut', 'agentUpdatePhoneSchema', agentUpdatePhoneSchema)
            const localVarPath = `/agents/{agent_id}/change-phone/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentUpdatePhoneSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of currencies used by agent clients.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get currencies for agent client statistics.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/client-currencies/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client currencies statistics for agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get client currencies statistics for agent.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/client-currencies-statistics/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Check if user has debts or overpayments.
         * @param {string} agentId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet: async (agentId: string, currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet', 'agentId', agentId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet', 'currencyId', currencyId)
            const localVarPath = `/agents/{agent_id}/client-statistics/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Create agent user.
         * @param {AgentCreateSchema} agentCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsCreateAgentsPost: async (agentCreateSchema: AgentCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentCreateSchema' is not null or undefined
            assertParamExists('usersAgentsCreateAgentsPost', 'agentCreateSchema', agentCreateSchema)
            const localVarPath = `/agents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate agent user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Deactivate agent user.
         * @param {string} agentId 
         * @param {AgentDeactivationSchema} agentDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsDeactivateAgentsAgentIdDeactivatePut: async (agentId: string, agentDeactivationSchema: AgentDeactivationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsDeactivateAgentsAgentIdDeactivatePut', 'agentId', agentId)
            // verify required parameter 'agentDeactivationSchema' is not null or undefined
            assertParamExists('usersAgentsDeactivateAgentsAgentIdDeactivatePut', 'agentDeactivationSchema', agentDeactivationSchema)
            const localVarPath = `/agents/{agent_id}/deactivate/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentDeactivationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Delete \'in processing\' agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsDeleteAgentsAgentIdDeleteDelete: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsDeleteAgentsAgentIdDeleteDelete', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/delete/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate temporary password for agent user.  Role check: is_staff.  Permission: crm_change_agent_access  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for agent user.
         * @param {string} agentId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut: async (agentId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut', 'agentId', agentId)
            // verify required parameter 'generateTemporaryPasswordSchema' is not null or undefined
            assertParamExists('usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut', 'generateTemporaryPasswordSchema', generateTemporaryPasswordSchema)
            const localVarPath = `/agents/{agent_id}/generate-temporary-password/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateTemporaryPasswordSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGetAgentsAgentIdGet: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsGetAgentsAgentIdGet', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent user full info.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user full info.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGetFullInfoAgentsAgentIdFullInfoGet: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsGetFullInfoAgentsAgentIdFullInfoGet', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/full-info/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGetSelectAgentsAgentIdSelectGet: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsGetSelectAgentsAgentIdSelectGet', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/select/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary List of agents users for select.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {AgentQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {AgentStatuses} [agentStatus] 
         * @param {AgentLabels} [label] Agent label.
         * @param {Array<string>} [onlyWithPermissions] Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsListAgentsGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: AgentQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, agentStatus?: AgentStatuses, label?: AgentLabels, onlyWithPermissions?: Array<string>, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (agentStatus !== undefined) {
                localVarQueryParameter['agentStatus'] = agentStatus;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (onlyWithPermissions) {
                localVarQueryParameter['onlyWithPermissions'] = onlyWithPermissions;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary List of agents users for select.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {AgentQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {AgentStatuses} [agentStatus] 
         * @param {AgentLabels} [label] Agent label.
         * @param {Array<string>} [onlyWithPermissions] Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsListSelectAgentsSelectGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: AgentQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, agentStatus?: AgentStatuses, label?: AgentLabels, onlyWithPermissions?: Array<string>, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agents/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (agentStatus !== undefined) {
                localVarQueryParameter['agentStatus'] = agentStatus;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (onlyWithPermissions) {
                localVarQueryParameter['onlyWithPermissions'] = onlyWithPermissions;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send current agent user phone to email after phone change.  Role check: is_staff. Permission: crm_change_agent_access
         * @summary Send current agent user phone to email after phone change.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost: async (agentId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/send-phone-email/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminate agent contract.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Terminate agent contract.
         * @param {string} agentId 
         * @param {AgentContractTerminationSchema} agentContractTerminationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsTerminateAgentsAgentIdTerminateContractPut: async (agentId: string, agentContractTerminationSchema: AgentContractTerminationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsTerminateAgentsAgentIdTerminateContractPut', 'agentId', agentId)
            // verify required parameter 'agentContractTerminationSchema' is not null or undefined
            assertParamExists('usersAgentsTerminateAgentsAgentIdTerminateContractPut', 'agentContractTerminationSchema', agentContractTerminationSchema)
            const localVarPath = `/agents/{agent_id}/terminate-contract/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentContractTerminationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Turn to agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Add agent role to user.
         * @param {string} userId 
         * @param {AgentTurnSchema} agentTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsTurnToAgentAgentsUserIdTurnAgentPut: async (userId: string, agentTurnSchema: AgentTurnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersAgentsTurnToAgentAgentsUserIdTurnAgentPut', 'userId', userId)
            // verify required parameter 'agentTurnSchema' is not null or undefined
            assertParamExists('usersAgentsTurnToAgentAgentsUserIdTurnAgentPut', 'agentTurnSchema', agentTurnSchema)
            const localVarPath = `/agents/{user_id}/turn-agent/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentTurnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update agent user.  Role check: is_staff.  Permission: crm_change_agent_access  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Email/Phone will be changed only if agent status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update agent user.
         * @param {string} agentId 
         * @param {AgentUpdateSchema} agentUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsUpdateAgentsAgentIdPut: async (agentId: string, agentUpdateSchema: AgentUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsUpdateAgentsAgentIdPut', 'agentId', agentId)
            // verify required parameter 'agentUpdateSchema' is not null or undefined
            assertParamExists('usersAgentsUpdateAgentsAgentIdPut', 'agentUpdateSchema', agentUpdateSchema)
            const localVarPath = `/agents/{agent_id}/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change agent user avatar.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Change agent user avatar.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsUpdateAvatarAgentsAgentIdAvatarPut: async (agentId: string, acceptLanguage?: string, avatar?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('usersAgentsUpdateAvatarAgentsAgentIdAvatarPut', 'agentId', agentId)
            const localVarPath = `/agents/{agent_id}/avatar/`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent/staff unclosed documents.  Role check: is_staff. Permission: crm_view_agent_access, crm_change_agent_access
         * @summary Get agent/staff unclosed documents
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUnclosedDocumentsAgentsUnclosedDocumentsGet: async (userId: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUnclosedDocumentsAgentsUnclosedDocumentsGet', 'userId', userId)
            const localVarPath = `/agents/unclosed-documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if agent has unclosed documents and active clients.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Check if agent has unclosed documents and active clients
         * @param {string} userId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet(userId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUnclosedDocumentsAndActiveClientsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet(userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activate agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Activate staff user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsActivateAgentsAgentIdActivatePut(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsActivateAgentsAgentIdActivatePut(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change agent user login.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Change agent user login.
         * @param {string} agentId 
         * @param {AgentUpdateEmailSchema} agentUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsChangeLoginAgentsAgentIdChangeLoginPut(agentId: string, agentUpdateEmailSchema: AgentUpdateEmailSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsChangeLoginAgentsAgentIdChangeLoginPut(agentId, agentUpdateEmailSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change agent user phone.  Role check: is_staff.  Permission: crm_change_agent_access  Can be changed only if the status in AgentStatuses.ACTIVE, AgentStatuses.INACTIVE  Send an email with a new phone to an agent.
         * @summary Change agent user phone.
         * @param {string} agentId 
         * @param {AgentUpdatePhoneSchema} agentUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsChangePhoneAgentsAgentIdChangePhonePut(agentId: string, agentUpdatePhoneSchema: AgentUpdatePhoneSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsChangePhoneAgentsAgentIdChangePhonePut(agentId, agentUpdatePhoneSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of currencies used by agent clients.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get currencies for agent client statistics.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentClientStatisticsCurrenciesSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client currencies statistics for agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get client currencies statistics for agent.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentClientStatisticsForCurrencySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Check if user has debts or overpayments.
         * @param {string} agentId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet(agentId: string, currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoicesDetailedStatisticsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet(agentId, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Create agent user.
         * @param {AgentCreateSchema} agentCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsCreateAgentsPost(agentCreateSchema: AgentCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsCreateAgentsPost(agentCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate agent user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Deactivate agent user.
         * @param {string} agentId 
         * @param {AgentDeactivationSchema} agentDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsDeactivateAgentsAgentIdDeactivatePut(agentId: string, agentDeactivationSchema: AgentDeactivationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsDeactivateAgentsAgentIdDeactivatePut(agentId, agentDeactivationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Delete \'in processing\' agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsDeleteAgentsAgentIdDeleteDelete(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsDeleteAgentsAgentIdDeleteDelete(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate temporary password for agent user.  Role check: is_staff.  Permission: crm_change_agent_access  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for agent user.
         * @param {string} agentId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut(agentId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut(agentId, generateTemporaryPasswordSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsGetAgentsAgentIdGet(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsGetAgentsAgentIdGet(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agent user full info.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user full info.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsGetFullInfoAgentsAgentIdFullInfoGet(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentFullInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsGetFullInfoAgentsAgentIdFullInfoGet(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsGetSelectAgentsAgentIdSelectGet(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleUserSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsGetSelectAgentsAgentIdSelectGet(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary List of agents users for select.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {AgentQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {AgentStatuses} [agentStatus] 
         * @param {AgentLabels} [label] Agent label.
         * @param {Array<string>} [onlyWithPermissions] Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsListAgentsGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: AgentQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, agentStatus?: AgentStatuses, label?: AgentLabels, onlyWithPermissions?: Array<string>, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsListAgentsGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, agentStatus, label, onlyWithPermissions, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary List of agents users for select.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {AgentQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {AgentStatuses} [agentStatus] 
         * @param {AgentLabels} [label] Agent label.
         * @param {Array<string>} [onlyWithPermissions] Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsListSelectAgentsSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: AgentQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, agentStatus?: AgentStatuses, label?: AgentLabels, onlyWithPermissions?: Array<string>, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsListSelectAgentsSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, agentStatus, label, onlyWithPermissions, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send current agent user phone to email after phone change.  Role check: is_staff. Permission: crm_change_agent_access
         * @summary Send current agent user phone to email after phone change.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost(agentId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost(agentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminate agent contract.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Terminate agent contract.
         * @param {string} agentId 
         * @param {AgentContractTerminationSchema} agentContractTerminationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsTerminateAgentsAgentIdTerminateContractPut(agentId: string, agentContractTerminationSchema: AgentContractTerminationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsTerminateAgentsAgentIdTerminateContractPut(agentId, agentContractTerminationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Turn to agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Add agent role to user.
         * @param {string} userId 
         * @param {AgentTurnSchema} agentTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsTurnToAgentAgentsUserIdTurnAgentPut(userId: string, agentTurnSchema: AgentTurnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsTurnToAgentAgentsUserIdTurnAgentPut(userId, agentTurnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update agent user.  Role check: is_staff.  Permission: crm_change_agent_access  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Email/Phone will be changed only if agent status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update agent user.
         * @param {string} agentId 
         * @param {AgentUpdateSchema} agentUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsUpdateAgentsAgentIdPut(agentId: string, agentUpdateSchema: AgentUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsUpdateAgentsAgentIdPut(agentId, agentUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change agent user avatar.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Change agent user avatar.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAgentsUpdateAvatarAgentsAgentIdAvatarPut(agentId: string, acceptLanguage?: string, avatar?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAgentsUpdateAvatarAgentsAgentIdAvatarPut(agentId, acceptLanguage, avatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agent/staff unclosed documents.  Role check: is_staff. Permission: crm_view_agent_access, crm_change_agent_access
         * @summary Get agent/staff unclosed documents
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUnclosedDocumentsAgentsUnclosedDocumentsGet(userId: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUnclosedDocumentPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUnclosedDocumentsAgentsUnclosedDocumentsGet(userId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * Check if agent has unclosed documents and active clients.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Check if agent has unclosed documents and active clients
         * @param {string} userId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet(userId: string, acceptLanguage?: string, options?: any): AxiosPromise<UserUnclosedDocumentsAndActiveClientsSchema> {
            return localVarFp.agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet(userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Activate staff user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsActivateAgentsAgentIdActivatePut(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsActivateAgentsAgentIdActivatePut(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change agent user login.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Change agent user login.
         * @param {string} agentId 
         * @param {AgentUpdateEmailSchema} agentUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsChangeLoginAgentsAgentIdChangeLoginPut(agentId: string, agentUpdateEmailSchema: AgentUpdateEmailSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsChangeLoginAgentsAgentIdChangeLoginPut(agentId, agentUpdateEmailSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change agent user phone.  Role check: is_staff.  Permission: crm_change_agent_access  Can be changed only if the status in AgentStatuses.ACTIVE, AgentStatuses.INACTIVE  Send an email with a new phone to an agent.
         * @summary Change agent user phone.
         * @param {string} agentId 
         * @param {AgentUpdatePhoneSchema} agentUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsChangePhoneAgentsAgentIdChangePhonePut(agentId: string, agentUpdatePhoneSchema: AgentUpdatePhoneSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsChangePhoneAgentsAgentIdChangePhonePut(agentId, agentUpdatePhoneSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of currencies used by agent clients.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get currencies for agent client statistics.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<AgentClientStatisticsCurrenciesSchema> {
            return localVarFp.usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client currencies statistics for agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get client currencies statistics for agent.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<AgentClientStatisticsForCurrencySchema> {
            return localVarFp.usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Check if user has debts or overpayments.
         * @param {string} agentId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet(agentId: string, currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoicesDetailedStatisticsSchema> {
            return localVarFp.usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet(agentId, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Create agent user.
         * @param {AgentCreateSchema} agentCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsCreateAgentsPost(agentCreateSchema: AgentCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsCreateAgentsPost(agentCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate agent user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Deactivate agent user.
         * @param {string} agentId 
         * @param {AgentDeactivationSchema} agentDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsDeactivateAgentsAgentIdDeactivatePut(agentId: string, agentDeactivationSchema: AgentDeactivationSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsDeactivateAgentsAgentIdDeactivatePut(agentId, agentDeactivationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Delete \'in processing\' agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsDeleteAgentsAgentIdDeleteDelete(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersAgentsDeleteAgentsAgentIdDeleteDelete(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate temporary password for agent user.  Role check: is_staff.  Permission: crm_change_agent_access  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for agent user.
         * @param {string} agentId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut(agentId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut(agentId, generateTemporaryPasswordSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGetAgentsAgentIdGet(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsGetAgentsAgentIdGet(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent user full info.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user full info.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGetFullInfoAgentsAgentIdFullInfoGet(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<AgentFullInfoSchema> {
            return localVarFp.usersAgentsGetFullInfoAgentsAgentIdFullInfoGet(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary Get agent user.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsGetSelectAgentsAgentIdSelectGet(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<SimpleUserSchema> {
            return localVarFp.usersAgentsGetSelectAgentsAgentIdSelectGet(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary List of agents users for select.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {AgentQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {AgentStatuses} [agentStatus] 
         * @param {AgentLabels} [label] Agent label.
         * @param {Array<string>} [onlyWithPermissions] Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsListAgentsGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: AgentQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, agentStatus?: AgentStatuses, label?: AgentLabels, onlyWithPermissions?: Array<string>, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<AgentPage> {
            return localVarFp.usersAgentsListAgentsGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, agentStatus, label, onlyWithPermissions, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
         * @summary List of agents users for select.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {AgentQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {AgentStatuses} [agentStatus] 
         * @param {AgentLabels} [label] Agent label.
         * @param {Array<string>} [onlyWithPermissions] Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsListSelectAgentsSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: AgentQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, agentStatus?: AgentStatuses, label?: AgentLabels, onlyWithPermissions?: Array<string>, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<AgentSimplePage> {
            return localVarFp.usersAgentsListSelectAgentsSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, agentStatus, label, onlyWithPermissions, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Send current agent user phone to email after phone change.  Role check: is_staff. Permission: crm_change_agent_access
         * @summary Send current agent user phone to email after phone change.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost(agentId: string, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost(agentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminate agent contract.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Terminate agent contract.
         * @param {string} agentId 
         * @param {AgentContractTerminationSchema} agentContractTerminationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsTerminateAgentsAgentIdTerminateContractPut(agentId: string, agentContractTerminationSchema: AgentContractTerminationSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsTerminateAgentsAgentIdTerminateContractPut(agentId, agentContractTerminationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Turn to agent user.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Add agent role to user.
         * @param {string} userId 
         * @param {AgentTurnSchema} agentTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsTurnToAgentAgentsUserIdTurnAgentPut(userId: string, agentTurnSchema: AgentTurnSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsTurnToAgentAgentsUserIdTurnAgentPut(userId, agentTurnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update agent user.  Role check: is_staff.  Permission: crm_change_agent_access  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Email/Phone will be changed only if agent status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update agent user.
         * @param {string} agentId 
         * @param {AgentUpdateSchema} agentUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsUpdateAgentsAgentIdPut(agentId: string, agentUpdateSchema: AgentUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsUpdateAgentsAgentIdPut(agentId, agentUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change agent user avatar.  Role check: is_staff.  Permission: crm_change_agent_access
         * @summary Change agent user avatar.
         * @param {string} agentId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAgentsUpdateAvatarAgentsAgentIdAvatarPut(agentId: string, acceptLanguage?: string, avatar?: File, options?: any): AxiosPromise<AgentSchema> {
            return localVarFp.usersAgentsUpdateAvatarAgentsAgentIdAvatarPut(agentId, acceptLanguage, avatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent/staff unclosed documents.  Role check: is_staff. Permission: crm_view_agent_access, crm_change_agent_access
         * @summary Get agent/staff unclosed documents
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUnclosedDocumentsAgentsUnclosedDocumentsGet(userId: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserUnclosedDocumentPage> {
            return localVarFp.usersUnclosedDocumentsAgentsUnclosedDocumentsGet(userId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet operation in AgentsApi.
 * @export
 * @interface AgentsApiAgentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGetRequest
 */
export interface AgentsApiAgentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiAgentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiAgentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsActivateAgentsAgentIdActivatePut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsActivateAgentsAgentIdActivatePutRequest
 */
export interface AgentsApiUsersAgentsActivateAgentsAgentIdActivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsActivateAgentsAgentIdActivatePut
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsActivateAgentsAgentIdActivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsChangeLoginAgentsAgentIdChangeLoginPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPutRequest
 */
export interface AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentUpdateEmailSchema}
     * @memberof AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPut
     */
    readonly agentUpdateEmailSchema: AgentUpdateEmailSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsChangePhoneAgentsAgentIdChangePhonePut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePutRequest
 */
export interface AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentUpdatePhoneSchema}
     * @memberof AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePut
     */
    readonly agentUpdatePhoneSchema: AgentUpdatePhoneSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGetRequest
 */
export interface AgentsApiUsersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGetRequest
 */
export interface AgentsApiUsersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGetRequest
 */
export interface AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet
     */
    readonly agentId: string

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsCreateAgentsPost operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsCreateAgentsPostRequest
 */
export interface AgentsApiUsersAgentsCreateAgentsPostRequest {
    /**
     * 
     * @type {AgentCreateSchema}
     * @memberof AgentsApiUsersAgentsCreateAgentsPost
     */
    readonly agentCreateSchema: AgentCreateSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsCreateAgentsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsDeactivateAgentsAgentIdDeactivatePut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePutRequest
 */
export interface AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentDeactivationSchema}
     * @memberof AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePut
     */
    readonly agentDeactivationSchema: AgentDeactivationSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsDeleteAgentsAgentIdDeleteDelete operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsDeleteAgentsAgentIdDeleteDeleteRequest
 */
export interface AgentsApiUsersAgentsDeleteAgentsAgentIdDeleteDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsDeleteAgentsAgentIdDeleteDelete
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsDeleteAgentsAgentIdDeleteDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPutRequest
 */
export interface AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut
     */
    readonly agentId: string

    /**
     * 
     * @type {GenerateTemporaryPasswordSchema}
     * @memberof AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut
     */
    readonly generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsGetAgentsAgentIdGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsGetAgentsAgentIdGetRequest
 */
export interface AgentsApiUsersAgentsGetAgentsAgentIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGetAgentsAgentIdGet
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGetAgentsAgentIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsGetFullInfoAgentsAgentIdFullInfoGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsGetFullInfoAgentsAgentIdFullInfoGetRequest
 */
export interface AgentsApiUsersAgentsGetFullInfoAgentsAgentIdFullInfoGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGetFullInfoAgentsAgentIdFullInfoGet
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGetFullInfoAgentsAgentIdFullInfoGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsGetSelectAgentsAgentIdSelectGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsGetSelectAgentsAgentIdSelectGetRequest
 */
export interface AgentsApiUsersAgentsGetSelectAgentsAgentIdSelectGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGetSelectAgentsAgentIdSelectGet
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsGetSelectAgentsAgentIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsListAgentsGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsListAgentsGetRequest
 */
export interface AgentsApiUsersAgentsListAgentsGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {AgentQueryOrder}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly order?: AgentQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {AgentStatuses}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly agentStatus?: AgentStatuses

    /**
     * Agent label.
     * @type {AgentLabels}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly label?: AgentLabels

    /**
     * Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
     * @type {Array<string>}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly onlyWithPermissions?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsListAgentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsListSelectAgentsSelectGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsListSelectAgentsSelectGetRequest
 */
export interface AgentsApiUsersAgentsListSelectAgentsSelectGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {AgentQueryOrder}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly order?: AgentQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {AgentStatuses}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly agentStatus?: AgentStatuses

    /**
     * Agent label.
     * @type {AgentLabels}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly label?: AgentLabels

    /**
     * Only agents with specified permission will be returned. Used for agent select for clients.Use \&#39;agent_view_set_as_personal_agent\&#39; for this purpose.
     * @type {Array<string>}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly onlyWithPermissions?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsListSelectAgentsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPostRequest
 */
export interface AgentsApiUsersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsTerminateAgentsAgentIdTerminateContractPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPutRequest
 */
export interface AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentContractTerminationSchema}
     * @memberof AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPut
     */
    readonly agentContractTerminationSchema: AgentContractTerminationSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsTurnToAgentAgentsUserIdTurnAgentPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPutRequest
 */
export interface AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPut
     */
    readonly userId: string

    /**
     * 
     * @type {AgentTurnSchema}
     * @memberof AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPut
     */
    readonly agentTurnSchema: AgentTurnSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsUpdateAgentsAgentIdPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsUpdateAgentsAgentIdPutRequest
 */
export interface AgentsApiUsersAgentsUpdateAgentsAgentIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsUpdateAgentsAgentIdPut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentUpdateSchema}
     * @memberof AgentsApiUsersAgentsUpdateAgentsAgentIdPut
     */
    readonly agentUpdateSchema: AgentUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsUpdateAgentsAgentIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAgentsUpdateAvatarAgentsAgentIdAvatarPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPutRequest
 */
export interface AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPut
     */
    readonly agentId: string

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPut
     */
    readonly acceptLanguage?: string

    /**
     * Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
     * @type {File}
     * @memberof AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPut
     */
    readonly avatar?: File
}

/**
 * Request parameters for usersUnclosedDocumentsAgentsUnclosedDocumentsGet operation in AgentsApi.
 * @export
 * @interface AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGetRequest
 */
export interface AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGet
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * Check if agent has unclosed documents and active clients.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Check if agent has unclosed documents and active clients
     * @param {AgentsApiAgentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet(requestParameters: AgentsApiAgentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsUnclosedDocumentsAndActiveClientsAgentsUnclosedDocumentsAndActiveClientsUserIdGet(requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate agent user.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Activate staff user.
     * @param {AgentsApiUsersAgentsActivateAgentsAgentIdActivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsActivateAgentsAgentIdActivatePut(requestParameters: AgentsApiUsersAgentsActivateAgentsAgentIdActivatePutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsActivateAgentsAgentIdActivatePut(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change agent user login.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Change agent user login.
     * @param {AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsChangeLoginAgentsAgentIdChangeLoginPut(requestParameters: AgentsApiUsersAgentsChangeLoginAgentsAgentIdChangeLoginPutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsChangeLoginAgentsAgentIdChangeLoginPut(requestParameters.agentId, requestParameters.agentUpdateEmailSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change agent user phone.  Role check: is_staff.  Permission: crm_change_agent_access  Can be changed only if the status in AgentStatuses.ACTIVE, AgentStatuses.INACTIVE  Send an email with a new phone to an agent.
     * @summary Change agent user phone.
     * @param {AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsChangePhoneAgentsAgentIdChangePhonePut(requestParameters: AgentsApiUsersAgentsChangePhoneAgentsAgentIdChangePhonePutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsChangePhoneAgentsAgentIdChangePhonePut(requestParameters.agentId, requestParameters.agentUpdatePhoneSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of currencies used by agent clients.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Get currencies for agent client statistics.
     * @param {AgentsApiUsersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet(requestParameters: AgentsApiUsersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsClientCurrenciesAgentsAgentIdClientCurrenciesGet(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client currencies statistics for agent.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Get client currencies statistics for agent.
     * @param {AgentsApiUsersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet(requestParameters: AgentsApiUsersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsClientCurrenciesStatisticsAgentsAgentIdClientCurrenciesStatisticsGet(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Check if user has debts or overpayments.
     * @param {AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet(requestParameters: AgentsApiUsersAgentsClientStatisticsAgentsAgentIdClientStatisticsGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsClientStatisticsAgentsAgentIdClientStatisticsGet(requestParameters.agentId, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create staff user.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Create agent user.
     * @param {AgentsApiUsersAgentsCreateAgentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsCreateAgentsPost(requestParameters: AgentsApiUsersAgentsCreateAgentsPostRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsCreateAgentsPost(requestParameters.agentCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate agent user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Deactivate agent user.
     * @param {AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsDeactivateAgentsAgentIdDeactivatePut(requestParameters: AgentsApiUsersAgentsDeactivateAgentsAgentIdDeactivatePutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsDeactivateAgentsAgentIdDeactivatePut(requestParameters.agentId, requestParameters.agentDeactivationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete agent user.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Delete \'in processing\' agent user.
     * @param {AgentsApiUsersAgentsDeleteAgentsAgentIdDeleteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsDeleteAgentsAgentIdDeleteDelete(requestParameters: AgentsApiUsersAgentsDeleteAgentsAgentIdDeleteDeleteRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsDeleteAgentsAgentIdDeleteDelete(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate temporary password for agent user.  Role check: is_staff.  Permission: crm_change_agent_access  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
     * @summary Generate temporary password for agent user.
     * @param {AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut(requestParameters: AgentsApiUsersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsGenerateTemporaryPasswordAgentsAgentIdGenerateTemporaryPasswordPut(requestParameters.agentId, requestParameters.generateTemporaryPasswordSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Get agent user.
     * @param {AgentsApiUsersAgentsGetAgentsAgentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsGetAgentsAgentIdGet(requestParameters: AgentsApiUsersAgentsGetAgentsAgentIdGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsGetAgentsAgentIdGet(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent user full info.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Get agent user full info.
     * @param {AgentsApiUsersAgentsGetFullInfoAgentsAgentIdFullInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsGetFullInfoAgentsAgentIdFullInfoGet(requestParameters: AgentsApiUsersAgentsGetFullInfoAgentsAgentIdFullInfoGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsGetFullInfoAgentsAgentIdFullInfoGet(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary Get agent user.
     * @param {AgentsApiUsersAgentsGetSelectAgentsAgentIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsGetSelectAgentsAgentIdSelectGet(requestParameters: AgentsApiUsersAgentsGetSelectAgentsAgentIdSelectGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsGetSelectAgentsAgentIdSelectGet(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary List of agents users for select.
     * @param {AgentsApiUsersAgentsListAgentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsListAgentsGet(requestParameters: AgentsApiUsersAgentsListAgentsGetRequest = {}, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsListAgentsGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.counterAgentKind, requestParameters.agentStatus, requestParameters.label, requestParameters.onlyWithPermissions, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agents\' users.  Role check: is_staff.  Permission: crm_view_agent_access
     * @summary List of agents users for select.
     * @param {AgentsApiUsersAgentsListSelectAgentsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsListSelectAgentsSelectGet(requestParameters: AgentsApiUsersAgentsListSelectAgentsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsListSelectAgentsSelectGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.counterAgentKind, requestParameters.agentStatus, requestParameters.label, requestParameters.onlyWithPermissions, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send current agent user phone to email after phone change.  Role check: is_staff. Permission: crm_change_agent_access
     * @summary Send current agent user phone to email after phone change.
     * @param {AgentsApiUsersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost(requestParameters: AgentsApiUsersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPostRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsSendPhoneEmailAgentsAgentIdSendPhoneEmailPost(requestParameters.agentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminate agent contract.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Terminate agent contract.
     * @param {AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsTerminateAgentsAgentIdTerminateContractPut(requestParameters: AgentsApiUsersAgentsTerminateAgentsAgentIdTerminateContractPutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsTerminateAgentsAgentIdTerminateContractPut(requestParameters.agentId, requestParameters.agentContractTerminationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Turn to agent user.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Add agent role to user.
     * @param {AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsTurnToAgentAgentsUserIdTurnAgentPut(requestParameters: AgentsApiUsersAgentsTurnToAgentAgentsUserIdTurnAgentPutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsTurnToAgentAgentsUserIdTurnAgentPut(requestParameters.userId, requestParameters.agentTurnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update agent user.  Role check: is_staff.  Permission: crm_change_agent_access  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Email/Phone will be changed only if agent status in [IN_PROCESSING, UNCONFIRMED]
     * @summary Update agent user.
     * @param {AgentsApiUsersAgentsUpdateAgentsAgentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsUpdateAgentsAgentIdPut(requestParameters: AgentsApiUsersAgentsUpdateAgentsAgentIdPutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsUpdateAgentsAgentIdPut(requestParameters.agentId, requestParameters.agentUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change agent user avatar.  Role check: is_staff.  Permission: crm_change_agent_access
     * @summary Change agent user avatar.
     * @param {AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersAgentsUpdateAvatarAgentsAgentIdAvatarPut(requestParameters: AgentsApiUsersAgentsUpdateAvatarAgentsAgentIdAvatarPutRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersAgentsUpdateAvatarAgentsAgentIdAvatarPut(requestParameters.agentId, requestParameters.acceptLanguage, requestParameters.avatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent/staff unclosed documents.  Role check: is_staff. Permission: crm_view_agent_access, crm_change_agent_access
     * @summary Get agent/staff unclosed documents
     * @param {AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public usersUnclosedDocumentsAgentsUnclosedDocumentsGet(requestParameters: AgentsApiUsersUnclosedDocumentsAgentsUnclosedDocumentsGetRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).usersUnclosedDocumentsAgentsUnclosedDocumentsGet(requestParameters.userId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login to the CRM system. Only for staff users. Rate limited.
         * @summary Login to the CRM system. Only for staff users.
         * @param {UserCRMLoginSchema} userCRMLoginSchema 
         * @param {string} [acceptLanguage] 
         * @param {any} [securityToken]          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
         * @param {string} [recaptchaToken]              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginToCrmAuthLoginCrmPost: async (userCRMLoginSchema: UserCRMLoginSchema, acceptLanguage?: string, securityToken?: any, recaptchaToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCRMLoginSchema' is not null or undefined
            assertParamExists('authLoginToCrmAuthLoginCrmPost', 'userCRMLoginSchema', userCRMLoginSchema)
            const localVarPath = `/auth/login/crm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }

            if (securityToken != null) {
                localVarHeaderParameter['security-token'] = typeof securityToken === 'string' 
                    ? securityToken 
                    : JSON.stringify(securityToken);
            }

            if (recaptchaToken != null) {
                localVarHeaderParameter['recaptcha-token'] = String(recaptchaToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCRMLoginSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout from the system. Call it on frontend logout.
         * @summary Logout from the system. Only used for backend statistics/logs. Not invalidate tokens.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutAuthLogoutPost: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh access_token from refresh_token.
         * @summary Refresh tokens
         * @param {RefreshTokenSchema} refreshTokenSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshAuthRefreshPost: async (refreshTokenSchema: RefreshTokenSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenSchema' is not null or undefined
            assertParamExists('authRefreshAuthRefreshPost', 'refreshTokenSchema', refreshTokenSchema)
            const localVarPath = `/auth/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send new password on staff email. Does not require authentication. Rate limited.
         * @summary Send temporary password on staff email.
         * @param {string} email 
         * @param {string} [acceptLanguage] 
         * @param {any} [securityToken]          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
         * @param {string} [recaptchaToken]              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTempPasswordCrmAuthTempPasswordCrmEmailPost: async (email: string, acceptLanguage?: string, securityToken?: any, recaptchaToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authTempPasswordCrmAuthTempPasswordCrmEmailPost', 'email', email)
            const localVarPath = `/auth/temp-password/crm/{email}/`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }

            if (securityToken != null) {
                localVarHeaderParameter['security-token'] = typeof securityToken === 'string' 
                    ? securityToken 
                    : JSON.stringify(securityToken);
            }

            if (recaptchaToken != null) {
                localVarHeaderParameter['recaptcha-token'] = String(recaptchaToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Login to the CRM system. Only for staff users. Rate limited.
         * @summary Login to the CRM system. Only for staff users.
         * @param {UserCRMLoginSchema} userCRMLoginSchema 
         * @param {string} [acceptLanguage] 
         * @param {any} [securityToken]          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
         * @param {string} [recaptchaToken]              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginToCrmAuthLoginCrmPost(userCRMLoginSchema: UserCRMLoginSchema, acceptLanguage?: string, securityToken?: any, recaptchaToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAuthLoginToCrmAuthLoginCrmPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginToCrmAuthLoginCrmPost(userCRMLoginSchema, acceptLanguage, securityToken, recaptchaToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logout from the system. Call it on frontend logout.
         * @summary Logout from the system. Only used for backend statistics/logs. Not invalidate tokens.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutAuthLogoutPost(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutAuthLogoutPost(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh access_token from refresh_token.
         * @summary Refresh tokens
         * @param {RefreshTokenSchema} refreshTokenSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshAuthRefreshPost(refreshTokenSchema: RefreshTokenSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRefreshTokensSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshAuthRefreshPost(refreshTokenSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send new password on staff email. Does not require authentication. Rate limited.
         * @summary Send temporary password on staff email.
         * @param {string} email 
         * @param {string} [acceptLanguage] 
         * @param {any} [securityToken]          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
         * @param {string} [recaptchaToken]              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTempPasswordCrmAuthTempPasswordCrmEmailPost(email: string, acceptLanguage?: string, securityToken?: any, recaptchaToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTempPasswordCrmAuthTempPasswordCrmEmailPost(email, acceptLanguage, securityToken, recaptchaToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Login to the CRM system. Only for staff users. Rate limited.
         * @summary Login to the CRM system. Only for staff users.
         * @param {UserCRMLoginSchema} userCRMLoginSchema 
         * @param {string} [acceptLanguage] 
         * @param {any} [securityToken]          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
         * @param {string} [recaptchaToken]              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginToCrmAuthLoginCrmPost(userCRMLoginSchema: UserCRMLoginSchema, acceptLanguage?: string, securityToken?: any, recaptchaToken?: string, options?: any): AxiosPromise<ResponseAuthLoginToCrmAuthLoginCrmPost> {
            return localVarFp.authLoginToCrmAuthLoginCrmPost(userCRMLoginSchema, acceptLanguage, securityToken, recaptchaToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout from the system. Call it on frontend logout.
         * @summary Logout from the system. Only used for backend statistics/logs. Not invalidate tokens.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutAuthLogoutPost(acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.authLogoutAuthLogoutPost(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh access_token from refresh_token.
         * @summary Refresh tokens
         * @param {RefreshTokenSchema} refreshTokenSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshAuthRefreshPost(refreshTokenSchema: RefreshTokenSchema, acceptLanguage?: string, options?: any): AxiosPromise<AccessRefreshTokensSchema> {
            return localVarFp.authRefreshAuthRefreshPost(refreshTokenSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Send new password on staff email. Does not require authentication. Rate limited.
         * @summary Send temporary password on staff email.
         * @param {string} email 
         * @param {string} [acceptLanguage] 
         * @param {any} [securityToken]          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
         * @param {string} [recaptchaToken]              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTempPasswordCrmAuthTempPasswordCrmEmailPost(email: string, acceptLanguage?: string, securityToken?: any, recaptchaToken?: string, options?: any): AxiosPromise<any> {
            return localVarFp.authTempPasswordCrmAuthTempPasswordCrmEmailPost(email, acceptLanguage, securityToken, recaptchaToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authLoginToCrmAuthLoginCrmPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthLoginToCrmAuthLoginCrmPostRequest
 */
export interface AuthApiAuthLoginToCrmAuthLoginCrmPostRequest {
    /**
     * 
     * @type {UserCRMLoginSchema}
     * @memberof AuthApiAuthLoginToCrmAuthLoginCrmPost
     */
    readonly userCRMLoginSchema: UserCRMLoginSchema

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthLoginToCrmAuthLoginCrmPost
     */
    readonly acceptLanguage?: string

    /**
     *          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
     * @type {any}
     * @memberof AuthApiAuthLoginToCrmAuthLoginCrmPost
     */
    readonly securityToken?: any

    /**
     *              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
     * @type {string}
     * @memberof AuthApiAuthLoginToCrmAuthLoginCrmPost
     */
    readonly recaptchaToken?: string
}

/**
 * Request parameters for authLogoutAuthLogoutPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthLogoutAuthLogoutPostRequest
 */
export interface AuthApiAuthLogoutAuthLogoutPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthLogoutAuthLogoutPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for authRefreshAuthRefreshPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthRefreshAuthRefreshPostRequest
 */
export interface AuthApiAuthRefreshAuthRefreshPostRequest {
    /**
     * 
     * @type {RefreshTokenSchema}
     * @memberof AuthApiAuthRefreshAuthRefreshPost
     */
    readonly refreshTokenSchema: RefreshTokenSchema

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthRefreshAuthRefreshPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for authTempPasswordCrmAuthTempPasswordCrmEmailPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPostRequest
 */
export interface AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPost
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPost
     */
    readonly acceptLanguage?: string

    /**
     *          Security token verification.         If default value exists, then it is used as a super token for testing. Even if you erase it.         Check JS documentation here: https://avada.teamwork.com/app/notebooks/364392         
     * @type {any}
     * @memberof AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPost
     */
    readonly securityToken?: any

    /**
     *              reCAPTCHA v3 token verification.             If default value exists, then it is used as a super token for testing.             Ask developers for API key if you need to test reCAPTCHA.             
     * @type {string}
     * @memberof AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPost
     */
    readonly recaptchaToken?: string
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Login to the CRM system. Only for staff users. Rate limited.
     * @summary Login to the CRM system. Only for staff users.
     * @param {AuthApiAuthLoginToCrmAuthLoginCrmPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginToCrmAuthLoginCrmPost(requestParameters: AuthApiAuthLoginToCrmAuthLoginCrmPostRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginToCrmAuthLoginCrmPost(requestParameters.userCRMLoginSchema, requestParameters.acceptLanguage, requestParameters.securityToken, requestParameters.recaptchaToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout from the system. Call it on frontend logout.
     * @summary Logout from the system. Only used for backend statistics/logs. Not invalidate tokens.
     * @param {AuthApiAuthLogoutAuthLogoutPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutAuthLogoutPost(requestParameters: AuthApiAuthLogoutAuthLogoutPostRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutAuthLogoutPost(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh access_token from refresh_token.
     * @summary Refresh tokens
     * @param {AuthApiAuthRefreshAuthRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshAuthRefreshPost(requestParameters: AuthApiAuthRefreshAuthRefreshPostRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshAuthRefreshPost(requestParameters.refreshTokenSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send new password on staff email. Does not require authentication. Rate limited.
     * @summary Send temporary password on staff email.
     * @param {AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTempPasswordCrmAuthTempPasswordCrmEmailPost(requestParameters: AuthApiAuthTempPasswordCrmAuthTempPasswordCrmEmailPostRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTempPasswordCrmAuthTempPasswordCrmEmailPost(requestParameters.email, requestParameters.acceptLanguage, requestParameters.securityToken, requestParameters.recaptchaToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user chat list.  Role check: is_staff.
         * @summary Get user chat list
         * @param {number} [limit] 
         * @param {number} [offsetId] 
         * @param {string} [search] Search existing chats by user names
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatListChatsGet: async (limit?: number, offsetId?: number, search?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offsetId !== undefined) {
                localVarQueryParameter['offsetId'] = offsetId;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new message.  The new message will be created for existing chat. If chat does not exist, it will be created. You can create new message to client, agent or staff. Can\'t create message to yourself.  Role check: is_staff.
         * @summary Create new message
         * @param {string} recipientId 
         * @param {string} [acceptLanguage] 
         * @param {string} [text] Message text.
         * @param {File} [file] File, not more than 5MB. Supported formats: DOC/XML/PDF/JPG/PNG/GIF/JPEG/XLS/ZIP/RAR/DOCX/XLSX/TXT/CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesCreateChatsMessagesPost: async (recipientId: string, acceptLanguage?: string, text?: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipientId' is not null or undefined
            assertParamExists('chatMessagesCreateChatsMessagesPost', 'recipientId', recipientId)
            const localVarPath = `/chats/messages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (recipientId !== undefined) {
                localVarQueryParameter['recipient_id'] = recipientId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (text !== undefined) { 
                localVarFormParams.append('text', text as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete message.  If last message in chat is deleted, chat will be deleted too.  Role check: \'is_staff\'.
         * @summary Delete message
         * @param {number} userMessageId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesDeleteChatsMessagesUserMessageIdDelete: async (userMessageId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userMessageId' is not null or undefined
            assertParamExists('chatMessagesDeleteChatsMessagesUserMessageIdDelete', 'userMessageId', userMessageId)
            const localVarPath = `/chats/messages/{user_message_id}/`
                .replace(`{${"user_message_id"}}`, encodeURIComponent(String(userMessageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user message list.  Role check: is_staff.
         * @summary Get user message list
         * @param {number} chatId 
         * @param {number} [limit] 
         * @param {number} [offsetId] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesListChatsChatIdMessagesGet: async (chatId: number, limit?: number, offsetId?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatMessagesListChatsChatIdMessagesGet', 'chatId', chatId)
            const localVarPath = `/chats/{chat_id}/messages/`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offsetId !== undefined) {
                localVarQueryParameter['offsetId'] = offsetId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Count unread messages from all chats for request user.  Role check: is_staff.
         * @summary Get user total unread messages
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats/total-unread-messages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update message.  Only text can be updated.  Role check: is_staff.
         * @summary Update message
         * @param {number} userMessageId 
         * @param {MessageUpdateSchema} messageUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesUpdateChatsMessagesUserMessageIdPut: async (userMessageId: number, messageUpdateSchema: MessageUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userMessageId' is not null or undefined
            assertParamExists('chatMessagesUpdateChatsMessagesUserMessageIdPut', 'userMessageId', userMessageId)
            // verify required parameter 'messageUpdateSchema' is not null or undefined
            assertParamExists('chatMessagesUpdateChatsMessagesUserMessageIdPut', 'messageUpdateSchema', messageUpdateSchema)
            const localVarPath = `/chats/messages/{user_message_id}/`
                .replace(`{${"user_message_id"}}`, encodeURIComponent(String(userMessageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user chat list.  Role check: is_staff.
         * @summary Get user chat list
         * @param {number} [limit] 
         * @param {number} [offsetId] 
         * @param {string} [search] Search existing chats by user names
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatListChatsGet(limit?: number, offsetId?: number, search?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatListChatsGet(limit, offsetId, search, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new message.  The new message will be created for existing chat. If chat does not exist, it will be created. You can create new message to client, agent or staff. Can\'t create message to yourself.  Role check: is_staff.
         * @summary Create new message
         * @param {string} recipientId 
         * @param {string} [acceptLanguage] 
         * @param {string} [text] Message text.
         * @param {File} [file] File, not more than 5MB. Supported formats: DOC/XML/PDF/JPG/PNG/GIF/JPEG/XLS/ZIP/RAR/DOCX/XLSX/TXT/CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesCreateChatsMessagesPost(recipientId: string, acceptLanguage?: string, text?: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMessageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatMessagesCreateChatsMessagesPost(recipientId, acceptLanguage, text, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete message.  If last message in chat is deleted, chat will be deleted too.  Role check: \'is_staff\'.
         * @summary Delete message
         * @param {number} userMessageId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesDeleteChatsMessagesUserMessageIdDelete(userMessageId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatMessagesDeleteChatsMessagesUserMessageIdDelete(userMessageId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user message list.  Role check: is_staff.
         * @summary Get user message list
         * @param {number} chatId 
         * @param {number} [limit] 
         * @param {number} [offsetId] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesListChatsChatIdMessagesGet(chatId: number, limit?: number, offsetId?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMessagePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatMessagesListChatsChatIdMessagesGet(chatId, limit, offsetId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Count unread messages from all chats for request user.  Role check: is_staff.
         * @summary Get user total unread messages
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTotalUnreadMessagesSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update message.  Only text can be updated.  Role check: is_staff.
         * @summary Update message
         * @param {number} userMessageId 
         * @param {MessageUpdateSchema} messageUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatMessagesUpdateChatsMessagesUserMessageIdPut(userMessageId: number, messageUpdateSchema: MessageUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMessageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatMessagesUpdateChatsMessagesUserMessageIdPut(userMessageId, messageUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * Get user chat list.  Role check: is_staff.
         * @summary Get user chat list
         * @param {number} [limit] 
         * @param {number} [offsetId] 
         * @param {string} [search] Search existing chats by user names
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatListChatsGet(limit?: number, offsetId?: number, search?: string, acceptLanguage?: string, options?: any): AxiosPromise<ChatPage> {
            return localVarFp.chatListChatsGet(limit, offsetId, search, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new message.  The new message will be created for existing chat. If chat does not exist, it will be created. You can create new message to client, agent or staff. Can\'t create message to yourself.  Role check: is_staff.
         * @summary Create new message
         * @param {string} recipientId 
         * @param {string} [acceptLanguage] 
         * @param {string} [text] Message text.
         * @param {File} [file] File, not more than 5MB. Supported formats: DOC/XML/PDF/JPG/PNG/GIF/JPEG/XLS/ZIP/RAR/DOCX/XLSX/TXT/CSV
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesCreateChatsMessagesPost(recipientId: string, acceptLanguage?: string, text?: string, file?: File, options?: any): AxiosPromise<UserMessageSchema> {
            return localVarFp.chatMessagesCreateChatsMessagesPost(recipientId, acceptLanguage, text, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete message.  If last message in chat is deleted, chat will be deleted too.  Role check: \'is_staff\'.
         * @summary Delete message
         * @param {number} userMessageId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesDeleteChatsMessagesUserMessageIdDelete(userMessageId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.chatMessagesDeleteChatsMessagesUserMessageIdDelete(userMessageId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user message list.  Role check: is_staff.
         * @summary Get user message list
         * @param {number} chatId 
         * @param {number} [limit] 
         * @param {number} [offsetId] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesListChatsChatIdMessagesGet(chatId: number, limit?: number, offsetId?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserMessagePage> {
            return localVarFp.chatMessagesListChatsChatIdMessagesGet(chatId, limit, offsetId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Count unread messages from all chats for request user.  Role check: is_staff.
         * @summary Get user total unread messages
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet(acceptLanguage?: string, options?: any): AxiosPromise<UserTotalUnreadMessagesSchema> {
            return localVarFp.chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update message.  Only text can be updated.  Role check: is_staff.
         * @summary Update message
         * @param {number} userMessageId 
         * @param {MessageUpdateSchema} messageUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatMessagesUpdateChatsMessagesUserMessageIdPut(userMessageId: number, messageUpdateSchema: MessageUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<UserMessageSchema> {
            return localVarFp.chatMessagesUpdateChatsMessagesUserMessageIdPut(userMessageId, messageUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for chatListChatsGet operation in ChatsApi.
 * @export
 * @interface ChatsApiChatListChatsGetRequest
 */
export interface ChatsApiChatListChatsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatListChatsGet
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatListChatsGet
     */
    readonly offsetId?: number

    /**
     * Search existing chats by user names
     * @type {string}
     * @memberof ChatsApiChatListChatsGet
     */
    readonly search?: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatListChatsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for chatMessagesCreateChatsMessagesPost operation in ChatsApi.
 * @export
 * @interface ChatsApiChatMessagesCreateChatsMessagesPostRequest
 */
export interface ChatsApiChatMessagesCreateChatsMessagesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatMessagesCreateChatsMessagesPost
     */
    readonly recipientId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatMessagesCreateChatsMessagesPost
     */
    readonly acceptLanguage?: string

    /**
     * Message text.
     * @type {string}
     * @memberof ChatsApiChatMessagesCreateChatsMessagesPost
     */
    readonly text?: string

    /**
     * File, not more than 5MB. Supported formats: DOC/XML/PDF/JPG/PNG/GIF/JPEG/XLS/ZIP/RAR/DOCX/XLSX/TXT/CSV
     * @type {File}
     * @memberof ChatsApiChatMessagesCreateChatsMessagesPost
     */
    readonly file?: File
}

/**
 * Request parameters for chatMessagesDeleteChatsMessagesUserMessageIdDelete operation in ChatsApi.
 * @export
 * @interface ChatsApiChatMessagesDeleteChatsMessagesUserMessageIdDeleteRequest
 */
export interface ChatsApiChatMessagesDeleteChatsMessagesUserMessageIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatMessagesDeleteChatsMessagesUserMessageIdDelete
     */
    readonly userMessageId: number

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatMessagesDeleteChatsMessagesUserMessageIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for chatMessagesListChatsChatIdMessagesGet operation in ChatsApi.
 * @export
 * @interface ChatsApiChatMessagesListChatsChatIdMessagesGetRequest
 */
export interface ChatsApiChatMessagesListChatsChatIdMessagesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatMessagesListChatsChatIdMessagesGet
     */
    readonly chatId: number

    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatMessagesListChatsChatIdMessagesGet
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatMessagesListChatsChatIdMessagesGet
     */
    readonly offsetId?: number

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatMessagesListChatsChatIdMessagesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet operation in ChatsApi.
 * @export
 * @interface ChatsApiChatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGetRequest
 */
export interface ChatsApiChatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for chatMessagesUpdateChatsMessagesUserMessageIdPut operation in ChatsApi.
 * @export
 * @interface ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPutRequest
 */
export interface ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPut
     */
    readonly userMessageId: number

    /**
     * 
     * @type {MessageUpdateSchema}
     * @memberof ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPut
     */
    readonly messageUpdateSchema: MessageUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     * Get user chat list.  Role check: is_staff.
     * @summary Get user chat list
     * @param {ChatsApiChatListChatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatListChatsGet(requestParameters: ChatsApiChatListChatsGetRequest = {}, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatListChatsGet(requestParameters.limit, requestParameters.offsetId, requestParameters.search, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new message.  The new message will be created for existing chat. If chat does not exist, it will be created. You can create new message to client, agent or staff. Can\'t create message to yourself.  Role check: is_staff.
     * @summary Create new message
     * @param {ChatsApiChatMessagesCreateChatsMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatMessagesCreateChatsMessagesPost(requestParameters: ChatsApiChatMessagesCreateChatsMessagesPostRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatMessagesCreateChatsMessagesPost(requestParameters.recipientId, requestParameters.acceptLanguage, requestParameters.text, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete message.  If last message in chat is deleted, chat will be deleted too.  Role check: \'is_staff\'.
     * @summary Delete message
     * @param {ChatsApiChatMessagesDeleteChatsMessagesUserMessageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatMessagesDeleteChatsMessagesUserMessageIdDelete(requestParameters: ChatsApiChatMessagesDeleteChatsMessagesUserMessageIdDeleteRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatMessagesDeleteChatsMessagesUserMessageIdDelete(requestParameters.userMessageId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user message list.  Role check: is_staff.
     * @summary Get user message list
     * @param {ChatsApiChatMessagesListChatsChatIdMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatMessagesListChatsChatIdMessagesGet(requestParameters: ChatsApiChatMessagesListChatsChatIdMessagesGetRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatMessagesListChatsChatIdMessagesGet(requestParameters.chatId, requestParameters.limit, requestParameters.offsetId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Count unread messages from all chats for request user.  Role check: is_staff.
     * @summary Get user total unread messages
     * @param {ChatsApiChatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet(requestParameters: ChatsApiChatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGetRequest = {}, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatMessagesUnreadMessagesCountChatsTotalUnreadMessagesGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update message.  Only text can be updated.  Role check: is_staff.
     * @summary Update message
     * @param {ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatMessagesUpdateChatsMessagesUserMessageIdPut(requestParameters: ChatsApiChatMessagesUpdateChatsMessagesUserMessageIdPutRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatMessagesUpdateChatsMessagesUserMessageIdPut(requestParameters.userMessageId, requestParameters.messageUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientDebtsReportsApi - axios parameter creator
 * @export
 */
export const ClientDebtsReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get client debts reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get client debts reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {ClientTypes} [clientType] Client type
         * @param {number} [clientCategoryId] Client category id
         * @param {number} [countryId] Country id
         * @param {number} [clientAgentId] Client agent id
         * @param {number} [clientManagerId] Client manager id
         * @param {ClientDebtsReportQueryOrder} [order] Order
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsClientDebtsListReportsClientDebtsGet: async (page?: number, pageSize?: number, searchFilter?: string, clientType?: ClientTypes, clientCategoryId?: number, countryId?: number, clientAgentId?: number, clientManagerId?: number, order?: ClientDebtsReportQueryOrder, sort?: BaseSort, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/client-debts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (clientAgentId !== undefined) {
                localVarQueryParameter['clientAgentId'] = clientAgentId;
            }

            if (clientManagerId !== undefined) {
                localVarQueryParameter['clientManagerId'] = clientManagerId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export countries profit data.
         * @param {DataExportType} exportType 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {ClientTypes} [clientType] Client type
         * @param {number} [clientCategoryId] Client category id
         * @param {number} [countryId] Country id
         * @param {number} [clientAgentId] Client agent id
         * @param {number} [clientManagerId] Client manager id
         * @param {ClientDebtsReportQueryOrder} [order] Order
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitCountriesExportReportsClientDebtsExportTypeGet: async (exportType: DataExportType, searchFilter?: string, clientType?: ClientTypes, clientCategoryId?: number, countryId?: number, clientAgentId?: number, clientManagerId?: number, order?: ClientDebtsReportQueryOrder, sort?: BaseSort, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsProfitCountriesExportReportsClientDebtsExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/client-debts/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (clientAgentId !== undefined) {
                localVarQueryParameter['clientAgentId'] = clientAgentId;
            }

            if (clientManagerId !== undefined) {
                localVarQueryParameter['clientManagerId'] = clientManagerId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientDebtsReportsApi - functional programming interface
 * @export
 */
export const ClientDebtsReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientDebtsReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get client debts reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get client debts reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {ClientTypes} [clientType] Client type
         * @param {number} [clientCategoryId] Client category id
         * @param {number} [countryId] Country id
         * @param {number} [clientAgentId] Client agent id
         * @param {number} [clientManagerId] Client manager id
         * @param {ClientDebtsReportQueryOrder} [order] Order
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsClientDebtsListReportsClientDebtsGet(page?: number, pageSize?: number, searchFilter?: string, clientType?: ClientTypes, clientCategoryId?: number, countryId?: number, clientAgentId?: number, clientManagerId?: number, order?: ClientDebtsReportQueryOrder, sort?: BaseSort, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientDebtsReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsClientDebtsListReportsClientDebtsGet(page, pageSize, searchFilter, clientType, clientCategoryId, countryId, clientAgentId, clientManagerId, order, sort, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export countries profit data.
         * @param {DataExportType} exportType 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {ClientTypes} [clientType] Client type
         * @param {number} [clientCategoryId] Client category id
         * @param {number} [countryId] Country id
         * @param {number} [clientAgentId] Client agent id
         * @param {number} [clientManagerId] Client manager id
         * @param {ClientDebtsReportQueryOrder} [order] Order
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitCountriesExportReportsClientDebtsExportTypeGet(exportType: DataExportType, searchFilter?: string, clientType?: ClientTypes, clientCategoryId?: number, countryId?: number, clientAgentId?: number, clientManagerId?: number, order?: ClientDebtsReportQueryOrder, sort?: BaseSort, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitCountriesExportReportsClientDebtsExportTypeGet(exportType, searchFilter, clientType, clientCategoryId, countryId, clientAgentId, clientManagerId, order, sort, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientDebtsReportsApi - factory interface
 * @export
 */
export const ClientDebtsReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientDebtsReportsApiFp(configuration)
    return {
        /**
         * Get client debts reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get client debts reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {ClientTypes} [clientType] Client type
         * @param {number} [clientCategoryId] Client category id
         * @param {number} [countryId] Country id
         * @param {number} [clientAgentId] Client agent id
         * @param {number} [clientManagerId] Client manager id
         * @param {ClientDebtsReportQueryOrder} [order] Order
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsClientDebtsListReportsClientDebtsGet(page?: number, pageSize?: number, searchFilter?: string, clientType?: ClientTypes, clientCategoryId?: number, countryId?: number, clientAgentId?: number, clientManagerId?: number, order?: ClientDebtsReportQueryOrder, sort?: BaseSort, acceptLanguage?: string, options?: any): AxiosPromise<ClientDebtsReportPageSchema> {
            return localVarFp.reportsClientDebtsListReportsClientDebtsGet(page, pageSize, searchFilter, clientType, clientCategoryId, countryId, clientAgentId, clientManagerId, order, sort, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export countries profit data.
         * @param {DataExportType} exportType 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {ClientTypes} [clientType] Client type
         * @param {number} [clientCategoryId] Client category id
         * @param {number} [countryId] Country id
         * @param {number} [clientAgentId] Client agent id
         * @param {number} [clientManagerId] Client manager id
         * @param {ClientDebtsReportQueryOrder} [order] Order
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitCountriesExportReportsClientDebtsExportTypeGet(exportType: DataExportType, searchFilter?: string, clientType?: ClientTypes, clientCategoryId?: number, countryId?: number, clientAgentId?: number, clientManagerId?: number, order?: ClientDebtsReportQueryOrder, sort?: BaseSort, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsProfitCountriesExportReportsClientDebtsExportTypeGet(exportType, searchFilter, clientType, clientCategoryId, countryId, clientAgentId, clientManagerId, order, sort, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportsClientDebtsListReportsClientDebtsGet operation in ClientDebtsReportsApi.
 * @export
 * @interface ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGetRequest
 */
export interface ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly pageSize?: number

    /**
     * Search filter. vendor code, name
     * @type {string}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly searchFilter?: string

    /**
     * Client type
     * @type {ClientTypes}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly clientType?: ClientTypes

    /**
     * Client category id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly clientCategoryId?: number

    /**
     * Country id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly countryId?: number

    /**
     * Client agent id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly clientAgentId?: number

    /**
     * Client manager id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly clientManagerId?: number

    /**
     * Order
     * @type {ClientDebtsReportQueryOrder}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly order?: ClientDebtsReportQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitCountriesExportReportsClientDebtsExportTypeGet operation in ClientDebtsReportsApi.
 * @export
 * @interface ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGetRequest
 */
export interface ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * Search filter. vendor code, name
     * @type {string}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * Client type
     * @type {ClientTypes}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly clientType?: ClientTypes

    /**
     * Client category id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly clientCategoryId?: number

    /**
     * Country id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly countryId?: number

    /**
     * Client agent id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly clientAgentId?: number

    /**
     * Client manager id
     * @type {number}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly clientManagerId?: number

    /**
     * Order
     * @type {ClientDebtsReportQueryOrder}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly order?: ClientDebtsReportQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * ClientDebtsReportsApi - object-oriented interface
 * @export
 * @class ClientDebtsReportsApi
 * @extends {BaseAPI}
 */
export class ClientDebtsReportsApi extends BaseAPI {
    /**
     * Get client debts reports.  Role check: is_staff Permission: reports_can_view
     * @summary Get client debts reports
     * @param {ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDebtsReportsApi
     */
    public reportsClientDebtsListReportsClientDebtsGet(requestParameters: ClientDebtsReportsApiReportsClientDebtsListReportsClientDebtsGetRequest = {}, options?: AxiosRequestConfig) {
        return ClientDebtsReportsApiFp(this.configuration).reportsClientDebtsListReportsClientDebtsGet(requestParameters.page, requestParameters.pageSize, requestParameters.searchFilter, requestParameters.clientType, requestParameters.clientCategoryId, requestParameters.countryId, requestParameters.clientAgentId, requestParameters.clientManagerId, requestParameters.order, requestParameters.sort, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export countries profit data.
     * @param {ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDebtsReportsApi
     */
    public reportsProfitCountriesExportReportsClientDebtsExportTypeGet(requestParameters: ClientDebtsReportsApiReportsProfitCountriesExportReportsClientDebtsExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ClientDebtsReportsApiFp(this.configuration).reportsProfitCountriesExportReportsClientDebtsExportTypeGet(requestParameters.exportType, requestParameters.searchFilter, requestParameters.clientType, requestParameters.clientCategoryId, requestParameters.countryId, requestParameters.clientAgentId, requestParameters.clientManagerId, requestParameters.order, requestParameters.sort, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Activate client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsActivateClientsClientIdActivatePut: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsActivateClientsClientIdActivatePut', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/activate/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change client user login.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change client user login.
         * @param {string} clientId 
         * @param {ClientUpdateEmailSchema} clientUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsChangeLoginClientsClientIdChangeLoginPut: async (clientId: string, clientUpdateEmailSchema: ClientUpdateEmailSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsChangeLoginClientsClientIdChangeLoginPut', 'clientId', clientId)
            // verify required parameter 'clientUpdateEmailSchema' is not null or undefined
            assertParamExists('usersClientsChangeLoginClientsClientIdChangeLoginPut', 'clientUpdateEmailSchema', clientUpdateEmailSchema)
            const localVarPath = `/clients/{client_id}/change-login/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdateEmailSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change client user phone.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Can be changed only if status in ClientStatuses.ACTIVE, ClientStatuses.INACTIVE
         * @summary Change client user phone.
         * @param {string} clientId 
         * @param {ClientUpdatePhoneSchema} clientUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsChangePhoneClientsClientIdChangePhonePut: async (clientId: string, clientUpdatePhoneSchema: ClientUpdatePhoneSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsChangePhoneClientsClientIdChangePhonePut', 'clientId', clientId)
            // verify required parameter 'clientUpdatePhoneSchema' is not null or undefined
            assertParamExists('usersClientsChangePhoneClientsClientIdChangePhonePut', 'clientUpdatePhoneSchema', clientUpdatePhoneSchema)
            const localVarPath = `/clients/{client_id}/change-phone/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdatePhoneSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  У менеджера выбираемого должны быть права: crm_change_clients, auto_distribution_clients_view + он не должен быть супер-юзером
         * @summary Create client user.
         * @param {ClientCreateSchema} clientCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsCreateClientsPost: async (clientCreateSchema: ClientCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientCreateSchema' is not null or undefined
            assertParamExists('usersClientsCreateClientsPost', 'clientCreateSchema', clientCreateSchema)
            const localVarPath = `/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Deactivate client user.
         * @param {string} clientId 
         * @param {ClientDeactivationSchema} clientDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsDeactivateClientsClientIdDeactivatePut: async (clientId: string, clientDeactivationSchema: ClientDeactivationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsDeactivateClientsClientIdDeactivatePut', 'clientId', clientId)
            // verify required parameter 'clientDeactivationSchema' is not null or undefined
            assertParamExists('usersClientsDeactivateClientsClientIdDeactivatePut', 'clientDeactivationSchema', clientDeactivationSchema)
            const localVarPath = `/clients/{client_id}/deactivate/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientDeactivationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Check if user has debts or overpayments.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/debts-and-overpayments/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Delete \'in processing\' client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsDeleteClientsClientIdDeleteDelete: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsDeleteClientsClientIdDeleteDelete', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/delete/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate temporary password for client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for client user.
         * @param {string} clientId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut: async (clientId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut', 'clientId', clientId)
            // verify required parameter 'generateTemporaryPasswordSchema' is not null or undefined
            assertParamExists('usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut', 'generateTemporaryPasswordSchema', generateTemporaryPasswordSchema)
            const localVarPath = `/clients/{client_id}/generate-temporary-password/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateTemporaryPasswordSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGetClientsClientIdGet: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsGetClientsClientIdGet', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client user full info.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user full info.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGetFullInfoClientsClientIdFullInfoGet: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsGetFullInfoClientsClientIdFullInfoGet', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/full-info/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGetSelectClientsClientIdSelectGet: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsGetSelectClientsClientIdSelectGet', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/select/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of clients users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {ClientQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {ClientTypes} [clientType] 
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] 
         * @param {ClientStatuses} [clientStatus] 
         * @param {string} [clientManagerId] Client manager id. Use for staff clients list (pass current user id).
         * @param {ClientLabels} [label] Client label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsListClientsGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: ClientQueryOrder, sort?: BaseSort, excludeInactive?: boolean, clientType?: ClientTypes, counterAgentKind?: CounterAgentKinds, clientCategoryId?: number, agentId?: string, clientStatus?: ClientStatuses, clientManagerId?: string, label?: ClientLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (clientStatus !== undefined) {
                localVarQueryParameter['clientStatus'] = clientStatus;
            }

            if (clientManagerId !== undefined) {
                localVarQueryParameter['clientManagerId'] = clientManagerId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of clients users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {ClientQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {ClientTypes} [clientType] 
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] 
         * @param {ClientStatuses} [clientStatus] 
         * @param {string} [clientManagerId] Client manager id. Use for staff clients list (pass current user id).
         * @param {ClientLabels} [label] Client label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsListSelectClientsSelectGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: ClientQueryOrder, sort?: BaseSort, excludeInactive?: boolean, clientType?: ClientTypes, counterAgentKind?: CounterAgentKinds, clientCategoryId?: number, agentId?: string, clientStatus?: ClientStatuses, clientManagerId?: string, label?: ClientLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (clientStatus !== undefined) {
                localVarQueryParameter['clientStatus'] = clientStatus;
            }

            if (clientManagerId !== undefined) {
                localVarQueryParameter['clientManagerId'] = clientManagerId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send current client user phone to email after phone change.  Role check: is_staff. Permission: crm_change_clients
         * @summary Send current client user phone to email after phone change.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost: async (clientId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/send-phone-email/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client user statistics.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user statistics.
         * @param {string} clientId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsStatisticsClientsClientIdStatisticsGet: async (clientId: string, currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsStatisticsClientsClientIdStatisticsGet', 'clientId', clientId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('usersClientsStatisticsClientsClientIdStatisticsGet', 'currencyId', currencyId)
            const localVarPath = `/clients/{client_id}/statistics/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Turn to client user.  Role check: is_staff.  Permission: crm_view_clients, crm_change_clients, crm_change_other_manager_client_access
         * @summary Add client role to user.
         * @param {string} userId 
         * @param {ClientTurnSchema} clientTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsTurnToClientClientsUserIdTurnClientPut: async (userId: string, clientTurnSchema: ClientTurnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersClientsTurnToClientClientsUserIdTurnClientPut', 'userId', userId)
            // verify required parameter 'clientTurnSchema' is not null or undefined
            assertParamExists('usersClientsTurnToClientClientsUserIdTurnClientPut', 'clientTurnSchema', clientTurnSchema)
            const localVarPath = `/clients/{user_id}/turn-client/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientTurnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change client user avatar.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change client user avatar.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsUpdateAvatarClientsClientIdAvatarPut: async (clientId: string, acceptLanguage?: string, avatar?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsUpdateAvatarClientsClientIdAvatarPut', 'clientId', clientId)
            const localVarPath = `/clients/{client_id}/avatar/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client user.  Role check: is_staff.  Permission: crm_change_clients  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if client status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update client user.
         * @param {string} clientId 
         * @param {ClientUpdateSchema} clientUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsUpdateClientsClientIdPut: async (clientId: string, clientUpdateSchema: ClientUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('usersClientsUpdateClientsClientIdPut', 'clientId', clientId)
            // verify required parameter 'clientUpdateSchema' is not null or undefined
            assertParamExists('usersClientsUpdateClientsClientIdPut', 'clientUpdateSchema', clientUpdateSchema)
            const localVarPath = `/clients/{client_id}/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Activate client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsActivateClientsClientIdActivatePut(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsActivateClientsClientIdActivatePut(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change client user login.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change client user login.
         * @param {string} clientId 
         * @param {ClientUpdateEmailSchema} clientUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsChangeLoginClientsClientIdChangeLoginPut(clientId: string, clientUpdateEmailSchema: ClientUpdateEmailSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsChangeLoginClientsClientIdChangeLoginPut(clientId, clientUpdateEmailSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change client user phone.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Can be changed only if status in ClientStatuses.ACTIVE, ClientStatuses.INACTIVE
         * @summary Change client user phone.
         * @param {string} clientId 
         * @param {ClientUpdatePhoneSchema} clientUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsChangePhoneClientsClientIdChangePhonePut(clientId: string, clientUpdatePhoneSchema: ClientUpdatePhoneSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsChangePhoneClientsClientIdChangePhonePut(clientId, clientUpdatePhoneSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  У менеджера выбираемого должны быть права: crm_change_clients, auto_distribution_clients_view + он не должен быть супер-юзером
         * @summary Create client user.
         * @param {ClientCreateSchema} clientCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsCreateClientsPost(clientCreateSchema: ClientCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsCreateClientsPost(clientCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Deactivate client user.
         * @param {string} clientId 
         * @param {ClientDeactivationSchema} clientDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsDeactivateClientsClientIdDeactivatePut(clientId: string, clientDeactivationSchema: ClientDeactivationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsDeactivateClientsClientIdDeactivatePut(clientId, clientDeactivationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Check if user has debts or overpayments.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DebtOrOverpaymentSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Delete \'in processing\' client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsDeleteClientsClientIdDeleteDelete(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsDeleteClientsClientIdDeleteDelete(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate temporary password for client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for client user.
         * @param {string} clientId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut(clientId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut(clientId, generateTemporaryPasswordSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsGetClientsClientIdGet(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsGetClientsClientIdGet(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client user full info.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user full info.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsGetFullInfoClientsClientIdFullInfoGet(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientFullInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsGetFullInfoClientsClientIdFullInfoGet(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsGetSelectClientsClientIdSelectGet(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleUserSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsGetSelectClientsClientIdSelectGet(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of clients users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {ClientQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {ClientTypes} [clientType] 
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] 
         * @param {ClientStatuses} [clientStatus] 
         * @param {string} [clientManagerId] Client manager id. Use for staff clients list (pass current user id).
         * @param {ClientLabels} [label] Client label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsListClientsGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: ClientQueryOrder, sort?: BaseSort, excludeInactive?: boolean, clientType?: ClientTypes, counterAgentKind?: CounterAgentKinds, clientCategoryId?: number, agentId?: string, clientStatus?: ClientStatuses, clientManagerId?: string, label?: ClientLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsListClientsGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, clientType, counterAgentKind, clientCategoryId, agentId, clientStatus, clientManagerId, label, currencyId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of clients users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {ClientQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {ClientTypes} [clientType] 
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] 
         * @param {ClientStatuses} [clientStatus] 
         * @param {string} [clientManagerId] Client manager id. Use for staff clients list (pass current user id).
         * @param {ClientLabels} [label] Client label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsListSelectClientsSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: ClientQueryOrder, sort?: BaseSort, excludeInactive?: boolean, clientType?: ClientTypes, counterAgentKind?: CounterAgentKinds, clientCategoryId?: number, agentId?: string, clientStatus?: ClientStatuses, clientManagerId?: string, label?: ClientLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsListSelectClientsSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, clientType, counterAgentKind, clientCategoryId, agentId, clientStatus, clientManagerId, label, currencyId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send current client user phone to email after phone change.  Role check: is_staff. Permission: crm_change_clients
         * @summary Send current client user phone to email after phone change.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost(clientId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost(clientId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client user statistics.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user statistics.
         * @param {string} clientId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsStatisticsClientsClientIdStatisticsGet(clientId: string, currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStatisticsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsStatisticsClientsClientIdStatisticsGet(clientId, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Turn to client user.  Role check: is_staff.  Permission: crm_view_clients, crm_change_clients, crm_change_other_manager_client_access
         * @summary Add client role to user.
         * @param {string} userId 
         * @param {ClientTurnSchema} clientTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsTurnToClientClientsUserIdTurnClientPut(userId: string, clientTurnSchema: ClientTurnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsTurnToClientClientsUserIdTurnClientPut(userId, clientTurnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change client user avatar.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change client user avatar.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsUpdateAvatarClientsClientIdAvatarPut(clientId: string, acceptLanguage?: string, avatar?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsUpdateAvatarClientsClientIdAvatarPut(clientId, acceptLanguage, avatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client user.  Role check: is_staff.  Permission: crm_change_clients  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if client status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update client user.
         * @param {string} clientId 
         * @param {ClientUpdateSchema} clientUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersClientsUpdateClientsClientIdPut(clientId: string, clientUpdateSchema: ClientUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersClientsUpdateClientsClientIdPut(clientId, clientUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientsApiFp(configuration)
    return {
        /**
         * Activate client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Activate client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsActivateClientsClientIdActivatePut(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsActivateClientsClientIdActivatePut(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change client user login.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change client user login.
         * @param {string} clientId 
         * @param {ClientUpdateEmailSchema} clientUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsChangeLoginClientsClientIdChangeLoginPut(clientId: string, clientUpdateEmailSchema: ClientUpdateEmailSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsChangeLoginClientsClientIdChangeLoginPut(clientId, clientUpdateEmailSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change client user phone.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Can be changed only if status in ClientStatuses.ACTIVE, ClientStatuses.INACTIVE
         * @summary Change client user phone.
         * @param {string} clientId 
         * @param {ClientUpdatePhoneSchema} clientUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsChangePhoneClientsClientIdChangePhonePut(clientId: string, clientUpdatePhoneSchema: ClientUpdatePhoneSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsChangePhoneClientsClientIdChangePhonePut(clientId, clientUpdatePhoneSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  У менеджера выбираемого должны быть права: crm_change_clients, auto_distribution_clients_view + он не должен быть супер-юзером
         * @summary Create client user.
         * @param {ClientCreateSchema} clientCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsCreateClientsPost(clientCreateSchema: ClientCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsCreateClientsPost(clientCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Deactivate client user.
         * @param {string} clientId 
         * @param {ClientDeactivationSchema} clientDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsDeactivateClientsClientIdDeactivatePut(clientId: string, clientDeactivationSchema: ClientDeactivationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsDeactivateClientsClientIdDeactivatePut(clientId, clientDeactivationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Check if user has debts or overpayments.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<Array<DebtOrOverpaymentSchema>> {
            return localVarFp.usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Delete \'in processing\' client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsDeleteClientsClientIdDeleteDelete(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersClientsDeleteClientsClientIdDeleteDelete(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate temporary password for client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for client user.
         * @param {string} clientId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut(clientId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut(clientId, generateTemporaryPasswordSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGetClientsClientIdGet(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsGetClientsClientIdGet(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client user full info.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user full info.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGetFullInfoClientsClientIdFullInfoGet(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<ClientFullInfoSchema> {
            return localVarFp.usersClientsGetFullInfoClientsClientIdFullInfoGet(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsGetSelectClientsClientIdSelectGet(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<SimpleUserSchema> {
            return localVarFp.usersClientsGetSelectClientsClientIdSelectGet(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of clients users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {ClientQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {ClientTypes} [clientType] 
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] 
         * @param {ClientStatuses} [clientStatus] 
         * @param {string} [clientManagerId] Client manager id. Use for staff clients list (pass current user id).
         * @param {ClientLabels} [label] Client label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsListClientsGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: ClientQueryOrder, sort?: BaseSort, excludeInactive?: boolean, clientType?: ClientTypes, counterAgentKind?: CounterAgentKinds, clientCategoryId?: number, agentId?: string, clientStatus?: ClientStatuses, clientManagerId?: string, label?: ClientLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientPage> {
            return localVarFp.usersClientsListClientsGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, clientType, counterAgentKind, clientCategoryId, agentId, clientStatus, clientManagerId, label, currencyId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of clients users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {ClientQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {ClientTypes} [clientType] 
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] 
         * @param {ClientStatuses} [clientStatus] 
         * @param {string} [clientManagerId] Client manager id. Use for staff clients list (pass current user id).
         * @param {ClientLabels} [label] Client label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsListSelectClientsSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: ClientQueryOrder, sort?: BaseSort, excludeInactive?: boolean, clientType?: ClientTypes, counterAgentKind?: CounterAgentKinds, clientCategoryId?: number, agentId?: string, clientStatus?: ClientStatuses, clientManagerId?: string, label?: ClientLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientSimplePage> {
            return localVarFp.usersClientsListSelectClientsSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, clientType, counterAgentKind, clientCategoryId, agentId, clientStatus, clientManagerId, label, currencyId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Send current client user phone to email after phone change.  Role check: is_staff. Permission: crm_change_clients
         * @summary Send current client user phone to email after phone change.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost(clientId: string, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost(clientId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client user statistics.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get client user statistics.
         * @param {string} clientId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsStatisticsClientsClientIdStatisticsGet(clientId: string, currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<UserStatisticsSchema> {
            return localVarFp.usersClientsStatisticsClientsClientIdStatisticsGet(clientId, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Turn to client user.  Role check: is_staff.  Permission: crm_view_clients, crm_change_clients, crm_change_other_manager_client_access
         * @summary Add client role to user.
         * @param {string} userId 
         * @param {ClientTurnSchema} clientTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsTurnToClientClientsUserIdTurnClientPut(userId: string, clientTurnSchema: ClientTurnSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsTurnToClientClientsUserIdTurnClientPut(userId, clientTurnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change client user avatar.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change client user avatar.
         * @param {string} clientId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsUpdateAvatarClientsClientIdAvatarPut(clientId: string, acceptLanguage?: string, avatar?: File, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsUpdateAvatarClientsClientIdAvatarPut(clientId, acceptLanguage, avatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client user.  Role check: is_staff.  Permission: crm_change_clients  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if client status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update client user.
         * @param {string} clientId 
         * @param {ClientUpdateSchema} clientUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersClientsUpdateClientsClientIdPut(clientId: string, clientUpdateSchema: ClientUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSchema> {
            return localVarFp.usersClientsUpdateClientsClientIdPut(clientId, clientUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersClientsActivateClientsClientIdActivatePut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsActivateClientsClientIdActivatePutRequest
 */
export interface ClientsApiUsersClientsActivateClientsClientIdActivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsActivateClientsClientIdActivatePut
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsActivateClientsClientIdActivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsChangeLoginClientsClientIdChangeLoginPut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPutRequest
 */
export interface ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPut
     */
    readonly clientId: string

    /**
     * 
     * @type {ClientUpdateEmailSchema}
     * @memberof ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPut
     */
    readonly clientUpdateEmailSchema: ClientUpdateEmailSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsChangePhoneClientsClientIdChangePhonePut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePutRequest
 */
export interface ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePut
     */
    readonly clientId: string

    /**
     * 
     * @type {ClientUpdatePhoneSchema}
     * @memberof ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePut
     */
    readonly clientUpdatePhoneSchema: ClientUpdatePhoneSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsCreateClientsPost operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsCreateClientsPostRequest
 */
export interface ClientsApiUsersClientsCreateClientsPostRequest {
    /**
     * 
     * @type {ClientCreateSchema}
     * @memberof ClientsApiUsersClientsCreateClientsPost
     */
    readonly clientCreateSchema: ClientCreateSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsCreateClientsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsDeactivateClientsClientIdDeactivatePut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePutRequest
 */
export interface ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePut
     */
    readonly clientId: string

    /**
     * 
     * @type {ClientDeactivationSchema}
     * @memberof ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePut
     */
    readonly clientDeactivationSchema: ClientDeactivationSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGetRequest
 */
export interface ClientsApiUsersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsDeleteClientsClientIdDeleteDelete operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsDeleteClientsClientIdDeleteDeleteRequest
 */
export interface ClientsApiUsersClientsDeleteClientsClientIdDeleteDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsDeleteClientsClientIdDeleteDelete
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsDeleteClientsClientIdDeleteDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPutRequest
 */
export interface ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut
     */
    readonly clientId: string

    /**
     * 
     * @type {GenerateTemporaryPasswordSchema}
     * @memberof ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut
     */
    readonly generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsGetClientsClientIdGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsGetClientsClientIdGetRequest
 */
export interface ClientsApiUsersClientsGetClientsClientIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGetClientsClientIdGet
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGetClientsClientIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsGetFullInfoClientsClientIdFullInfoGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsGetFullInfoClientsClientIdFullInfoGetRequest
 */
export interface ClientsApiUsersClientsGetFullInfoClientsClientIdFullInfoGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGetFullInfoClientsClientIdFullInfoGet
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGetFullInfoClientsClientIdFullInfoGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsGetSelectClientsClientIdSelectGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsGetSelectClientsClientIdSelectGetRequest
 */
export interface ClientsApiUsersClientsGetSelectClientsClientIdSelectGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGetSelectClientsClientIdSelectGet
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsGetSelectClientsClientIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsListClientsGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsListClientsGetRequest
 */
export interface ClientsApiUsersClientsListClientsGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {ClientQueryOrder}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly order?: ClientQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly clientCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientStatuses}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly clientStatus?: ClientStatuses

    /**
     * Client manager id. Use for staff clients list (pass current user id).
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly clientManagerId?: string

    /**
     * Client label.
     * @type {ClientLabels}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly label?: ClientLabels

    /**
     * Currency id.
     * @type {number}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsListClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsListSelectClientsSelectGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsListSelectClientsSelectGetRequest
 */
export interface ClientsApiUsersClientsListSelectClientsSelectGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {ClientQueryOrder}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly order?: ClientQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {ClientTypes}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly clientCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientStatuses}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly clientStatus?: ClientStatuses

    /**
     * Client manager id. Use for staff clients list (pass current user id).
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly clientManagerId?: string

    /**
     * Client label.
     * @type {ClientLabels}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly label?: ClientLabels

    /**
     * Currency id.
     * @type {number}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsListSelectClientsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPostRequest
 */
export interface ClientsApiUsersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsStatisticsClientsClientIdStatisticsGet operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGetRequest
 */
export interface ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGet
     */
    readonly clientId: string

    /**
     * 
     * @type {number}
     * @memberof ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsTurnToClientClientsUserIdTurnClientPut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPutRequest
 */
export interface ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPut
     */
    readonly userId: string

    /**
     * 
     * @type {ClientTurnSchema}
     * @memberof ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPut
     */
    readonly clientTurnSchema: ClientTurnSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersClientsUpdateAvatarClientsClientIdAvatarPut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPutRequest
 */
export interface ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPut
     */
    readonly clientId: string

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPut
     */
    readonly acceptLanguage?: string

    /**
     * Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
     * @type {File}
     * @memberof ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPut
     */
    readonly avatar?: File
}

/**
 * Request parameters for usersClientsUpdateClientsClientIdPut operation in ClientsApi.
 * @export
 * @interface ClientsApiUsersClientsUpdateClientsClientIdPutRequest
 */
export interface ClientsApiUsersClientsUpdateClientsClientIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsUpdateClientsClientIdPut
     */
    readonly clientId: string

    /**
     * 
     * @type {ClientUpdateSchema}
     * @memberof ClientsApiUsersClientsUpdateClientsClientIdPut
     */
    readonly clientUpdateSchema: ClientUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ClientsApiUsersClientsUpdateClientsClientIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * Activate client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Activate client user.
     * @param {ClientsApiUsersClientsActivateClientsClientIdActivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsActivateClientsClientIdActivatePut(requestParameters: ClientsApiUsersClientsActivateClientsClientIdActivatePutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsActivateClientsClientIdActivatePut(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change client user login.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Change client user login.
     * @param {ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsChangeLoginClientsClientIdChangeLoginPut(requestParameters: ClientsApiUsersClientsChangeLoginClientsClientIdChangeLoginPutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsChangeLoginClientsClientIdChangeLoginPut(requestParameters.clientId, requestParameters.clientUpdateEmailSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change client user phone.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Can be changed only if status in ClientStatuses.ACTIVE, ClientStatuses.INACTIVE
     * @summary Change client user phone.
     * @param {ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsChangePhoneClientsClientIdChangePhonePut(requestParameters: ClientsApiUsersClientsChangePhoneClientsClientIdChangePhonePutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsChangePhoneClientsClientIdChangePhonePut(requestParameters.clientId, requestParameters.clientUpdatePhoneSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create staff user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  У менеджера выбираемого должны быть права: crm_change_clients, auto_distribution_clients_view + он не должен быть супер-юзером
     * @summary Create client user.
     * @param {ClientsApiUsersClientsCreateClientsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsCreateClientsPost(requestParameters: ClientsApiUsersClientsCreateClientsPostRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsCreateClientsPost(requestParameters.clientCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Deactivate client user.
     * @param {ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsDeactivateClientsClientIdDeactivatePut(requestParameters: ClientsApiUsersClientsDeactivateClientsClientIdDeactivatePutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsDeactivateClientsClientIdDeactivatePut(requestParameters.clientId, requestParameters.clientDeactivationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if user has debts or overpayments.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Check if user has debts or overpayments.
     * @param {ClientsApiUsersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet(requestParameters: ClientsApiUsersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGetRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsDebtsAndOverpaymentsClientsClientIdDebtsAndOverpaymentsGet(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Delete \'in processing\' client user.
     * @param {ClientsApiUsersClientsDeleteClientsClientIdDeleteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsDeleteClientsClientIdDeleteDelete(requestParameters: ClientsApiUsersClientsDeleteClientsClientIdDeleteDeleteRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsDeleteClientsClientIdDeleteDelete(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate temporary password for client user.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
     * @summary Generate temporary password for client user.
     * @param {ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut(requestParameters: ClientsApiUsersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsGenerateTemporaryPasswordClientsClientIdGenerateTemporaryPasswordPut(requestParameters.clientId, requestParameters.generateTemporaryPasswordSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get client user.
     * @param {ClientsApiUsersClientsGetClientsClientIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsGetClientsClientIdGet(requestParameters: ClientsApiUsersClientsGetClientsClientIdGetRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsGetClientsClientIdGet(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client user full info.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get client user full info.
     * @param {ClientsApiUsersClientsGetFullInfoClientsClientIdFullInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsGetFullInfoClientsClientIdFullInfoGet(requestParameters: ClientsApiUsersClientsGetFullInfoClientsClientIdFullInfoGetRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsGetFullInfoClientsClientIdFullInfoGet(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client user.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get client user.
     * @param {ClientsApiUsersClientsGetSelectClientsClientIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsGetSelectClientsClientIdSelectGet(requestParameters: ClientsApiUsersClientsGetSelectClientsClientIdSelectGetRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsGetSelectClientsClientIdSelectGet(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary List of clients users.
     * @param {ClientsApiUsersClientsListClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsListClientsGet(requestParameters: ClientsApiUsersClientsListClientsGetRequest = {}, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsListClientsGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.clientType, requestParameters.counterAgentKind, requestParameters.clientCategoryId, requestParameters.agentId, requestParameters.clientStatus, requestParameters.clientManagerId, requestParameters.label, requestParameters.currencyId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client users.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary List of clients users.
     * @param {ClientsApiUsersClientsListSelectClientsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsListSelectClientsSelectGet(requestParameters: ClientsApiUsersClientsListSelectClientsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsListSelectClientsSelectGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.clientType, requestParameters.counterAgentKind, requestParameters.clientCategoryId, requestParameters.agentId, requestParameters.clientStatus, requestParameters.clientManagerId, requestParameters.label, requestParameters.currencyId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send current client user phone to email after phone change.  Role check: is_staff. Permission: crm_change_clients
     * @summary Send current client user phone to email after phone change.
     * @param {ClientsApiUsersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost(requestParameters: ClientsApiUsersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPostRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsSendPhoneEmailClientsClientIdSendPhoneEmailPost(requestParameters.clientId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client user statistics.  Role check: is_staff.  Permission: crm_view_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get client user statistics.
     * @param {ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsStatisticsClientsClientIdStatisticsGet(requestParameters: ClientsApiUsersClientsStatisticsClientsClientIdStatisticsGetRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsStatisticsClientsClientIdStatisticsGet(requestParameters.clientId, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Turn to client user.  Role check: is_staff.  Permission: crm_view_clients, crm_change_clients, crm_change_other_manager_client_access
     * @summary Add client role to user.
     * @param {ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsTurnToClientClientsUserIdTurnClientPut(requestParameters: ClientsApiUsersClientsTurnToClientClientsUserIdTurnClientPutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsTurnToClientClientsUserIdTurnClientPut(requestParameters.userId, requestParameters.clientTurnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change client user avatar.  Role check: is_staff.  Permission: crm_change_clients  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Change client user avatar.
     * @param {ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsUpdateAvatarClientsClientIdAvatarPut(requestParameters: ClientsApiUsersClientsUpdateAvatarClientsClientIdAvatarPutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsUpdateAvatarClientsClientIdAvatarPut(requestParameters.clientId, requestParameters.acceptLanguage, requestParameters.avatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client user.  Role check: is_staff.  Permission: crm_change_clients  Requires \'crm_change_price_type\' permission to change a price type.  Requires \'crm_change_credit_limit\' permission to change user currencies / credit limits. Just send \'null\' if you don\'t want to change it.  Permission \'crm_change_other_manager_client_access\' needed for any change action on another manager user. Permission \'crm_view_other_manager_client_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if client status in [IN_PROCESSING, UNCONFIRMED]
     * @summary Update client user.
     * @param {ClientsApiUsersClientsUpdateClientsClientIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public usersClientsUpdateClientsClientIdPut(requestParameters: ClientsApiUsersClientsUpdateClientsClientIdPutRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).usersClientsUpdateClientsClientIdPut(requestParameters.clientId, requestParameters.clientUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompensationsApi - axios parameter creator
 * @export
 */
export const CompensationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new compensation.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
         * @summary Create new compensation
         * @param {CompensationCreateSchema} compensationCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsCreateOneCompensationsPost: async (compensationCreateSchema: CompensationCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compensationCreateSchema' is not null or undefined
            assertParamExists('compensationsCreateOneCompensationsPost', 'compensationCreateSchema', compensationCreateSchema)
            const localVarPath = `/compensations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compensationCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compensation detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_warehouse_view_compensation\'.
         * @summary Get compensation detail
         * @param {number} compensationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsGetOneCompensationsCompensationIdGet: async (compensationId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compensationId' is not null or undefined
            assertParamExists('compensationsGetOneCompensationsCompensationIdGet', 'compensationId', compensationId)
            const localVarPath = `/compensations/{compensation_id}/`
                .replace(`{${"compensation_id"}}`, encodeURIComponent(String(compensationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compensation list.  Role check: is_staff.  Permission: crm_warehouse_view_compensation.
         * @summary Get compensation list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {CompensationQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {string} [searchFilter] Search. Filtering by id, documentNumber and contragent(phone, email, name, vat, register).
         * @param {string} [creatorId] Filtering by creator id.
         * @param {string} [responsibleId] Filtering by responsible id.
         * @param {number} [currencyId] Filtering by currency id.
         * @param {CounterAgentKinds} [counterAgentKind] Filtering by counter agent kind.
         * @param {number} [countryId] Filtering by country id.
         * @param {CompensationStatuses} [status] Filtering by status.
         * @param {string} [contragentId] Filtering by contragent id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsListCompensationsGet: async (page?: number, pageSize?: number, order?: CompensationQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, creatorId?: string, responsibleId?: string, currencyId?: number, counterAgentKind?: CounterAgentKinds, countryId?: number, status?: CompensationStatuses, contragentId?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compensations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (contragentId !== undefined) {
                localVarQueryParameter['contragentId'] = contragentId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change compensation status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_warehouse_cancel_compensation\'.  Role needed: \'is_staff\'.
         * @summary Change compensation status to created
         * @param {number} compensationId 
         * @param {CompensationCancellationSchema} compensationCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsUpdateOneCancelCompensationsCompensationIdCancelPut: async (compensationId: number, compensationCancellationSchema: CompensationCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compensationId' is not null or undefined
            assertParamExists('compensationsUpdateOneCancelCompensationsCompensationIdCancelPut', 'compensationId', compensationId)
            // verify required parameter 'compensationCancellationSchema' is not null or undefined
            assertParamExists('compensationsUpdateOneCancelCompensationsCompensationIdCancelPut', 'compensationCancellationSchema', compensationCancellationSchema)
            const localVarPath = `/compensations/{compensation_id}/cancel/`
                .replace(`{${"compensation_id"}}`, encodeURIComponent(String(compensationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compensationCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update compensation. Also, can conduct compensation.  Only for status \"created\".  Perms needed: \'crm_warehouse_change_compensation\'. Conducting compensation: \'crm_warehouse_post_compensation\'.  Role needed: \'is_staff\'.
         * @summary Update client compensation(conduct)
         * @param {number} compensationId 
         * @param {CompensationUpdateSchema} compensationUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsUpdateOneCompensationsCompensationIdPut: async (compensationId: number, compensationUpdateSchema: CompensationUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compensationId' is not null or undefined
            assertParamExists('compensationsUpdateOneCompensationsCompensationIdPut', 'compensationId', compensationId)
            // verify required parameter 'compensationUpdateSchema' is not null or undefined
            assertParamExists('compensationsUpdateOneCompensationsCompensationIdPut', 'compensationUpdateSchema', compensationUpdateSchema)
            const localVarPath = `/compensations/{compensation_id}/`
                .replace(`{${"compensation_id"}}`, encodeURIComponent(String(compensationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compensationUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change compensation status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
         * @summary Change compensation status to deleted
         * @param {number} compensationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut: async (compensationId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compensationId' is not null or undefined
            assertParamExists('compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut', 'compensationId', compensationId)
            const localVarPath = `/compensations/{compensation_id}/delete/`
                .replace(`{${"compensation_id"}}`, encodeURIComponent(String(compensationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export packaging list data.  Role check: is_staff  Permission: \'crm_warehouse_view_compensation\'  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice packaging list data.
         * @param {number} compensationId 
         * @param {DataExportType} exportType 
         * @param {LimitedAcceptLanguage} [exportLanguage] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet: async (compensationId: number, exportType: DataExportType, exportLanguage?: LimitedAcceptLanguage, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compensationId' is not null or undefined
            assertParamExists('crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet', 'compensationId', compensationId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet', 'exportType', exportType)
            const localVarPath = `/compensations/{compensation_id}/compensation/{export_type}/`
                .replace(`{${"compensation_id"}}`, encodeURIComponent(String(compensationId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (exportLanguage !== undefined) {
                localVarQueryParameter['export_language'] = exportLanguage;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompensationsApi - functional programming interface
 * @export
 */
export const CompensationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompensationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new compensation.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
         * @summary Create new compensation
         * @param {CompensationCreateSchema} compensationCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compensationsCreateOneCompensationsPost(compensationCreateSchema: CompensationCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompensationDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compensationsCreateOneCompensationsPost(compensationCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compensation detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_warehouse_view_compensation\'.
         * @summary Get compensation detail
         * @param {number} compensationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compensationsGetOneCompensationsCompensationIdGet(compensationId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompensationDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compensationsGetOneCompensationsCompensationIdGet(compensationId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compensation list.  Role check: is_staff.  Permission: crm_warehouse_view_compensation.
         * @summary Get compensation list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {CompensationQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {string} [searchFilter] Search. Filtering by id, documentNumber and contragent(phone, email, name, vat, register).
         * @param {string} [creatorId] Filtering by creator id.
         * @param {string} [responsibleId] Filtering by responsible id.
         * @param {number} [currencyId] Filtering by currency id.
         * @param {CounterAgentKinds} [counterAgentKind] Filtering by counter agent kind.
         * @param {number} [countryId] Filtering by country id.
         * @param {CompensationStatuses} [status] Filtering by status.
         * @param {string} [contragentId] Filtering by contragent id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compensationsListCompensationsGet(page?: number, pageSize?: number, order?: CompensationQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, creatorId?: string, responsibleId?: string, currencyId?: number, counterAgentKind?: CounterAgentKinds, countryId?: number, status?: CompensationStatuses, contragentId?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompensationPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compensationsListCompensationsGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, searchFilter, creatorId, responsibleId, currencyId, counterAgentKind, countryId, status, contragentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change compensation status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_warehouse_cancel_compensation\'.  Role needed: \'is_staff\'.
         * @summary Change compensation status to created
         * @param {number} compensationId 
         * @param {CompensationCancellationSchema} compensationCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compensationsUpdateOneCancelCompensationsCompensationIdCancelPut(compensationId: number, compensationCancellationSchema: CompensationCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompensationDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compensationsUpdateOneCancelCompensationsCompensationIdCancelPut(compensationId, compensationCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update compensation. Also, can conduct compensation.  Only for status \"created\".  Perms needed: \'crm_warehouse_change_compensation\'. Conducting compensation: \'crm_warehouse_post_compensation\'.  Role needed: \'is_staff\'.
         * @summary Update client compensation(conduct)
         * @param {number} compensationId 
         * @param {CompensationUpdateSchema} compensationUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compensationsUpdateOneCompensationsCompensationIdPut(compensationId: number, compensationUpdateSchema: CompensationUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompensationDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compensationsUpdateOneCompensationsCompensationIdPut(compensationId, compensationUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change compensation status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
         * @summary Change compensation status to deleted
         * @param {number} compensationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut(compensationId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompensationDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut(compensationId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export packaging list data.  Role check: is_staff  Permission: \'crm_warehouse_view_compensation\'  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice packaging list data.
         * @param {number} compensationId 
         * @param {DataExportType} exportType 
         * @param {LimitedAcceptLanguage} [exportLanguage] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet(compensationId: number, exportType: DataExportType, exportLanguage?: LimitedAcceptLanguage, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet(compensationId, exportType, exportLanguage, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompensationsApi - factory interface
 * @export
 */
export const CompensationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompensationsApiFp(configuration)
    return {
        /**
         * Create new compensation.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
         * @summary Create new compensation
         * @param {CompensationCreateSchema} compensationCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsCreateOneCompensationsPost(compensationCreateSchema: CompensationCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<CompensationDetailSchema> {
            return localVarFp.compensationsCreateOneCompensationsPost(compensationCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compensation detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_warehouse_view_compensation\'.
         * @summary Get compensation detail
         * @param {number} compensationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsGetOneCompensationsCompensationIdGet(compensationId: number, acceptLanguage?: string, options?: any): AxiosPromise<CompensationDetailSchema> {
            return localVarFp.compensationsGetOneCompensationsCompensationIdGet(compensationId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compensation list.  Role check: is_staff.  Permission: crm_warehouse_view_compensation.
         * @summary Get compensation list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {CompensationQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {string} [searchFilter] Search. Filtering by id, documentNumber and contragent(phone, email, name, vat, register).
         * @param {string} [creatorId] Filtering by creator id.
         * @param {string} [responsibleId] Filtering by responsible id.
         * @param {number} [currencyId] Filtering by currency id.
         * @param {CounterAgentKinds} [counterAgentKind] Filtering by counter agent kind.
         * @param {number} [countryId] Filtering by country id.
         * @param {CompensationStatuses} [status] Filtering by status.
         * @param {string} [contragentId] Filtering by contragent id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsListCompensationsGet(page?: number, pageSize?: number, order?: CompensationQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, creatorId?: string, responsibleId?: string, currencyId?: number, counterAgentKind?: CounterAgentKinds, countryId?: number, status?: CompensationStatuses, contragentId?: string, acceptLanguage?: string, options?: any): AxiosPromise<CompensationPage> {
            return localVarFp.compensationsListCompensationsGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, searchFilter, creatorId, responsibleId, currencyId, counterAgentKind, countryId, status, contragentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change compensation status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_warehouse_cancel_compensation\'.  Role needed: \'is_staff\'.
         * @summary Change compensation status to created
         * @param {number} compensationId 
         * @param {CompensationCancellationSchema} compensationCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsUpdateOneCancelCompensationsCompensationIdCancelPut(compensationId: number, compensationCancellationSchema: CompensationCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<CompensationDetailSchema> {
            return localVarFp.compensationsUpdateOneCancelCompensationsCompensationIdCancelPut(compensationId, compensationCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update compensation. Also, can conduct compensation.  Only for status \"created\".  Perms needed: \'crm_warehouse_change_compensation\'. Conducting compensation: \'crm_warehouse_post_compensation\'.  Role needed: \'is_staff\'.
         * @summary Update client compensation(conduct)
         * @param {number} compensationId 
         * @param {CompensationUpdateSchema} compensationUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsUpdateOneCompensationsCompensationIdPut(compensationId: number, compensationUpdateSchema: CompensationUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<CompensationDetailSchema> {
            return localVarFp.compensationsUpdateOneCompensationsCompensationIdPut(compensationId, compensationUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change compensation status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
         * @summary Change compensation status to deleted
         * @param {number} compensationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut(compensationId: number, acceptLanguage?: string, options?: any): AxiosPromise<CompensationDetailSchema> {
            return localVarFp.compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut(compensationId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export packaging list data.  Role check: is_staff  Permission: \'crm_warehouse_view_compensation\'  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice packaging list data.
         * @param {number} compensationId 
         * @param {DataExportType} exportType 
         * @param {LimitedAcceptLanguage} [exportLanguage] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet(compensationId: number, exportType: DataExportType, exportLanguage?: LimitedAcceptLanguage, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet(compensationId, exportType, exportLanguage, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for compensationsCreateOneCompensationsPost operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCompensationsCreateOneCompensationsPostRequest
 */
export interface CompensationsApiCompensationsCreateOneCompensationsPostRequest {
    /**
     * 
     * @type {CompensationCreateSchema}
     * @memberof CompensationsApiCompensationsCreateOneCompensationsPost
     */
    readonly compensationCreateSchema: CompensationCreateSchema

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCompensationsCreateOneCompensationsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for compensationsGetOneCompensationsCompensationIdGet operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCompensationsGetOneCompensationsCompensationIdGetRequest
 */
export interface CompensationsApiCompensationsGetOneCompensationsCompensationIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCompensationsGetOneCompensationsCompensationIdGet
     */
    readonly compensationId: number

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCompensationsGetOneCompensationsCompensationIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for compensationsListCompensationsGet operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCompensationsListCompensationsGetRequest
 */
export interface CompensationsApiCompensationsListCompensationsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {CompensationQueryOrder}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly order?: CompensationQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly dateConductionTo?: string

    /**
     * Search. Filtering by id, documentNumber and contragent(phone, email, name, vat, register).
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by creator id.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly creatorId?: string

    /**
     * Filtering by responsible id.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly responsibleId?: string

    /**
     * Filtering by currency id.
     * @type {number}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly currencyId?: number

    /**
     * Filtering by counter agent kind.
     * @type {CounterAgentKinds}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Filtering by country id.
     * @type {number}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly countryId?: number

    /**
     * Filtering by status.
     * @type {CompensationStatuses}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly status?: CompensationStatuses

    /**
     * Filtering by contragent id.
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly contragentId?: string

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCompensationsListCompensationsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for compensationsUpdateOneCancelCompensationsCompensationIdCancelPut operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPutRequest
 */
export interface CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPut
     */
    readonly compensationId: number

    /**
     * 
     * @type {CompensationCancellationSchema}
     * @memberof CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPut
     */
    readonly compensationCancellationSchema: CompensationCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for compensationsUpdateOneCompensationsCompensationIdPut operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPutRequest
 */
export interface CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPut
     */
    readonly compensationId: number

    /**
     * 
     * @type {CompensationUpdateSchema}
     * @memberof CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPut
     */
    readonly compensationUpdateSchema: CompensationUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCompensationsUpdateOneDeleteCompensationsCompensationIdDeletePutRequest
 */
export interface CompensationsApiCompensationsUpdateOneDeleteCompensationsCompensationIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCompensationsUpdateOneDeleteCompensationsCompensationIdDeletePut
     */
    readonly compensationId: number

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCompensationsUpdateOneDeleteCompensationsCompensationIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet operation in CompensationsApi.
 * @export
 * @interface CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGetRequest
 */
export interface CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet
     */
    readonly compensationId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {LimitedAcceptLanguage}
     * @memberof CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet
     */
    readonly exportLanguage?: LimitedAcceptLanguage

    /**
     * 
     * @type {string}
     * @memberof CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * CompensationsApi - object-oriented interface
 * @export
 * @class CompensationsApi
 * @extends {BaseAPI}
 */
export class CompensationsApi extends BaseAPI {
    /**
     * Create new compensation.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
     * @summary Create new compensation
     * @param {CompensationsApiCompensationsCreateOneCompensationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public compensationsCreateOneCompensationsPost(requestParameters: CompensationsApiCompensationsCreateOneCompensationsPostRequest, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).compensationsCreateOneCompensationsPost(requestParameters.compensationCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compensation detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_warehouse_view_compensation\'.
     * @summary Get compensation detail
     * @param {CompensationsApiCompensationsGetOneCompensationsCompensationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public compensationsGetOneCompensationsCompensationIdGet(requestParameters: CompensationsApiCompensationsGetOneCompensationsCompensationIdGetRequest, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).compensationsGetOneCompensationsCompensationIdGet(requestParameters.compensationId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compensation list.  Role check: is_staff.  Permission: crm_warehouse_view_compensation.
     * @summary Get compensation list.
     * @param {CompensationsApiCompensationsListCompensationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public compensationsListCompensationsGet(requestParameters: CompensationsApiCompensationsListCompensationsGetRequest = {}, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).compensationsListCompensationsGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.searchFilter, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.currencyId, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.status, requestParameters.contragentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change compensation status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_warehouse_cancel_compensation\'.  Role needed: \'is_staff\'.
     * @summary Change compensation status to created
     * @param {CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public compensationsUpdateOneCancelCompensationsCompensationIdCancelPut(requestParameters: CompensationsApiCompensationsUpdateOneCancelCompensationsCompensationIdCancelPutRequest, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).compensationsUpdateOneCancelCompensationsCompensationIdCancelPut(requestParameters.compensationId, requestParameters.compensationCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update compensation. Also, can conduct compensation.  Only for status \"created\".  Perms needed: \'crm_warehouse_change_compensation\'. Conducting compensation: \'crm_warehouse_post_compensation\'.  Role needed: \'is_staff\'.
     * @summary Update client compensation(conduct)
     * @param {CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public compensationsUpdateOneCompensationsCompensationIdPut(requestParameters: CompensationsApiCompensationsUpdateOneCompensationsCompensationIdPutRequest, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).compensationsUpdateOneCompensationsCompensationIdPut(requestParameters.compensationId, requestParameters.compensationUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change compensation status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_warehouse_change_compensation\'.  Role needed: \'is_staff\'.
     * @summary Change compensation status to deleted
     * @param {CompensationsApiCompensationsUpdateOneDeleteCompensationsCompensationIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut(requestParameters: CompensationsApiCompensationsUpdateOneDeleteCompensationsCompensationIdDeletePutRequest, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).compensationsUpdateOneDeleteCompensationsCompensationIdDeletePut(requestParameters.compensationId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export packaging list data.  Role check: is_staff  Permission: \'crm_warehouse_view_compensation\'  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
     * @summary Export client invoice packaging list data.
     * @param {CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompensationsApi
     */
    public crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet(requestParameters: CompensationsApiCrmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGetRequest, options?: AxiosRequestConfig) {
        return CompensationsApiFp(this.configuration).crmClientInvoiceExportPackagingListCompensationsCompensationIdCompensationExportTypeGet(requestParameters.compensationId, requestParameters.exportType, requestParameters.exportLanguage, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractTemplatesClientApi - axios parameter creator
 * @export
 */
export const ContractTemplatesClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract templates
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesClientsListContractTemplatesClientsGet: async (contractType: ContractTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('contractTemplatesClientsListContractTemplatesClientsGet', 'contractType', contractType)
            const localVarPath = `/contract-templates/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create or update client contract template
         * @param {File} file Docx file, not more than 20MB.
         * @param {ContractTemplateLanguage} language 
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesClientsUpdateContractTemplatesClientsPost: async (file: File, language: ContractTemplateLanguage, contractType: ContractTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('contractTemplatesClientsUpdateContractTemplatesClientsPost', 'file', file)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('contractTemplatesClientsUpdateContractTemplatesClientsPost', 'language', language)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('contractTemplatesClientsUpdateContractTemplatesClientsPost', 'contractType', contractType)
            const localVarPath = `/contract-templates/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', new Blob([JSON.stringify(language)], { type: "application/json", }));
            }
    
            if (contractType !== undefined) { 
                localVarFormParams.append('contractType', new Blob([JSON.stringify(contractType)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractTemplatesClientApi - functional programming interface
 * @export
 */
export const ContractTemplatesClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractTemplatesClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract templates
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractTemplatesClientsListContractTemplatesClientsGet(contractType: ContractTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractTemplateWithFileReadSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractTemplatesClientsListContractTemplatesClientsGet(contractType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create or update client contract template
         * @param {File} file Docx file, not more than 20MB.
         * @param {ContractTemplateLanguage} language 
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractTemplatesClientsUpdateContractTemplatesClientsPost(file: File, language: ContractTemplateLanguage, contractType: ContractTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractTemplateWithFileReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractTemplatesClientsUpdateContractTemplatesClientsPost(file, language, contractType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractTemplatesClientApi - factory interface
 * @export
 */
export const ContractTemplatesClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractTemplatesClientApiFp(configuration)
    return {
        /**
         * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract templates
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesClientsListContractTemplatesClientsGet(contractType: ContractTypes, acceptLanguage?: string, options?: any): AxiosPromise<Array<ContractTemplateWithFileReadSchema>> {
            return localVarFp.contractTemplatesClientsListContractTemplatesClientsGet(contractType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create or update client contract template
         * @param {File} file Docx file, not more than 20MB.
         * @param {ContractTemplateLanguage} language 
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesClientsUpdateContractTemplatesClientsPost(file: File, language: ContractTemplateLanguage, contractType: ContractTypes, acceptLanguage?: string, options?: any): AxiosPromise<ContractTemplateWithFileReadSchema> {
            return localVarFp.contractTemplatesClientsUpdateContractTemplatesClientsPost(file, language, contractType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractTemplatesClientsListContractTemplatesClientsGet operation in ContractTemplatesClientApi.
 * @export
 * @interface ContractTemplatesClientApiContractTemplatesClientsListContractTemplatesClientsGetRequest
 */
export interface ContractTemplatesClientApiContractTemplatesClientsListContractTemplatesClientsGetRequest {
    /**
     * 
     * @type {ContractTypes}
     * @memberof ContractTemplatesClientApiContractTemplatesClientsListContractTemplatesClientsGet
     */
    readonly contractType: ContractTypes

    /**
     * 
     * @type {string}
     * @memberof ContractTemplatesClientApiContractTemplatesClientsListContractTemplatesClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractTemplatesClientsUpdateContractTemplatesClientsPost operation in ContractTemplatesClientApi.
 * @export
 * @interface ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPostRequest
 */
export interface ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPostRequest {
    /**
     * Docx file, not more than 20MB.
     * @type {File}
     * @memberof ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPost
     */
    readonly file: File

    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPost
     */
    readonly language: ContractTemplateLanguage

    /**
     * 
     * @type {ContractTypes}
     * @memberof ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPost
     */
    readonly contractType: ContractTypes

    /**
     * 
     * @type {string}
     * @memberof ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPost
     */
    readonly acceptLanguage?: string
}

/**
 * ContractTemplatesClientApi - object-oriented interface
 * @export
 * @class ContractTemplatesClientApi
 * @extends {BaseAPI}
 */
export class ContractTemplatesClientApi extends BaseAPI {
    /**
     * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get client contract templates
     * @param {ContractTemplatesClientApiContractTemplatesClientsListContractTemplatesClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesClientApi
     */
    public contractTemplatesClientsListContractTemplatesClientsGet(requestParameters: ContractTemplatesClientApiContractTemplatesClientsListContractTemplatesClientsGetRequest, options?: AxiosRequestConfig) {
        return ContractTemplatesClientApiFp(this.configuration).contractTemplatesClientsListContractTemplatesClientsGet(requestParameters.contractType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Create or update client contract template
     * @param {ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesClientApi
     */
    public contractTemplatesClientsUpdateContractTemplatesClientsPost(requestParameters: ContractTemplatesClientApiContractTemplatesClientsUpdateContractTemplatesClientsPostRequest, options?: AxiosRequestConfig) {
        return ContractTemplatesClientApiFp(this.configuration).contractTemplatesClientsUpdateContractTemplatesClientsPost(requestParameters.file, requestParameters.language, requestParameters.contractType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractTemplatesSupplierApi - axios parameter creator
 * @export
 */
export const ContractTemplatesSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract templates
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesSuppliersListContractTemplatesSuppliersGet: async (contractType: ContractTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('contractTemplatesSuppliersListContractTemplatesSuppliersGet', 'contractType', contractType)
            const localVarPath = `/contract-templates/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create or update supplier contract template
         * @param {File} file Docx file, not more than 20MB.
         * @param {ContractTemplateLanguage} language 
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost: async (file: File, language: ContractTemplateLanguage, contractType: ContractTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost', 'file', file)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost', 'language', language)
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost', 'contractType', contractType)
            const localVarPath = `/contract-templates/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', new Blob([JSON.stringify(language)], { type: "application/json", }));
            }
    
            if (contractType !== undefined) { 
                localVarFormParams.append('contractType', new Blob([JSON.stringify(contractType)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractTemplatesSupplierApi - functional programming interface
 * @export
 */
export const ContractTemplatesSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractTemplatesSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract templates
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractTemplatesSuppliersListContractTemplatesSuppliersGet(contractType: ContractTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractTemplateWithFileReadSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractTemplatesSuppliersListContractTemplatesSuppliersGet(contractType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create or update supplier contract template
         * @param {File} file Docx file, not more than 20MB.
         * @param {ContractTemplateLanguage} language 
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost(file: File, language: ContractTemplateLanguage, contractType: ContractTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractTemplateWithFileReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost(file, language, contractType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractTemplatesSupplierApi - factory interface
 * @export
 */
export const ContractTemplatesSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractTemplatesSupplierApiFp(configuration)
    return {
        /**
         * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract templates
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesSuppliersListContractTemplatesSuppliersGet(contractType: ContractTypes, acceptLanguage?: string, options?: any): AxiosPromise<Array<ContractTemplateWithFileReadSchema>> {
            return localVarFp.contractTemplatesSuppliersListContractTemplatesSuppliersGet(contractType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create or update supplier contract template
         * @param {File} file Docx file, not more than 20MB.
         * @param {ContractTemplateLanguage} language 
         * @param {ContractTypes} contractType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost(file: File, language: ContractTemplateLanguage, contractType: ContractTypes, acceptLanguage?: string, options?: any): AxiosPromise<ContractTemplateWithFileReadSchema> {
            return localVarFp.contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost(file, language, contractType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractTemplatesSuppliersListContractTemplatesSuppliersGet operation in ContractTemplatesSupplierApi.
 * @export
 * @interface ContractTemplatesSupplierApiContractTemplatesSuppliersListContractTemplatesSuppliersGetRequest
 */
export interface ContractTemplatesSupplierApiContractTemplatesSuppliersListContractTemplatesSuppliersGetRequest {
    /**
     * 
     * @type {ContractTypes}
     * @memberof ContractTemplatesSupplierApiContractTemplatesSuppliersListContractTemplatesSuppliersGet
     */
    readonly contractType: ContractTypes

    /**
     * 
     * @type {string}
     * @memberof ContractTemplatesSupplierApiContractTemplatesSuppliersListContractTemplatesSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost operation in ContractTemplatesSupplierApi.
 * @export
 * @interface ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPostRequest
 */
export interface ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPostRequest {
    /**
     * Docx file, not more than 20MB.
     * @type {File}
     * @memberof ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPost
     */
    readonly file: File

    /**
     * 
     * @type {ContractTemplateLanguage}
     * @memberof ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPost
     */
    readonly language: ContractTemplateLanguage

    /**
     * 
     * @type {ContractTypes}
     * @memberof ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPost
     */
    readonly contractType: ContractTypes

    /**
     * 
     * @type {string}
     * @memberof ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPost
     */
    readonly acceptLanguage?: string
}

/**
 * ContractTemplatesSupplierApi - object-oriented interface
 * @export
 * @class ContractTemplatesSupplierApi
 * @extends {BaseAPI}
 */
export class ContractTemplatesSupplierApi extends BaseAPI {
    /**
     * Get contract templates.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get supplier contract templates
     * @param {ContractTemplatesSupplierApiContractTemplatesSuppliersListContractTemplatesSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesSupplierApi
     */
    public contractTemplatesSuppliersListContractTemplatesSuppliersGet(requestParameters: ContractTemplatesSupplierApiContractTemplatesSuppliersListContractTemplatesSuppliersGetRequest, options?: AxiosRequestConfig) {
        return ContractTemplatesSupplierApiFp(this.configuration).contractTemplatesSuppliersListContractTemplatesSuppliersGet(requestParameters.contractType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update contract templates.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Create or update supplier contract template
     * @param {ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesSupplierApi
     */
    public contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost(requestParameters: ContractTemplatesSupplierApiContractTemplatesSuppliersUpdateContractTemplatesSuppliersPostRequest, options?: AxiosRequestConfig) {
        return ContractTemplatesSupplierApiFp(this.configuration).contractTemplatesSuppliersUpdateContractTemplatesSuppliersPost(requestParameters.file, requestParameters.language, requestParameters.contractType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsClientApi - axios parameter creator
 * @export
 */
export const ContractsClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Cancel client contract
         * @param {number} contractId 
         * @param {CancelContractSchema} cancelContractSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsCancelContractsClientsContractIdCancelPut: async (contractId: number, cancelContractSchema: CancelContractSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsCancelContractsClientsContractIdCancelPut', 'contractId', contractId)
            // verify required parameter 'cancelContractSchema' is not null or undefined
            assertParamExists('contractsClientsCancelContractsClientsContractIdCancelPut', 'cancelContractSchema', cancelContractSchema)
            const localVarPath = `/contracts/clients/{contract_id}/cancel/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelContractSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create client contract
         * @param {ClientContractCreateSchema} clientContractCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsCreateContractsClientsPost: async (clientContractCreateSchema: ClientContractCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientContractCreateSchema' is not null or undefined
            assertParamExists('contractsClientsCreateContractsClientsPost', 'clientContractCreateSchema', clientContractCreateSchema)
            const localVarPath = `/contracts/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientContractCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Delete client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsDeleteContractsClientsContractIdDelete: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsDeleteContractsClientsContractIdDelete', 'contractId', contractId)
            const localVarPath = `/contracts/clients/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Export client contract
         * @param {number} contractId 
         * @param {ContractExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsExportContractsClientsContractIdExportExportTypeGet: async (contractId: number, exportType: ContractExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsExportContractsClientsContractIdExportExportTypeGet', 'contractId', contractId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('contractsClientsExportContractsClientsContractIdExportExportTypeGet', 'exportType', exportType)
            const localVarPath = `/contracts/clients/{contract_id}/export/{export_type}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsGetContractsClientsContractIdGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsGetContractsClientsContractIdGet', 'contractId', contractId)
            const localVarPath = `/contracts/clients/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsGetSelectContractsClientsContractIdSelectGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsGetSelectContractsClientsContractIdSelectGet', 'contractId', contractId)
            const localVarPath = `/contracts/clients/{contract_id}/select/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract signed documents
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet', 'contractId', contractId)
            const localVarPath = `/contracts/clients/{contract_id}/signed-documents/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get client contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsListContractsClientsGet: async (page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateSignFrom !== undefined) {
                localVarQueryParameter['dateSignFrom'] = (dateSignFrom as any instanceof Date) ?
                    (dateSignFrom as any).toISOString().substr(0,10) :
                    dateSignFrom;
            }

            if (dateSignTo !== undefined) {
                localVarQueryParameter['dateSignTo'] = (dateSignTo as any instanceof Date) ?
                    (dateSignTo as any).toISOString().substr(0,10) :
                    dateSignTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (managerId !== undefined) {
                localVarQueryParameter['managerId'] = managerId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientAgentId !== undefined) {
                localVarQueryParameter['clientAgentId'] = clientAgentId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get client contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsListSelectContractsClientsSelectGet: async (page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/clients/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateSignFrom !== undefined) {
                localVarQueryParameter['dateSignFrom'] = (dateSignFrom as any instanceof Date) ?
                    (dateSignFrom as any).toISOString().substr(0,10) :
                    dateSignFrom;
            }

            if (dateSignTo !== undefined) {
                localVarQueryParameter['dateSignTo'] = (dateSignTo as any instanceof Date) ?
                    (dateSignTo as any).toISOString().substr(0,10) :
                    dateSignTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (managerId !== undefined) {
                localVarQueryParameter['managerId'] = managerId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientAgentId !== undefined) {
                localVarQueryParameter['clientAgentId'] = clientAgentId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Sign client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsSignContractsClientsContractIdSignPut: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsSignContractsClientsContractIdSignPut', 'contractId', contractId)
            const localVarPath = `/contracts/clients/{contract_id}/sign/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Update client contract
         * @param {number} contractId 
         * @param {ContractUpdateSchema} contractUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsUpdateContractsClientsContractIdPut: async (contractId: number, contractUpdateSchema: ContractUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsClientsUpdateContractsClientsContractIdPut', 'contractId', contractId)
            // verify required parameter 'contractUpdateSchema' is not null or undefined
            assertParamExists('contractsClientsUpdateContractsClientsContractIdPut', 'contractUpdateSchema', contractUpdateSchema)
            const localVarPath = `/contracts/clients/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsClientApi - functional programming interface
 * @export
 */
export const ContractsClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Cancel client contract
         * @param {number} contractId 
         * @param {CancelContractSchema} cancelContractSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsCancelContractsClientsContractIdCancelPut(contractId: number, cancelContractSchema: CancelContractSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsCancelContractsClientsContractIdCancelPut(contractId, cancelContractSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create client contract
         * @param {ClientContractCreateSchema} clientContractCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsCreateContractsClientsPost(clientContractCreateSchema: ClientContractCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsCreateContractsClientsPost(clientContractCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Delete client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsDeleteContractsClientsContractIdDelete(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsDeleteContractsClientsContractIdDelete(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Export client contract
         * @param {number} contractId 
         * @param {ContractExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsExportContractsClientsContractIdExportExportTypeGet(contractId: number, exportType: ContractExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsExportContractsClientsContractIdExportExportTypeGet(contractId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsGetContractsClientsContractIdGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsGetContractsClientsContractIdGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsGetSelectContractsClientsContractIdSelectGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContractSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsGetSelectContractsClientsContractIdSelectGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract signed documents
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignedContractDocumentReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get client contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsListContractsClientsGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsListContractsClientsGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get client contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsListSelectContractsClientsSelectGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsListSelectContractsClientsSelectGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Sign client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsSignContractsClientsContractIdSignPut(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsSignContractsClientsContractIdSignPut(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Update client contract
         * @param {number} contractId 
         * @param {ContractUpdateSchema} contractUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsClientsUpdateContractsClientsContractIdPut(contractId: number, contractUpdateSchema: ContractUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsClientsUpdateContractsClientsContractIdPut(contractId, contractUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsClientApi - factory interface
 * @export
 */
export const ContractsClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsClientApiFp(configuration)
    return {
        /**
         * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Cancel client contract
         * @param {number} contractId 
         * @param {CancelContractSchema} cancelContractSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsCancelContractsClientsContractIdCancelPut(contractId: number, cancelContractSchema: CancelContractSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsClientsCancelContractsClientsContractIdCancelPut(contractId, cancelContractSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create client contract
         * @param {ClientContractCreateSchema} clientContractCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsCreateContractsClientsPost(clientContractCreateSchema: ClientContractCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsClientsCreateContractsClientsPost(clientContractCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Delete client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsDeleteContractsClientsContractIdDelete(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsClientsDeleteContractsClientsContractIdDelete(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Export client contract
         * @param {number} contractId 
         * @param {ContractExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsExportContractsClientsContractIdExportExportTypeGet(contractId: number, exportType: ContractExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsClientsExportContractsClientsContractIdExportExportTypeGet(contractId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsGetContractsClientsContractIdGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsClientsGetContractsClientsContractIdGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsGetSelectContractsClientsContractIdSelectGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<SimpleContractSchema> {
            return localVarFp.contractsClientsGetSelectContractsClientsContractIdSelectGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get client contract signed documents
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<SignedContractDocumentReadSchema> {
            return localVarFp.contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get client contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsListContractsClientsGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: any): AxiosPromise<ContractsPage> {
            return localVarFp.contractsClientsListContractsClientsGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get client contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsListSelectContractsClientsSelectGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: any): AxiosPromise<ContractsPage> {
            return localVarFp.contractsClientsListSelectContractsClientsSelectGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Sign client contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsSignContractsClientsContractIdSignPut(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsClientsSignContractsClientsContractIdSignPut(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Update client contract
         * @param {number} contractId 
         * @param {ContractUpdateSchema} contractUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsClientsUpdateContractsClientsContractIdPut(contractId: number, contractUpdateSchema: ContractUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsClientsUpdateContractsClientsContractIdPut(contractId, contractUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractsClientsCancelContractsClientsContractIdCancelPut operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPutRequest
 */
export interface ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPut
     */
    readonly contractId: number

    /**
     * 
     * @type {CancelContractSchema}
     * @memberof ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPut
     */
    readonly cancelContractSchema: CancelContractSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsCreateContractsClientsPost operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsCreateContractsClientsPostRequest
 */
export interface ContractsClientApiContractsClientsCreateContractsClientsPostRequest {
    /**
     * 
     * @type {ClientContractCreateSchema}
     * @memberof ContractsClientApiContractsClientsCreateContractsClientsPost
     */
    readonly clientContractCreateSchema: ClientContractCreateSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsCreateContractsClientsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsDeleteContractsClientsContractIdDelete operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsDeleteContractsClientsContractIdDeleteRequest
 */
export interface ContractsClientApiContractsClientsDeleteContractsClientsContractIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsDeleteContractsClientsContractIdDelete
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsDeleteContractsClientsContractIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsExportContractsClientsContractIdExportExportTypeGet operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGetRequest
 */
export interface ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGet
     */
    readonly contractId: number

    /**
     * 
     * @type {ContractExportType}
     * @memberof ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGet
     */
    readonly exportType: ContractExportType

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsGetContractsClientsContractIdGet operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsGetContractsClientsContractIdGetRequest
 */
export interface ContractsClientApiContractsClientsGetContractsClientsContractIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsGetContractsClientsContractIdGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsGetContractsClientsContractIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsGetSelectContractsClientsContractIdSelectGet operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsGetSelectContractsClientsContractIdSelectGetRequest
 */
export interface ContractsClientApiContractsClientsGetSelectContractsClientsContractIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsGetSelectContractsClientsContractIdSelectGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsGetSelectContractsClientsContractIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGetRequest
 */
export interface ContractsClientApiContractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsListContractsClientsGet operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsListContractsClientsGetRequest
 */
export interface ContractsClientApiContractsClientsListContractsClientsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date sign from.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly dateSignFrom?: string

    /**
     * Date sign to.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly dateSignTo?: string

    /**
     * Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly searchFilterSelect?: string

    /**
     * Contract type.
     * @type {ContractTypes}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly contractType?: ContractTypes

    /**
     * Currency id.
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly currencyId?: number

    /**
     * Supplier category id.
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly supplierCategoryId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly countryId?: number

    /**
     * Manager id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly managerId?: string

    /**
     * Creator id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly creatorId?: string

    /**
     * Status.
     * @type {ContractStatuses}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly status?: ContractStatuses

    /**
     * Sort.
     * @type {BaseSort}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly sort?: BaseSort

    /**
     * Order.
     * @type {ContractQueryOrder}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly order?: ContractQueryOrder

    /**
     * Client type.
     * @type {ClientTypes}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly clientType?: ClientTypes

    /**
     * Client agent id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly clientAgentId?: string

    /**
     * User id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListContractsClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsListSelectContractsClientsSelectGet operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsListSelectContractsClientsSelectGetRequest
 */
export interface ContractsClientApiContractsClientsListSelectContractsClientsSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date sign from.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly dateSignFrom?: string

    /**
     * Date sign to.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly dateSignTo?: string

    /**
     * Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Contract type.
     * @type {ContractTypes}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly contractType?: ContractTypes

    /**
     * Currency id.
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly currencyId?: number

    /**
     * Supplier category id.
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly supplierCategoryId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly countryId?: number

    /**
     * Manager id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly managerId?: string

    /**
     * Creator id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly creatorId?: string

    /**
     * Status.
     * @type {ContractStatuses}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly status?: ContractStatuses

    /**
     * Sort.
     * @type {BaseSort}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Order.
     * @type {ContractQueryOrder}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly order?: ContractQueryOrder

    /**
     * Client type.
     * @type {ClientTypes}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly clientType?: ClientTypes

    /**
     * Client agent id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly clientAgentId?: string

    /**
     * User id.
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsListSelectContractsClientsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsSignContractsClientsContractIdSignPut operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsSignContractsClientsContractIdSignPutRequest
 */
export interface ContractsClientApiContractsClientsSignContractsClientsContractIdSignPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsSignContractsClientsContractIdSignPut
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsSignContractsClientsContractIdSignPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsClientsUpdateContractsClientsContractIdPut operation in ContractsClientApi.
 * @export
 * @interface ContractsClientApiContractsClientsUpdateContractsClientsContractIdPutRequest
 */
export interface ContractsClientApiContractsClientsUpdateContractsClientsContractIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsClientApiContractsClientsUpdateContractsClientsContractIdPut
     */
    readonly contractId: number

    /**
     * 
     * @type {ContractUpdateSchema}
     * @memberof ContractsClientApiContractsClientsUpdateContractsClientsContractIdPut
     */
    readonly contractUpdateSchema: ContractUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsClientApiContractsClientsUpdateContractsClientsContractIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ContractsClientApi - object-oriented interface
 * @export
 * @class ContractsClientApi
 * @extends {BaseAPI}
 */
export class ContractsClientApi extends BaseAPI {
    /**
     * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Cancel client contract
     * @param {ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsCancelContractsClientsContractIdCancelPut(requestParameters: ContractsClientApiContractsClientsCancelContractsClientsContractIdCancelPutRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsCancelContractsClientsContractIdCancelPut(requestParameters.contractId, requestParameters.cancelContractSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Create client contract
     * @param {ContractsClientApiContractsClientsCreateContractsClientsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsCreateContractsClientsPost(requestParameters: ContractsClientApiContractsClientsCreateContractsClientsPostRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsCreateContractsClientsPost(requestParameters.clientContractCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Delete client contract
     * @param {ContractsClientApiContractsClientsDeleteContractsClientsContractIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsDeleteContractsClientsContractIdDelete(requestParameters: ContractsClientApiContractsClientsDeleteContractsClientsContractIdDeleteRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsDeleteContractsClientsContractIdDelete(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Export client contract
     * @param {ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsExportContractsClientsContractIdExportExportTypeGet(requestParameters: ContractsClientApiContractsClientsExportContractsClientsContractIdExportExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsExportContractsClientsContractIdExportExportTypeGet(requestParameters.contractId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get client contract
     * @param {ContractsClientApiContractsClientsGetContractsClientsContractIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsGetContractsClientsContractIdGet(requestParameters: ContractsClientApiContractsClientsGetContractsClientsContractIdGetRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsGetContractsClientsContractIdGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get client contract
     * @param {ContractsClientApiContractsClientsGetSelectContractsClientsContractIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsGetSelectContractsClientsContractIdSelectGet(requestParameters: ContractsClientApiContractsClientsGetSelectContractsClientsContractIdSelectGetRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsGetSelectContractsClientsContractIdSelectGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get client contract signed documents
     * @param {ContractsClientApiContractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet(requestParameters: ContractsClientApiContractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGetRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsGetSignedDocumentsContractsClientsContractIdSignedDocumentsGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
     * @summary Get client contracts list
     * @param {ContractsClientApiContractsClientsListContractsClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsListContractsClientsGet(requestParameters: ContractsClientApiContractsClientsListContractsClientsGetRequest = {}, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsListContractsClientsGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateSignFrom, requestParameters.dateSignTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.contractType, requestParameters.currencyId, requestParameters.supplierCategoryId, requestParameters.countryId, requestParameters.managerId, requestParameters.creatorId, requestParameters.status, requestParameters.sort, requestParameters.order, requestParameters.clientType, requestParameters.clientAgentId, requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
     * @summary Get client contracts list
     * @param {ContractsClientApiContractsClientsListSelectContractsClientsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsListSelectContractsClientsSelectGet(requestParameters: ContractsClientApiContractsClientsListSelectContractsClientsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsListSelectContractsClientsSelectGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateSignFrom, requestParameters.dateSignTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.contractType, requestParameters.currencyId, requestParameters.supplierCategoryId, requestParameters.countryId, requestParameters.managerId, requestParameters.creatorId, requestParameters.status, requestParameters.sort, requestParameters.order, requestParameters.clientType, requestParameters.clientAgentId, requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Sign client contract
     * @param {ContractsClientApiContractsClientsSignContractsClientsContractIdSignPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsSignContractsClientsContractIdSignPut(requestParameters: ContractsClientApiContractsClientsSignContractsClientsContractIdSignPutRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsSignContractsClientsContractIdSignPut(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Update client contract
     * @param {ContractsClientApiContractsClientsUpdateContractsClientsContractIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsClientApi
     */
    public contractsClientsUpdateContractsClientsContractIdPut(requestParameters: ContractsClientApiContractsClientsUpdateContractsClientsContractIdPutRequest, options?: AxiosRequestConfig) {
        return ContractsClientApiFp(this.configuration).contractsClientsUpdateContractsClientsContractIdPut(requestParameters.contractId, requestParameters.contractUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsLanguageInfoClientApi - axios parameter creator
 * @export
 */
export const ContractsLanguageInfoClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Create or update client contract language info
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet', 'contractId', contractId)
            const localVarPath = `/contracts-language-info/clients/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contract language infos.  Roles: is_staff
         * @summary Create or update client contract language info
         * @param {number} contractId 
         * @param {ContractLanguageInfoUpdateSchema} contractLanguageInfoUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost: async (contractId: number, contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost', 'contractId', contractId)
            // verify required parameter 'contractLanguageInfoUpdateSchema' is not null or undefined
            assertParamExists('contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost', 'contractLanguageInfoUpdateSchema', contractLanguageInfoUpdateSchema)
            const localVarPath = `/contracts-language-info/clients/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractLanguageInfoUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsLanguageInfoClientApi - functional programming interface
 * @export
 */
export const ContractsLanguageInfoClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsLanguageInfoClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Create or update client contract language info
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractLanguageInfoReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contract language infos.  Roles: is_staff
         * @summary Create or update client contract language info
         * @param {number} contractId 
         * @param {ContractLanguageInfoUpdateSchema} contractLanguageInfoUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost(contractId: number, contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractLanguageInfoReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost(contractId, contractLanguageInfoUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsLanguageInfoClientApi - factory interface
 * @export
 */
export const ContractsLanguageInfoClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsLanguageInfoClientApiFp(configuration)
    return {
        /**
         * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Create or update client contract language info
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<ContractLanguageInfoReadSchema> {
            return localVarFp.contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contract language infos.  Roles: is_staff
         * @summary Create or update client contract language info
         * @param {number} contractId 
         * @param {ContractLanguageInfoUpdateSchema} contractLanguageInfoUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost(contractId: number, contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractLanguageInfoReadSchema> {
            return localVarFp.contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost(contractId, contractLanguageInfoUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet operation in ContractsLanguageInfoClientApi.
 * @export
 * @interface ContractsLanguageInfoClientApiContractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGetRequest
 */
export interface ContractsLanguageInfoClientApiContractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsLanguageInfoClientApiContractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsLanguageInfoClientApiContractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost operation in ContractsLanguageInfoClientApi.
 * @export
 * @interface ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPostRequest
 */
export interface ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost
     */
    readonly contractId: number

    /**
     * 
     * @type {ContractLanguageInfoUpdateSchema}
     * @memberof ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost
     */
    readonly contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * ContractsLanguageInfoClientApi - object-oriented interface
 * @export
 * @class ContractsLanguageInfoClientApi
 * @extends {BaseAPI}
 */
export class ContractsLanguageInfoClientApi extends BaseAPI {
    /**
     * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Create or update client contract language info
     * @param {ContractsLanguageInfoClientApiContractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsLanguageInfoClientApi
     */
    public contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet(requestParameters: ContractsLanguageInfoClientApiContractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGetRequest, options?: AxiosRequestConfig) {
        return ContractsLanguageInfoClientApiFp(this.configuration).contractLanguageInfoClientsListContractsLanguageInfoClientsContractIdGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contract language infos.  Roles: is_staff
     * @summary Create or update client contract language info
     * @param {ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsLanguageInfoClientApi
     */
    public contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost(requestParameters: ContractsLanguageInfoClientApiContractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPostRequest, options?: AxiosRequestConfig) {
        return ContractsLanguageInfoClientApiFp(this.configuration).contractLanguageInfoClientsUpdateContractsLanguageInfoClientsContractIdPost(requestParameters.contractId, requestParameters.contractLanguageInfoUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsLanguageInfoSupplierApi - axios parameter creator
 * @export
 */
export const ContractsLanguageInfoSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Create or update supplier contract language info
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet', 'contractId', contractId)
            const localVarPath = `/contracts-language-info/suppliers/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contract language infos.  Roles: is_staff
         * @summary Create or update supplier contract language info
         * @param {number} contractId 
         * @param {ContractLanguageInfoUpdateSchema} contractLanguageInfoUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost: async (contractId: number, contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost', 'contractId', contractId)
            // verify required parameter 'contractLanguageInfoUpdateSchema' is not null or undefined
            assertParamExists('contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost', 'contractLanguageInfoUpdateSchema', contractLanguageInfoUpdateSchema)
            const localVarPath = `/contracts-language-info/suppliers/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractLanguageInfoUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsLanguageInfoSupplierApi - functional programming interface
 * @export
 */
export const ContractsLanguageInfoSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsLanguageInfoSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Create or update supplier contract language info
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractLanguageInfoReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contract language infos.  Roles: is_staff
         * @summary Create or update supplier contract language info
         * @param {number} contractId 
         * @param {ContractLanguageInfoUpdateSchema} contractLanguageInfoUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost(contractId: number, contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractLanguageInfoReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost(contractId, contractLanguageInfoUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsLanguageInfoSupplierApi - factory interface
 * @export
 */
export const ContractsLanguageInfoSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsLanguageInfoSupplierApiFp(configuration)
    return {
        /**
         * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Create or update supplier contract language info
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<ContractLanguageInfoReadSchema> {
            return localVarFp.contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contract language infos.  Roles: is_staff
         * @summary Create or update supplier contract language info
         * @param {number} contractId 
         * @param {ContractLanguageInfoUpdateSchema} contractLanguageInfoUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost(contractId: number, contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractLanguageInfoReadSchema> {
            return localVarFp.contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost(contractId, contractLanguageInfoUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet operation in ContractsLanguageInfoSupplierApi.
 * @export
 * @interface ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGetRequest
 */
export interface ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost operation in ContractsLanguageInfoSupplierApi.
 * @export
 * @interface ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPostRequest
 */
export interface ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost
     */
    readonly contractId: number

    /**
     * 
     * @type {ContractLanguageInfoUpdateSchema}
     * @memberof ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost
     */
    readonly contractLanguageInfoUpdateSchema: ContractLanguageInfoUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * ContractsLanguageInfoSupplierApi - object-oriented interface
 * @export
 * @class ContractsLanguageInfoSupplierApi
 * @extends {BaseAPI}
 */
export class ContractsLanguageInfoSupplierApi extends BaseAPI {
    /**
     * Get contract language infos.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Create or update supplier contract language info
     * @param {ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsLanguageInfoSupplierApi
     */
    public contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet(requestParameters: ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGetRequest, options?: AxiosRequestConfig) {
        return ContractsLanguageInfoSupplierApiFp(this.configuration).contractLanguageInfoSuppliersListContractsLanguageInfoSuppliersContractIdGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contract language infos.  Roles: is_staff
     * @summary Create or update supplier contract language info
     * @param {ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsLanguageInfoSupplierApi
     */
    public contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost(requestParameters: ContractsLanguageInfoSupplierApiContractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPostRequest, options?: AxiosRequestConfig) {
        return ContractsLanguageInfoSupplierApiFp(this.configuration).contractLanguageInfoSuppliersUpdateContractsLanguageInfoSuppliersContractIdPost(requestParameters.contractId, requestParameters.contractLanguageInfoUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsSupplierApi - axios parameter creator
 * @export
 */
export const ContractsSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Cancel supplier contract
         * @param {number} contractId 
         * @param {CancelContractSchema} cancelContractSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersCancelContractsSuppliersContractIdCancelPut: async (contractId: number, cancelContractSchema: CancelContractSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersCancelContractsSuppliersContractIdCancelPut', 'contractId', contractId)
            // verify required parameter 'cancelContractSchema' is not null or undefined
            assertParamExists('contractsSuppliersCancelContractsSuppliersContractIdCancelPut', 'cancelContractSchema', cancelContractSchema)
            const localVarPath = `/contracts/suppliers/{contract_id}/cancel/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelContractSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create supplier contract
         * @param {SupplierContractCreateSchema} supplierContractCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersCreateContractsSuppliersPost: async (supplierContractCreateSchema: SupplierContractCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierContractCreateSchema' is not null or undefined
            assertParamExists('contractsSuppliersCreateContractsSuppliersPost', 'supplierContractCreateSchema', supplierContractCreateSchema)
            const localVarPath = `/contracts/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierContractCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Delete supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersDeleteContractsSuppliersContractIdDelete: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersDeleteContractsSuppliersContractIdDelete', 'contractId', contractId)
            const localVarPath = `/contracts/suppliers/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Export supplier contract
         * @param {number} contractId 
         * @param {ContractExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet: async (contractId: number, exportType: ContractExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet', 'contractId', contractId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet', 'exportType', exportType)
            const localVarPath = `/contracts/suppliers/{contract_id}/export/{export_type}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersGetContractsSuppliersContractIdGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersGetContractsSuppliersContractIdGet', 'contractId', contractId)
            const localVarPath = `/contracts/suppliers/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet', 'contractId', contractId)
            const localVarPath = `/contracts/suppliers/{contract_id}/select/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract signed documents
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet', 'contractId', contractId)
            const localVarPath = `/contracts/suppliers/{contract_id}/signed-documents/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get supplier contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersListContractsSuppliersGet: async (page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateSignFrom !== undefined) {
                localVarQueryParameter['dateSignFrom'] = (dateSignFrom as any instanceof Date) ?
                    (dateSignFrom as any).toISOString().substr(0,10) :
                    dateSignFrom;
            }

            if (dateSignTo !== undefined) {
                localVarQueryParameter['dateSignTo'] = (dateSignTo as any instanceof Date) ?
                    (dateSignTo as any).toISOString().substr(0,10) :
                    dateSignTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (managerId !== undefined) {
                localVarQueryParameter['managerId'] = managerId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientAgentId !== undefined) {
                localVarQueryParameter['clientAgentId'] = clientAgentId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get supplier contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersListSelectContractsSuppliersSelectGet: async (page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/suppliers/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateSignFrom !== undefined) {
                localVarQueryParameter['dateSignFrom'] = (dateSignFrom as any instanceof Date) ?
                    (dateSignFrom as any).toISOString().substr(0,10) :
                    dateSignFrom;
            }

            if (dateSignTo !== undefined) {
                localVarQueryParameter['dateSignTo'] = (dateSignTo as any instanceof Date) ?
                    (dateSignTo as any).toISOString().substr(0,10) :
                    dateSignTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (managerId !== undefined) {
                localVarQueryParameter['managerId'] = managerId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientAgentId !== undefined) {
                localVarQueryParameter['clientAgentId'] = clientAgentId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Sign supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersSignContractsSuppliersContractIdSignPut: async (contractId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersSignContractsSuppliersContractIdSignPut', 'contractId', contractId)
            const localVarPath = `/contracts/suppliers/{contract_id}/sign/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Update supplier contract
         * @param {number} contractId 
         * @param {SupplierContractUpdateSchema} supplierContractUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersUpdateContractsSuppliersContractIdPut: async (contractId: number, supplierContractUpdateSchema: SupplierContractUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsSuppliersUpdateContractsSuppliersContractIdPut', 'contractId', contractId)
            // verify required parameter 'supplierContractUpdateSchema' is not null or undefined
            assertParamExists('contractsSuppliersUpdateContractsSuppliersContractIdPut', 'supplierContractUpdateSchema', supplierContractUpdateSchema)
            const localVarPath = `/contracts/suppliers/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierContractUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsSupplierApi - functional programming interface
 * @export
 */
export const ContractsSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Cancel supplier contract
         * @param {number} contractId 
         * @param {CancelContractSchema} cancelContractSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersCancelContractsSuppliersContractIdCancelPut(contractId: number, cancelContractSchema: CancelContractSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersCancelContractsSuppliersContractIdCancelPut(contractId, cancelContractSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create supplier contract
         * @param {SupplierContractCreateSchema} supplierContractCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersCreateContractsSuppliersPost(supplierContractCreateSchema: SupplierContractCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersCreateContractsSuppliersPost(supplierContractCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Delete supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersDeleteContractsSuppliersContractIdDelete(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersDeleteContractsSuppliersContractIdDelete(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Export supplier contract
         * @param {number} contractId 
         * @param {ContractExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet(contractId: number, exportType: ContractExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet(contractId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersGetContractsSuppliersContractIdGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersGetContractsSuppliersContractIdGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContractSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract signed documents
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignedContractDocumentReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get supplier contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersListContractsSuppliersGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersListContractsSuppliersGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get supplier contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersListSelectContractsSuppliersSelectGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersListSelectContractsSuppliersSelectGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Sign supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersSignContractsSuppliersContractIdSignPut(contractId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersSignContractsSuppliersContractIdSignPut(contractId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Update supplier contract
         * @param {number} contractId 
         * @param {SupplierContractUpdateSchema} supplierContractUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSuppliersUpdateContractsSuppliersContractIdPut(contractId: number, supplierContractUpdateSchema: SupplierContractUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSuppliersUpdateContractsSuppliersContractIdPut(contractId, supplierContractUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsSupplierApi - factory interface
 * @export
 */
export const ContractsSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsSupplierApiFp(configuration)
    return {
        /**
         * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Cancel supplier contract
         * @param {number} contractId 
         * @param {CancelContractSchema} cancelContractSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersCancelContractsSuppliersContractIdCancelPut(contractId: number, cancelContractSchema: CancelContractSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsSuppliersCancelContractsSuppliersContractIdCancelPut(contractId, cancelContractSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Create supplier contract
         * @param {SupplierContractCreateSchema} supplierContractCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersCreateContractsSuppliersPost(supplierContractCreateSchema: SupplierContractCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsSuppliersCreateContractsSuppliersPost(supplierContractCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Delete supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersDeleteContractsSuppliersContractIdDelete(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsSuppliersDeleteContractsSuppliersContractIdDelete(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Export supplier contract
         * @param {number} contractId 
         * @param {ContractExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet(contractId: number, exportType: ContractExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet(contractId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersGetContractsSuppliersContractIdGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsSuppliersGetContractsSuppliersContractIdGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<SimpleContractSchema> {
            return localVarFp.contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
         * @summary Get supplier contract signed documents
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<SignedContractDocumentReadSchema> {
            return localVarFp.contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get supplier contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersListContractsSuppliersGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: any): AxiosPromise<ContractsPage> {
            return localVarFp.contractsSuppliersListContractsSuppliersGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
         * @summary Get supplier contracts list
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateSignFrom] Date sign from.
         * @param {string} [dateSignTo] Date sign to.
         * @param {string} [searchFilter] Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {ContractTypes} [contractType] Contract type.
         * @param {number} [currencyId] Currency id.
         * @param {number} [supplierCategoryId] Supplier category id.
         * @param {number} [countryId] Country id.
         * @param {string} [managerId] Manager id.
         * @param {string} [creatorId] Creator id.
         * @param {ContractStatuses} [status] Status.
         * @param {BaseSort} [sort] Sort.
         * @param {ContractQueryOrder} [order] Order.
         * @param {ClientTypes} [clientType] Client type.
         * @param {string} [clientAgentId] Client agent id.
         * @param {string} [userId] User id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersListSelectContractsSuppliersSelectGet(page?: number, pageSize?: number, dateCreatedFrom?: string, dateCreatedTo?: string, dateSignFrom?: string, dateSignTo?: string, searchFilter?: string, searchFilterSelect?: string, contractType?: ContractTypes, currencyId?: number, supplierCategoryId?: number, countryId?: number, managerId?: string, creatorId?: string, status?: ContractStatuses, sort?: BaseSort, order?: ContractQueryOrder, clientType?: ClientTypes, clientAgentId?: string, userId?: string, acceptLanguage?: string, options?: any): AxiosPromise<ContractsPage> {
            return localVarFp.contractsSuppliersListSelectContractsSuppliersSelectGet(page, pageSize, dateCreatedFrom, dateCreatedTo, dateSignFrom, dateSignTo, searchFilter, searchFilterSelect, contractType, currencyId, supplierCategoryId, countryId, managerId, creatorId, status, sort, order, clientType, clientAgentId, userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Sign supplier contract
         * @param {number} contractId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersSignContractsSuppliersContractIdSignPut(contractId: number, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsSuppliersSignContractsSuppliersContractIdSignPut(contractId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
         * @summary Update supplier contract
         * @param {number} contractId 
         * @param {SupplierContractUpdateSchema} supplierContractUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSuppliersUpdateContractsSuppliersContractIdPut(contractId: number, supplierContractUpdateSchema: SupplierContractUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ContractDetailSchema> {
            return localVarFp.contractsSuppliersUpdateContractsSuppliersContractIdPut(contractId, supplierContractUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractsSuppliersCancelContractsSuppliersContractIdCancelPut operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPutRequest
 */
export interface ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPut
     */
    readonly contractId: number

    /**
     * 
     * @type {CancelContractSchema}
     * @memberof ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPut
     */
    readonly cancelContractSchema: CancelContractSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersCreateContractsSuppliersPost operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersCreateContractsSuppliersPostRequest
 */
export interface ContractsSupplierApiContractsSuppliersCreateContractsSuppliersPostRequest {
    /**
     * 
     * @type {SupplierContractCreateSchema}
     * @memberof ContractsSupplierApiContractsSuppliersCreateContractsSuppliersPost
     */
    readonly supplierContractCreateSchema: SupplierContractCreateSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersCreateContractsSuppliersPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersDeleteContractsSuppliersContractIdDelete operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersDeleteContractsSuppliersContractIdDeleteRequest
 */
export interface ContractsSupplierApiContractsSuppliersDeleteContractsSuppliersContractIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersDeleteContractsSuppliersContractIdDelete
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersDeleteContractsSuppliersContractIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGetRequest
 */
export interface ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet
     */
    readonly contractId: number

    /**
     * 
     * @type {ContractExportType}
     * @memberof ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet
     */
    readonly exportType: ContractExportType

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersGetContractsSuppliersContractIdGet operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersGetContractsSuppliersContractIdGetRequest
 */
export interface ContractsSupplierApiContractsSuppliersGetContractsSuppliersContractIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersGetContractsSuppliersContractIdGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersGetContractsSuppliersContractIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersGetSelectContractsSuppliersContractIdSelectGetRequest
 */
export interface ContractsSupplierApiContractsSuppliersGetSelectContractsSuppliersContractIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersGetSelectContractsSuppliersContractIdSelectGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersGetSelectContractsSuppliersContractIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGetRequest
 */
export interface ContractsSupplierApiContractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersListContractsSuppliersGet operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersListContractsSuppliersGetRequest
 */
export interface ContractsSupplierApiContractsSuppliersListContractsSuppliersGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date sign from.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly dateSignFrom?: string

    /**
     * Date sign to.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly dateSignTo?: string

    /**
     * Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly searchFilterSelect?: string

    /**
     * Contract type.
     * @type {ContractTypes}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly contractType?: ContractTypes

    /**
     * Currency id.
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly currencyId?: number

    /**
     * Supplier category id.
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly supplierCategoryId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly countryId?: number

    /**
     * Manager id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly managerId?: string

    /**
     * Creator id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly creatorId?: string

    /**
     * Status.
     * @type {ContractStatuses}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly status?: ContractStatuses

    /**
     * Sort.
     * @type {BaseSort}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly sort?: BaseSort

    /**
     * Order.
     * @type {ContractQueryOrder}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly order?: ContractQueryOrder

    /**
     * Client type.
     * @type {ClientTypes}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly clientType?: ClientTypes

    /**
     * Client agent id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly clientAgentId?: string

    /**
     * User id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListContractsSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersListSelectContractsSuppliersSelectGet operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGetRequest
 */
export interface ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date sign from.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly dateSignFrom?: string

    /**
     * Date sign to.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly dateSignTo?: string

    /**
     * Search filter. По номеру документа, № документа поставщика, По поставщику (по Телефону, Почте, Названию, VAT номеру, регистрационному номеру)
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Contract type.
     * @type {ContractTypes}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly contractType?: ContractTypes

    /**
     * Currency id.
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly currencyId?: number

    /**
     * Supplier category id.
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly supplierCategoryId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly countryId?: number

    /**
     * Manager id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly managerId?: string

    /**
     * Creator id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly creatorId?: string

    /**
     * Status.
     * @type {ContractStatuses}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly status?: ContractStatuses

    /**
     * Sort.
     * @type {BaseSort}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Order.
     * @type {ContractQueryOrder}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly order?: ContractQueryOrder

    /**
     * Client type.
     * @type {ClientTypes}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly clientType?: ClientTypes

    /**
     * Client agent id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly clientAgentId?: string

    /**
     * User id.
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersSignContractsSuppliersContractIdSignPut operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersSignContractsSuppliersContractIdSignPutRequest
 */
export interface ContractsSupplierApiContractsSuppliersSignContractsSuppliersContractIdSignPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersSignContractsSuppliersContractIdSignPut
     */
    readonly contractId: number

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersSignContractsSuppliersContractIdSignPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for contractsSuppliersUpdateContractsSuppliersContractIdPut operation in ContractsSupplierApi.
 * @export
 * @interface ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPutRequest
 */
export interface ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPut
     */
    readonly contractId: number

    /**
     * 
     * @type {SupplierContractUpdateSchema}
     * @memberof ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPut
     */
    readonly supplierContractUpdateSchema: SupplierContractUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ContractsSupplierApi - object-oriented interface
 * @export
 * @class ContractsSupplierApi
 * @extends {BaseAPI}
 */
export class ContractsSupplierApi extends BaseAPI {
    /**
     * Cancel a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Cancel supplier contract
     * @param {ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersCancelContractsSuppliersContractIdCancelPut(requestParameters: ContractsSupplierApiContractsSuppliersCancelContractsSuppliersContractIdCancelPutRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersCancelContractsSuppliersContractIdCancelPut(requestParameters.contractId, requestParameters.cancelContractSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Create supplier contract
     * @param {ContractsSupplierApiContractsSuppliersCreateContractsSuppliersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersCreateContractsSuppliersPost(requestParameters: ContractsSupplierApiContractsSuppliersCreateContractsSuppliersPostRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersCreateContractsSuppliersPost(requestParameters.supplierContractCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Delete supplier contract
     * @param {ContractsSupplierApiContractsSuppliersDeleteContractsSuppliersContractIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersDeleteContractsSuppliersContractIdDelete(requestParameters: ContractsSupplierApiContractsSuppliersDeleteContractsSuppliersContractIdDeleteRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersDeleteContractsSuppliersContractIdDelete(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export contract(only for status \"created\").  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Export supplier contract
     * @param {ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet(requestParameters: ContractsSupplierApiContractsSuppliersExportContractsSuppliersContractIdExportExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersExportContractsSuppliersContractIdExportExportTypeGet(requestParameters.contractId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get supplier contract
     * @param {ContractsSupplierApiContractsSuppliersGetContractsSuppliersContractIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersGetContractsSuppliersContractIdGet(requestParameters: ContractsSupplierApiContractsSuppliersGetContractsSuppliersContractIdGetRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersGetContractsSuppliersContractIdGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contract.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get supplier contract
     * @param {ContractsSupplierApiContractsSuppliersGetSelectContractsSuppliersContractIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet(requestParameters: ContractsSupplierApiContractsSuppliersGetSelectContractsSuppliersContractIdSelectGetRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersGetSelectContractsSuppliersContractIdSelectGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get signed contract documents.  Roles: is_staff  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents  Situational permissions: crm_view_other_manager_client_access - for clients crm_view_other_manager_client_contract - for clients warehouse_view_other_manager_supplier_access - for suppliers warehouse_view_other_manager_supplier_contract - for suppliers crm_view_other_manager_agent_contract - for agents
     * @summary Get supplier contract signed documents
     * @param {ContractsSupplierApiContractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet(requestParameters: ContractsSupplierApiContractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGetRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersGetSignedDocumentsContractsSuppliersContractIdSignedDocumentsGet(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
     * @summary Get supplier contracts list
     * @param {ContractsSupplierApiContractsSuppliersListContractsSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersListContractsSuppliersGet(requestParameters: ContractsSupplierApiContractsSuppliersListContractsSuppliersGetRequest = {}, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersListContractsSuppliersGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateSignFrom, requestParameters.dateSignTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.contractType, requestParameters.currencyId, requestParameters.supplierCategoryId, requestParameters.countryId, requestParameters.managerId, requestParameters.creatorId, requestParameters.status, requestParameters.sort, requestParameters.order, requestParameters.clientType, requestParameters.clientAgentId, requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current contracts.  Permission required: crm_view_client_contract - for clients warehouse_view_supplier_contract - for suppliers crm_view_agent_contract - for agents
     * @summary Get supplier contracts list
     * @param {ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersListSelectContractsSuppliersSelectGet(requestParameters: ContractsSupplierApiContractsSuppliersListSelectContractsSuppliersSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersListSelectContractsSuppliersSelectGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateSignFrom, requestParameters.dateSignTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.contractType, requestParameters.currencyId, requestParameters.supplierCategoryId, requestParameters.countryId, requestParameters.managerId, requestParameters.creatorId, requestParameters.status, requestParameters.sort, requestParameters.order, requestParameters.clientType, requestParameters.clientAgentId, requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Sign supplier contract
     * @param {ContractsSupplierApiContractsSuppliersSignContractsSuppliersContractIdSignPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersSignContractsSuppliersContractIdSignPut(requestParameters: ContractsSupplierApiContractsSuppliersSignContractsSuppliersContractIdSignPutRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersSignContractsSuppliersContractIdSignPut(requestParameters.contractId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a contract.  Roles: is_staff  Permission required: crm_change_client_contract - for clients warehouse_change_supplier_contract - for suppliers crm_change_agent_contract - for agents  Situational permissions: crm_change_other_manager_client_access - for clients crm_change_other_manager_client_contract - for clients warehouse_change_other_manager_supplier_access - for suppliers warehouse_change_other_manager_supplier_contract - for suppliers crm_change_other_manager_agent_access - for agents crm_change_other_manager_agent_contract - for agents
     * @summary Update supplier contract
     * @param {ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsSupplierApi
     */
    public contractsSuppliersUpdateContractsSuppliersContractIdPut(requestParameters: ContractsSupplierApiContractsSuppliersUpdateContractsSuppliersContractIdPutRequest, options?: AxiosRequestConfig) {
        return ContractsSupplierApiFp(this.configuration).contractsSuppliersUpdateContractsSuppliersContractIdPut(requestParameters.contractId, requestParameters.supplierContractUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create document
         * @param {DocumentType} documentType 
         * @param {ContentId} contentId 
         * @param {File} file 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreateDocumentsDocumentTypeContentIdPost: async (documentType: DocumentType, contentId: ContentId, file: File, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('documentsCreateDocumentsDocumentTypeContentIdPost', 'documentType', documentType)
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('documentsCreateDocumentsDocumentTypeContentIdPost', 'contentId', contentId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('documentsCreateDocumentsDocumentTypeContentIdPost', 'file', file)
            const localVarPath = `/documents/{document_type}/{content_id}/`
                .replace(`{${"document_type"}}`, encodeURIComponent(String(documentType)))
                .replace(`{${"content_id"}}`, encodeURIComponent(String(contentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete document
         * @param {DocumentType} documentType 
         * @param {number} documentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDeleteDocumentsDocumentTypeDocumentIdDelete: async (documentType: DocumentType, documentId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('documentsDeleteDocumentsDocumentTypeDocumentIdDelete', 'documentType', documentType)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsDeleteDocumentsDocumentTypeDocumentIdDelete', 'documentId', documentId)
            const localVarPath = `/documents/{document_type}/{document_id}/`
                .replace(`{${"document_type"}}`, encodeURIComponent(String(documentType)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get documents.  Permission required to access client/client document: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
         * @summary Get documents
         * @param {DocumentType} documentType 
         * @param {ContentId} contentId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {DocumentQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsListDocumentsDocumentTypeContentIdGet: async (documentType: DocumentType, contentId: ContentId, page?: number, pageSize?: number, sort?: BaseSort, order?: DocumentQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('documentsListDocumentsDocumentTypeContentIdGet', 'documentType', documentType)
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('documentsListDocumentsDocumentTypeContentIdGet', 'contentId', contentId)
            const localVarPath = `/documents/{document_type}/{content_id}/`
                .replace(`{${"document_type"}}`, encodeURIComponent(String(documentType)))
                .replace(`{${"content_id"}}`, encodeURIComponent(String(contentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create document
         * @param {DocumentType} documentType 
         * @param {ContentId} contentId 
         * @param {File} file 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCreateDocumentsDocumentTypeContentIdPost(documentType: DocumentType, contentId: ContentId, file: File, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCreateDocumentsDocumentTypeContentIdPost(documentType, contentId, file, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete document
         * @param {DocumentType} documentType 
         * @param {number} documentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDeleteDocumentsDocumentTypeDocumentIdDelete(documentType: DocumentType, documentId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDeleteDocumentsDocumentTypeDocumentIdDelete(documentType, documentId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get documents.  Permission required to access client/client document: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
         * @summary Get documents
         * @param {DocumentType} documentType 
         * @param {ContentId} contentId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {DocumentQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsListDocumentsDocumentTypeContentIdGet(documentType: DocumentType, contentId: ContentId, page?: number, pageSize?: number, sort?: BaseSort, order?: DocumentQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsListDocumentsDocumentTypeContentIdGet(documentType, contentId, page, pageSize, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Create a document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create document
         * @param {DocumentType} documentType 
         * @param {ContentId} contentId 
         * @param {File} file 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreateDocumentsDocumentTypeContentIdPost(documentType: DocumentType, contentId: ContentId, file: File, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.documentsCreateDocumentsDocumentTypeContentIdPost(documentType, contentId, file, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete document
         * @param {DocumentType} documentType 
         * @param {number} documentId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDeleteDocumentsDocumentTypeDocumentIdDelete(documentType: DocumentType, documentId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentsDeleteDocumentsDocumentTypeDocumentIdDelete(documentType, documentId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get documents.  Permission required to access client/client document: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
         * @summary Get documents
         * @param {DocumentType} documentType 
         * @param {ContentId} contentId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {DocumentQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsListDocumentsDocumentTypeContentIdGet(documentType: DocumentType, contentId: ContentId, page?: number, pageSize?: number, sort?: BaseSort, order?: DocumentQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<DocumentPageSchema> {
            return localVarFp.documentsListDocumentsDocumentTypeContentIdGet(documentType, contentId, page, pageSize, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for documentsCreateDocumentsDocumentTypeContentIdPost operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPostRequest
 */
export interface DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPostRequest {
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPost
     */
    readonly documentType: DocumentType

    /**
     * 
     * @type {ContentId}
     * @memberof DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPost
     */
    readonly contentId: ContentId

    /**
     * 
     * @type {File}
     * @memberof DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPost
     */
    readonly file: File

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for documentsDeleteDocumentsDocumentTypeDocumentIdDelete operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDeleteRequest
 */
export interface DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDeleteRequest {
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDelete
     */
    readonly documentType: DocumentType

    /**
     * 
     * @type {number}
     * @memberof DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDelete
     */
    readonly documentId: number

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for documentsListDocumentsDocumentTypeContentIdGet operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGetRequest
 */
export interface DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGetRequest {
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly documentType: DocumentType

    /**
     * 
     * @type {ContentId}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly contentId: ContentId

    /**
     * 
     * @type {number}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {DocumentQueryOrder}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly order?: DocumentQueryOrder

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Create a document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Create document
     * @param {DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCreateDocumentsDocumentTypeContentIdPost(requestParameters: DocumentsApiDocumentsCreateDocumentsDocumentTypeContentIdPostRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCreateDocumentsDocumentTypeContentIdPost(requestParameters.documentType, requestParameters.contentId, requestParameters.file, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete document.  Roles: is_staff  Permission required to access client/client document: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Delete document
     * @param {DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDeleteDocumentsDocumentTypeDocumentIdDelete(requestParameters: DocumentsApiDocumentsDeleteDocumentsDocumentTypeDocumentIdDeleteRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDeleteDocumentsDocumentTypeDocumentIdDelete(requestParameters.documentType, requestParameters.documentId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get documents.  Permission required to access client/client document: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier document: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
     * @summary Get documents
     * @param {DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsListDocumentsDocumentTypeContentIdGet(requestParameters: DocumentsApiDocumentsListDocumentsDocumentTypeContentIdGetRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsListDocumentsDocumentTypeContentIdGet(requestParameters.documentType, requestParameters.contentId, requestParameters.page, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FinancialAnalysisItemsReportsApi - axios parameter creator
 * @export
 */
export const FinancialAnalysisItemsReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export fin item report packaging list data.  Role check: is_staff. Permission: reports_can_view.
         * @summary Export fin item report packaging list data.
         * @param {DataExportType} exportType 
         * @param {BaseSort} [sort] 
         * @param {FinItemReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {Array<number>} [categoryIds] Financial analysis category ids.
         * @param {Array<number>} [finItemIds] Financial analysis item ids.
         * @param {Array<AnalyticsItemTypes>} [types] Financial analysis types.
         * @param {Array<AnalyticsItemActivityKinds>} [activityKinds] Activity kinds.
         * @param {number} [currencyId] Currency id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet: async (exportType: DataExportType, sort?: BaseSort, order?: FinItemReportQueryOrder, dateFrom?: string, dateTo?: string, categoryIds?: Array<number>, finItemIds?: Array<number>, types?: Array<AnalyticsItemTypes>, activityKinds?: Array<AnalyticsItemActivityKinds>, currencyId?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/financial-analysis-items/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (finItemIds) {
                localVarQueryParameter['finItemIds'] = finItemIds;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (activityKinds) {
                localVarQueryParameter['activityKinds'] = activityKinds;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current reports by bank financial analysis items.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports by bank financial analysis items
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {FinItemReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {Array<number>} [categoryIds] Financial analysis category ids.
         * @param {Array<number>} [finItemIds] Financial analysis item ids.
         * @param {Array<AnalyticsItemTypes>} [types] Financial analysis types.
         * @param {Array<AnalyticsItemActivityKinds>} [activityKinds] Activity kinds.
         * @param {number} [currencyId] Currency id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsFinItemsListReportsFinancialAnalysisItemsGet: async (page?: number, pageSize?: number, sort?: BaseSort, order?: FinItemReportQueryOrder, dateFrom?: string, dateTo?: string, categoryIds?: Array<number>, finItemIds?: Array<number>, types?: Array<AnalyticsItemTypes>, activityKinds?: Array<AnalyticsItemActivityKinds>, currencyId?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/financial-analysis-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (finItemIds) {
                localVarQueryParameter['finItemIds'] = finItemIds;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (activityKinds) {
                localVarQueryParameter['activityKinds'] = activityKinds;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinancialAnalysisItemsReportsApi - functional programming interface
 * @export
 */
export const FinancialAnalysisItemsReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinancialAnalysisItemsReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export fin item report packaging list data.  Role check: is_staff. Permission: reports_can_view.
         * @summary Export fin item report packaging list data.
         * @param {DataExportType} exportType 
         * @param {BaseSort} [sort] 
         * @param {FinItemReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {Array<number>} [categoryIds] Financial analysis category ids.
         * @param {Array<number>} [finItemIds] Financial analysis item ids.
         * @param {Array<AnalyticsItemTypes>} [types] Financial analysis types.
         * @param {Array<AnalyticsItemActivityKinds>} [activityKinds] Activity kinds.
         * @param {number} [currencyId] Currency id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet(exportType: DataExportType, sort?: BaseSort, order?: FinItemReportQueryOrder, dateFrom?: string, dateTo?: string, categoryIds?: Array<number>, finItemIds?: Array<number>, types?: Array<AnalyticsItemTypes>, activityKinds?: Array<AnalyticsItemActivityKinds>, currencyId?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet(exportType, sort, order, dateFrom, dateTo, categoryIds, finItemIds, types, activityKinds, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current reports by bank financial analysis items.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports by bank financial analysis items
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {FinItemReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {Array<number>} [categoryIds] Financial analysis category ids.
         * @param {Array<number>} [finItemIds] Financial analysis item ids.
         * @param {Array<AnalyticsItemTypes>} [types] Financial analysis types.
         * @param {Array<AnalyticsItemActivityKinds>} [activityKinds] Activity kinds.
         * @param {number} [currencyId] Currency id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsFinItemsListReportsFinancialAnalysisItemsGet(page?: number, pageSize?: number, sort?: BaseSort, order?: FinItemReportQueryOrder, dateFrom?: string, dateTo?: string, categoryIds?: Array<number>, finItemIds?: Array<number>, types?: Array<AnalyticsItemTypes>, activityKinds?: Array<AnalyticsItemActivityKinds>, currencyId?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinItemReportPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsFinItemsListReportsFinancialAnalysisItemsGet(page, pageSize, sort, order, dateFrom, dateTo, categoryIds, finItemIds, types, activityKinds, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FinancialAnalysisItemsReportsApi - factory interface
 * @export
 */
export const FinancialAnalysisItemsReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinancialAnalysisItemsReportsApiFp(configuration)
    return {
        /**
         * Export fin item report packaging list data.  Role check: is_staff. Permission: reports_can_view.
         * @summary Export fin item report packaging list data.
         * @param {DataExportType} exportType 
         * @param {BaseSort} [sort] 
         * @param {FinItemReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {Array<number>} [categoryIds] Financial analysis category ids.
         * @param {Array<number>} [finItemIds] Financial analysis item ids.
         * @param {Array<AnalyticsItemTypes>} [types] Financial analysis types.
         * @param {Array<AnalyticsItemActivityKinds>} [activityKinds] Activity kinds.
         * @param {number} [currencyId] Currency id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet(exportType: DataExportType, sort?: BaseSort, order?: FinItemReportQueryOrder, dateFrom?: string, dateTo?: string, categoryIds?: Array<number>, finItemIds?: Array<number>, types?: Array<AnalyticsItemTypes>, activityKinds?: Array<AnalyticsItemActivityKinds>, currencyId?: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet(exportType, sort, order, dateFrom, dateTo, categoryIds, finItemIds, types, activityKinds, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current reports by bank financial analysis items.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports by bank financial analysis items
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseSort} [sort] 
         * @param {FinItemReportQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {Array<number>} [categoryIds] Financial analysis category ids.
         * @param {Array<number>} [finItemIds] Financial analysis item ids.
         * @param {Array<AnalyticsItemTypes>} [types] Financial analysis types.
         * @param {Array<AnalyticsItemActivityKinds>} [activityKinds] Activity kinds.
         * @param {number} [currencyId] Currency id.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsFinItemsListReportsFinancialAnalysisItemsGet(page?: number, pageSize?: number, sort?: BaseSort, order?: FinItemReportQueryOrder, dateFrom?: string, dateTo?: string, categoryIds?: Array<number>, finItemIds?: Array<number>, types?: Array<AnalyticsItemTypes>, activityKinds?: Array<AnalyticsItemActivityKinds>, currencyId?: number, acceptLanguage?: string, options?: any): AxiosPromise<FinItemReportPage> {
            return localVarFp.reportsFinItemsListReportsFinancialAnalysisItemsGet(page, pageSize, sort, order, dateFrom, dateTo, categoryIds, finItemIds, types, activityKinds, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet operation in FinancialAnalysisItemsReportsApi.
 * @export
 * @interface FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGetRequest
 */
export interface FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {BaseSort}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {FinItemReportQueryOrder}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly order?: FinItemReportQueryOrder

    /**
     * Date from.
     * @type {string}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly dateTo?: string

    /**
     * Financial analysis category ids.
     * @type {Array<number>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly categoryIds?: Array<number>

    /**
     * Financial analysis item ids.
     * @type {Array<number>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly finItemIds?: Array<number>

    /**
     * Financial analysis types.
     * @type {Array<AnalyticsItemTypes>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly types?: Array<AnalyticsItemTypes>

    /**
     * Activity kinds.
     * @type {Array<AnalyticsItemActivityKinds>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly activityKinds?: Array<AnalyticsItemActivityKinds>

    /**
     * Currency id.
     * @type {number}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsFinItemsListReportsFinancialAnalysisItemsGet operation in FinancialAnalysisItemsReportsApi.
 * @export
 * @interface FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGetRequest
 */
export interface FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {FinItemReportQueryOrder}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly order?: FinItemReportQueryOrder

    /**
     * Date from.
     * @type {string}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly dateTo?: string

    /**
     * Financial analysis category ids.
     * @type {Array<number>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly categoryIds?: Array<number>

    /**
     * Financial analysis item ids.
     * @type {Array<number>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly finItemIds?: Array<number>

    /**
     * Financial analysis types.
     * @type {Array<AnalyticsItemTypes>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly types?: Array<AnalyticsItemTypes>

    /**
     * Activity kinds.
     * @type {Array<AnalyticsItemActivityKinds>}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly activityKinds?: Array<AnalyticsItemActivityKinds>

    /**
     * Currency id.
     * @type {number}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGet
     */
    readonly acceptLanguage?: string
}

/**
 * FinancialAnalysisItemsReportsApi - object-oriented interface
 * @export
 * @class FinancialAnalysisItemsReportsApi
 * @extends {BaseAPI}
 */
export class FinancialAnalysisItemsReportsApi extends BaseAPI {
    /**
     * Export fin item report packaging list data.  Role check: is_staff. Permission: reports_can_view.
     * @summary Export fin item report packaging list data.
     * @param {FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialAnalysisItemsReportsApi
     */
    public reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet(requestParameters: FinancialAnalysisItemsReportsApiReportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGetRequest, options?: AxiosRequestConfig) {
        return FinancialAnalysisItemsReportsApiFp(this.configuration).reportsFinItemsExportPackagingListReportsFinancialAnalysisItemsExportTypeGet(requestParameters.exportType, requestParameters.sort, requestParameters.order, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.categoryIds, requestParameters.finItemIds, requestParameters.types, requestParameters.activityKinds, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current reports by bank financial analysis items.  Role check: is_staff Permission: reports_can_view
     * @summary Get current reports by bank financial analysis items
     * @param {FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialAnalysisItemsReportsApi
     */
    public reportsFinItemsListReportsFinancialAnalysisItemsGet(requestParameters: FinancialAnalysisItemsReportsApiReportsFinItemsListReportsFinancialAnalysisItemsGetRequest = {}, options?: AxiosRequestConfig) {
        return FinancialAnalysisItemsReportsApiFp(this.configuration).reportsFinItemsListReportsFinancialAnalysisItemsGet(requestParameters.page, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.categoryIds, requestParameters.finItemIds, requestParameters.types, requestParameters.activityKinds, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HistoryApi - axios parameter creator
 * @export
 */
export const HistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each log history_type:  User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view  Additional permissions for a client and supplier (only if request user is not a manager of this client/supplier):  crm_view_other_manager_client_access warehouse_view_other_manager_supplier_access
         * @summary List of auth history logs.
         * @param {string} userId 
         * @param {UserTypes} userType User type.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyAuthListHistoryAuthHistoryUserIdGet: async (userId: string, userType: UserTypes, dateCreatedFrom?: string, dateCreatedTo?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('historyAuthListHistoryAuthHistoryUserIdGet', 'userId', userId)
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('historyAuthListHistoryAuthHistoryUserIdGet', 'userType', userType)
            const localVarPath = `/history/auth-history/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (userType !== undefined) {
                localVarQueryParameter['userType'] = userType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - crm_view_client_order ClientProforma - crm_view_client_proforma ClientInvoice - crm_view_client_invoice ClientProductReturn - crm_view_client_returns SupplierOrder - warehouse_view_supplier_order SupplierProforma - warehouse_view_supplier_proforma SupplierInvoice - warehouse_view_supplier_invoice SupplierProductReturn - warehouse_view_supplier_returns User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view
         * @summary List of history logs creators for select.
         * @param {ObjectId} objectId 
         * @param {HistoryTypes} historyType 
         * @param {string} [searchFilterSelect] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyCreatorsListHistoryCreatorsObjectIdGet: async (objectId: ObjectId, historyType: HistoryTypes, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('historyCreatorsListHistoryCreatorsObjectIdGet', 'objectId', objectId)
            // verify required parameter 'historyType' is not null or undefined
            assertParamExists('historyCreatorsListHistoryCreatorsObjectIdGet', 'historyType', historyType)
            const localVarPath = `/history/creators/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (historyType !== undefined) {
                localVarQueryParameter['historyType'] = historyType;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - client_order_view ClientProforma - client_proforma_view ClientInvoice - client_invoice_view ClientProductReturn - client_returns_view SupplierOrder - supplier_order_view SupplierProforma - supplier_proforma_view SupplierInvoice - supplier_invoice_view SupplierProductReturn - supplier_returns_view User (AGENT) - agent_view User (CLIENT) - client_view User (SUPPLIER) - supplier_view User (STAFF) - staff_view
         * @summary List of history logs.
         * @param {ObjectId} objectId 
         * @param {HistoryTypes} historyType 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {string} [creatorId] 
         * @param {BaseSort} [sort] 
         * @param {HistoryLogQueryOrder} [order] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyListHistoryObjectIdGet: async (objectId: ObjectId, historyType: HistoryTypes, dateCreatedFrom?: string, dateCreatedTo?: string, creatorId?: string, sort?: BaseSort, order?: HistoryLogQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('historyListHistoryObjectIdGet', 'objectId', objectId)
            // verify required parameter 'historyType' is not null or undefined
            assertParamExists('historyListHistoryObjectIdGet', 'historyType', historyType)
            const localVarPath = `/history/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (historyType !== undefined) {
                localVarQueryParameter['historyType'] = historyType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each log history_type:  User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view  Additional permissions for a client and supplier (only if request user is not a manager of this client/supplier):  crm_view_other_manager_client_access warehouse_view_other_manager_supplier_access
         * @summary List of auth history logs.
         * @param {string} userId 
         * @param {UserTypes} userType User type.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historyAuthListHistoryAuthHistoryUserIdGet(userId: string, userType: UserTypes, dateCreatedFrom?: string, dateCreatedTo?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historyAuthListHistoryAuthHistoryUserIdGet(userId, userType, dateCreatedFrom, dateCreatedTo, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - crm_view_client_order ClientProforma - crm_view_client_proforma ClientInvoice - crm_view_client_invoice ClientProductReturn - crm_view_client_returns SupplierOrder - warehouse_view_supplier_order SupplierProforma - warehouse_view_supplier_proforma SupplierInvoice - warehouse_view_supplier_invoice SupplierProductReturn - warehouse_view_supplier_returns User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view
         * @summary List of history logs creators for select.
         * @param {ObjectId} objectId 
         * @param {HistoryTypes} historyType 
         * @param {string} [searchFilterSelect] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historyCreatorsListHistoryCreatorsObjectIdGet(objectId: ObjectId, historyType: HistoryTypes, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryLogCreatorsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historyCreatorsListHistoryCreatorsObjectIdGet(objectId, historyType, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - client_order_view ClientProforma - client_proforma_view ClientInvoice - client_invoice_view ClientProductReturn - client_returns_view SupplierOrder - supplier_order_view SupplierProforma - supplier_proforma_view SupplierInvoice - supplier_invoice_view SupplierProductReturn - supplier_returns_view User (AGENT) - agent_view User (CLIENT) - client_view User (SUPPLIER) - supplier_view User (STAFF) - staff_view
         * @summary List of history logs.
         * @param {ObjectId} objectId 
         * @param {HistoryTypes} historyType 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {string} [creatorId] 
         * @param {BaseSort} [sort] 
         * @param {HistoryLogQueryOrder} [order] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historyListHistoryObjectIdGet(objectId: ObjectId, historyType: HistoryTypes, dateCreatedFrom?: string, dateCreatedTo?: string, creatorId?: string, sort?: BaseSort, order?: HistoryLogQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryLogPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historyListHistoryObjectIdGet(objectId, historyType, dateCreatedFrom, dateCreatedTo, creatorId, sort, order, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HistoryApiFp(configuration)
    return {
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each log history_type:  User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view  Additional permissions for a client and supplier (only if request user is not a manager of this client/supplier):  crm_view_other_manager_client_access warehouse_view_other_manager_supplier_access
         * @summary List of auth history logs.
         * @param {string} userId 
         * @param {UserTypes} userType User type.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyAuthListHistoryAuthHistoryUserIdGet(userId: string, userType: UserTypes, dateCreatedFrom?: string, dateCreatedTo?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<AuthLogPage> {
            return localVarFp.historyAuthListHistoryAuthHistoryUserIdGet(userId, userType, dateCreatedFrom, dateCreatedTo, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - crm_view_client_order ClientProforma - crm_view_client_proforma ClientInvoice - crm_view_client_invoice ClientProductReturn - crm_view_client_returns SupplierOrder - warehouse_view_supplier_order SupplierProforma - warehouse_view_supplier_proforma SupplierInvoice - warehouse_view_supplier_invoice SupplierProductReturn - warehouse_view_supplier_returns User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view
         * @summary List of history logs creators for select.
         * @param {ObjectId} objectId 
         * @param {HistoryTypes} historyType 
         * @param {string} [searchFilterSelect] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyCreatorsListHistoryCreatorsObjectIdGet(objectId: ObjectId, historyType: HistoryTypes, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<HistoryLogCreatorsPage> {
            return localVarFp.historyCreatorsListHistoryCreatorsObjectIdGet(objectId, historyType, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - client_order_view ClientProforma - client_proforma_view ClientInvoice - client_invoice_view ClientProductReturn - client_returns_view SupplierOrder - supplier_order_view SupplierProforma - supplier_proforma_view SupplierInvoice - supplier_invoice_view SupplierProductReturn - supplier_returns_view User (AGENT) - agent_view User (CLIENT) - client_view User (SUPPLIER) - supplier_view User (STAFF) - staff_view
         * @summary List of history logs.
         * @param {ObjectId} objectId 
         * @param {HistoryTypes} historyType 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {string} [creatorId] 
         * @param {BaseSort} [sort] 
         * @param {HistoryLogQueryOrder} [order] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyListHistoryObjectIdGet(objectId: ObjectId, historyType: HistoryTypes, dateCreatedFrom?: string, dateCreatedTo?: string, creatorId?: string, sort?: BaseSort, order?: HistoryLogQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<HistoryLogPage> {
            return localVarFp.historyListHistoryObjectIdGet(objectId, historyType, dateCreatedFrom, dateCreatedTo, creatorId, sort, order, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for historyAuthListHistoryAuthHistoryUserIdGet operation in HistoryApi.
 * @export
 * @interface HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGetRequest
 */
export interface HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly userId: string

    /**
     * User type.
     * @type {UserTypes}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly userType: UserTypes

    /**
     * Date from.
     * @type {string}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly dateCreatedTo?: string

    /**
     * 
     * @type {number}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for historyCreatorsListHistoryCreatorsObjectIdGet operation in HistoryApi.
 * @export
 * @interface HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGetRequest
 */
export interface HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGetRequest {
    /**
     * 
     * @type {ObjectId}
     * @memberof HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGet
     */
    readonly objectId: ObjectId

    /**
     * 
     * @type {HistoryTypes}
     * @memberof HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGet
     */
    readonly historyType: HistoryTypes

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for historyListHistoryObjectIdGet operation in HistoryApi.
 * @export
 * @interface HistoryApiHistoryListHistoryObjectIdGetRequest
 */
export interface HistoryApiHistoryListHistoryObjectIdGetRequest {
    /**
     * 
     * @type {ObjectId}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly objectId: ObjectId

    /**
     * 
     * @type {HistoryTypes}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly historyType: HistoryTypes

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly dateCreatedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly dateCreatedTo?: string

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {HistoryLogQueryOrder}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly order?: HistoryLogQueryOrder

    /**
     * 
     * @type {number}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof HistoryApiHistoryListHistoryObjectIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI {
    /**
     * Get history logs.  Role check: is_staff.  Permissions for each log history_type:  User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view  Additional permissions for a client and supplier (only if request user is not a manager of this client/supplier):  crm_view_other_manager_client_access warehouse_view_other_manager_supplier_access
     * @summary List of auth history logs.
     * @param {HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public historyAuthListHistoryAuthHistoryUserIdGet(requestParameters: HistoryApiHistoryAuthListHistoryAuthHistoryUserIdGetRequest, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).historyAuthListHistoryAuthHistoryUserIdGet(requestParameters.userId, requestParameters.userType, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - crm_view_client_order ClientProforma - crm_view_client_proforma ClientInvoice - crm_view_client_invoice ClientProductReturn - crm_view_client_returns SupplierOrder - warehouse_view_supplier_order SupplierProforma - warehouse_view_supplier_proforma SupplierInvoice - warehouse_view_supplier_invoice SupplierProductReturn - warehouse_view_supplier_returns User (AGENT) - crm_view_agent_access User (CLIENT) - crm_view_clients User (SUPPLIER) - warehouse_view_suppliers User (STAFF) - staff_view
     * @summary List of history logs creators for select.
     * @param {HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public historyCreatorsListHistoryCreatorsObjectIdGet(requestParameters: HistoryApiHistoryCreatorsListHistoryCreatorsObjectIdGetRequest, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).historyCreatorsListHistoryCreatorsObjectIdGet(requestParameters.objectId, requestParameters.historyType, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get history logs.  Role check: is_staff.  Permissions for each history_type: CONTRACT (CLIENT_CONTRACT/SUPPLIER_CONTRACT) - crm_view_client_contract/warehouse_view_supplier_contract ClientOrder - client_order_view ClientProforma - client_proforma_view ClientInvoice - client_invoice_view ClientProductReturn - client_returns_view SupplierOrder - supplier_order_view SupplierProforma - supplier_proforma_view SupplierInvoice - supplier_invoice_view SupplierProductReturn - supplier_returns_view User (AGENT) - agent_view User (CLIENT) - client_view User (SUPPLIER) - supplier_view User (STAFF) - staff_view
     * @summary List of history logs.
     * @param {HistoryApiHistoryListHistoryObjectIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public historyListHistoryObjectIdGet(requestParameters: HistoryApiHistoryListHistoryObjectIdGetRequest, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).historyListHistoryObjectIdGet(requestParameters.objectId, requestParameters.historyType, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.creatorId, requestParameters.sort, requestParameters.order, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesClientApi - axios parameter creator
 * @export
 */
export const InvoicesClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get additional expense list for client invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get additional expenses for client invoice.
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/clients/{invoice_id}/additional-expenses/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update comments for client additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update comments for client additional expenses
         * @param {number} invoiceId 
         * @param {AdditionalExpenseUpdateCommentsSchema} additionalExpenseUpdateCommentsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut: async (invoiceId: number, additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut', 'invoiceId', invoiceId)
            // verify required parameter 'additionalExpenseUpdateCommentsSchema' is not null or undefined
            assertParamExists('clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut', 'additionalExpenseUpdateCommentsSchema', additionalExpenseUpdateCommentsSchema)
            const localVarPath = `/invoices/clients/{invoice_id}/additional-expenses/comments/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(additionalExpenseUpdateCommentsSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new client invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new client invoice
         * @param {ClientInvoiceCreateSchema} clientInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesCreateOneInvoicesClientsPost: async (clientInvoiceCreateSchema: ClientInvoiceCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientInvoiceCreateSchema' is not null or undefined
            assertParamExists('clientInvoicesCreateOneInvoicesClientsPost', 'clientInvoiceCreateSchema', clientInvoiceCreateSchema)
            const localVarPath = `/invoices/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientInvoiceCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get income by client invoice. Only for invoices with \"conducted\" status.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
         * @summary Get income by client invoice
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/clients/{invoice_id}/income/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
         * @summary Get client invoice detail
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesGetOneInvoicesClientsInvoiceIdGet: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesGetOneInvoicesClientsInvoiceIdGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/clients/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
         * @param {number} invoiceId 
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet: async (invoiceId: number, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/clients/{invoice_id}/invoice-nomenclatures/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesListInvoicesClientsGet: async (page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (excludeInactiveForAdditionalExpense !== undefined) {
                localVarQueryParameter['excludeInactiveForAdditionalExpense'] = excludeInactiveForAdditionalExpense;
            }

            if (hasDebt !== undefined) {
                localVarQueryParameter['hasDebt'] = hasDebt;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (deliveryStatus !== undefined) {
                localVarQueryParameter['deliveryStatus'] = deliveryStatus;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client invoice list without pagination.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list without pagination.
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet: async (order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/clients/no-pagination/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (excludeInactiveForAdditionalExpense !== undefined) {
                localVarQueryParameter['excludeInactiveForAdditionalExpense'] = excludeInactiveForAdditionalExpense;
            }

            if (hasDebt !== undefined) {
                localVarQueryParameter['hasDebt'] = hasDebt;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (deliveryStatus !== undefined) {
                localVarQueryParameter['deliveryStatus'] = deliveryStatus;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesListSelectInvoicesClientsSelectGet: async (page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/clients/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (excludeInactiveForAdditionalExpense !== undefined) {
                localVarQueryParameter['excludeInactiveForAdditionalExpense'] = excludeInactiveForAdditionalExpense;
            }

            if (hasDebt !== undefined) {
                localVarQueryParameter['hasDebt'] = hasDebt;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (deliveryStatus !== undefined) {
                localVarQueryParameter['deliveryStatus'] = deliveryStatus;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change client invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_cancel_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change client invoice status to created
         * @param {number} invoiceId 
         * @param {ClientInvoiceCancellationSchema} clientInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut: async (invoiceId: number, clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut', 'invoiceId', invoiceId)
            // verify required parameter 'clientInvoiceCancellationSchema' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut', 'clientInvoiceCancellationSchema', clientInvoiceCancellationSchema)
            const localVarPath = `/invoices/clients/{invoice_id}/cancel/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientInvoiceCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client invoice delivery status.  Only for status \"conducted\". Unable to set the delivery status to \"shipped\" if the invoice delivery type is not \"self_delivery\".  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update delivery status for conducted invoice
         * @param {number} invoiceId 
         * @param {ClientInvoiceDeliveryStatusUpdateSchema} clientInvoiceDeliveryStatusUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut: async (invoiceId: number, clientInvoiceDeliveryStatusUpdateSchema: ClientInvoiceDeliveryStatusUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut', 'invoiceId', invoiceId)
            // verify required parameter 'clientInvoiceDeliveryStatusUpdateSchema' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut', 'clientInvoiceDeliveryStatusUpdateSchema', clientInvoiceDeliveryStatusUpdateSchema)
            const localVarPath = `/invoices/clients/{invoice_id}/change-delivery-status/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientInvoiceDeliveryStatusUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change client invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change client invoice status to deleted
         * @param {number} invoiceId 
         * @param {ClientInvoiceCancellationSchema} clientInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut: async (invoiceId: number, clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut', 'invoiceId', invoiceId)
            // verify required parameter 'clientInvoiceCancellationSchema' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut', 'clientInvoiceCancellationSchema', clientInvoiceCancellationSchema)
            const localVarPath = `/invoices/clients/{invoice_id}/delete/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientInvoiceCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update client invoice
         * @param {number} invoiceId 
         * @param {ClientInvoiceUpdateSchema} clientInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut: async (invoiceId: number, clientInvoiceUpdateSchema: ClientInvoiceUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut', 'invoiceId', invoiceId)
            // verify required parameter 'clientInvoiceUpdateSchema' is not null or undefined
            assertParamExists('clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut', 'clientInvoiceUpdateSchema', clientInvoiceUpdateSchema)
            const localVarPath = `/invoices/clients/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientInvoiceUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice CMR data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet: async (invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet', 'invoiceId', invoiceId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet', 'exportType', exportType)
            const localVarPath = `/invoices/clients/{invoice_id}/invoice-cmr/{export_type}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice delivery note data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet: async (invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet', 'invoiceId', invoiceId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet', 'exportType', exportType)
            const localVarPath = `/invoices/clients/{invoice_id}/invoice-delivery-note/{export_type}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export invoice data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet: async (invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet', 'invoiceId', invoiceId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet', 'exportType', exportType)
            const localVarPath = `/invoices/clients/{invoice_id}/invoice/{export_type}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export packaging list data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice packaging list data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet: async (invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet', 'invoiceId', invoiceId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet', 'exportType', exportType)
            const localVarPath = `/invoices/clients/{invoice_id}/invoice-packaging-list/{export_type}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesClientApi - functional programming interface
 * @export
 */
export const InvoicesClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Get additional expense list for client invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get additional expenses for client invoice.
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientNomenclatureAdditionalExpenseListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update comments for client additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update comments for client additional expenses
         * @param {number} invoiceId 
         * @param {AdditionalExpenseUpdateCommentsSchema} additionalExpenseUpdateCommentsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut(invoiceId: number, additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientNomenclatureAdditionalExpenseListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut(invoiceId, additionalExpenseUpdateCommentsSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new client invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new client invoice
         * @param {ClientInvoiceCreateSchema} clientInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesCreateOneInvoicesClientsPost(clientInvoiceCreateSchema: ClientInvoiceCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesCreateOneInvoicesClientsPost(clientInvoiceCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get income by client invoice. Only for invoices with \"conducted\" status.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
         * @summary Get income by client invoice
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceIncomeListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
         * @summary Get client invoice detail
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesGetOneInvoicesClientsInvoiceIdGet(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesGetOneInvoicesClientsInvoiceIdGet(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
         * @param {number} invoiceId 
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet(invoiceId: number, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceNomenclaturePageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet(invoiceId, unit, searchFilter, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesListInvoicesClientsGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoicePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesListInvoicesClientsGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, clientCategoryId, clientType, isCashPayment, agentId, deliveryStatus, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client invoice list without pagination.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list without pagination.
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet(order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientInvoiceListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet(order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, clientCategoryId, clientType, isCashPayment, agentId, deliveryStatus, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesListSelectInvoicesClientsSelectGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectInvoicePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesListSelectInvoicesClientsSelectGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, clientCategoryId, clientType, isCashPayment, agentId, deliveryStatus, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change client invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_cancel_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change client invoice status to created
         * @param {number} invoiceId 
         * @param {ClientInvoiceCancellationSchema} clientInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut(invoiceId: number, clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut(invoiceId, clientInvoiceCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client invoice delivery status.  Only for status \"conducted\". Unable to set the delivery status to \"shipped\" if the invoice delivery type is not \"self_delivery\".  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update delivery status for conducted invoice
         * @param {number} invoiceId 
         * @param {ClientInvoiceDeliveryStatusUpdateSchema} clientInvoiceDeliveryStatusUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut(invoiceId: number, clientInvoiceDeliveryStatusUpdateSchema: ClientInvoiceDeliveryStatusUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut(invoiceId, clientInvoiceDeliveryStatusUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change client invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change client invoice status to deleted
         * @param {number} invoiceId 
         * @param {ClientInvoiceCancellationSchema} clientInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut(invoiceId: number, clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut(invoiceId, clientInvoiceCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update client invoice
         * @param {number} invoiceId 
         * @param {ClientInvoiceUpdateSchema} clientInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut(invoiceId: number, clientInvoiceUpdateSchema: ClientInvoiceUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut(invoiceId, clientInvoiceUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice CMR data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet(invoiceId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice delivery note data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet(invoiceId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export invoice data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet(invoiceId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export packaging list data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice packaging list data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet(invoiceId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesClientApi - factory interface
 * @export
 */
export const InvoicesClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesClientApiFp(configuration)
    return {
        /**
         * Get additional expense list for client invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get additional expenses for client invoice.
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<Array<ClientNomenclatureAdditionalExpenseListSchema>> {
            return localVarFp.clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update comments for client additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update comments for client additional expenses
         * @param {number} invoiceId 
         * @param {AdditionalExpenseUpdateCommentsSchema} additionalExpenseUpdateCommentsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut(invoiceId: number, additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema, acceptLanguage?: string, options?: any): AxiosPromise<Array<ClientNomenclatureAdditionalExpenseListSchema>> {
            return localVarFp.clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut(invoiceId, additionalExpenseUpdateCommentsSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new client invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new client invoice
         * @param {ClientInvoiceCreateSchema} clientInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesCreateOneInvoicesClientsPost(clientInvoiceCreateSchema: ClientInvoiceCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceDetailSchema> {
            return localVarFp.clientInvoicesCreateOneInvoicesClientsPost(clientInvoiceCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get income by client invoice. Only for invoices with \"conducted\" status.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
         * @summary Get income by client invoice
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceIncomeListSchema> {
            return localVarFp.clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
         * @summary Get client invoice detail
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesGetOneInvoicesClientsInvoiceIdGet(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceDetailSchema> {
            return localVarFp.clientInvoicesGetOneInvoicesClientsInvoiceIdGet(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
         * @param {number} invoiceId 
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet(invoiceId: number, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceNomenclaturePageSchema> {
            return localVarFp.clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet(invoiceId, unit, searchFilter, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesListInvoicesClientsGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoicePage> {
            return localVarFp.clientInvoicesListInvoicesClientsGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, clientCategoryId, clientType, isCashPayment, agentId, deliveryStatus, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client invoice list without pagination.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list without pagination.
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet(order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options?: any): AxiosPromise<Array<ClientInvoiceListSchema>> {
            return localVarFp.clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet(order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, clientCategoryId, clientType, isCashPayment, agentId, deliveryStatus, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
         * @summary Get client invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [agentId] 
         * @param {InvoiceDeliveryStatuses} [deliveryStatus] 
         * @param {ClientInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesListSelectInvoicesClientsSelectGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, isCashPayment?: boolean, agentId?: string, deliveryStatus?: InvoiceDeliveryStatuses, labels?: ClientInvoiceLabels, acceptLanguage?: string, options?: any): AxiosPromise<SelectInvoicePage> {
            return localVarFp.clientInvoicesListSelectInvoicesClientsSelectGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, clientCategoryId, clientType, isCashPayment, agentId, deliveryStatus, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change client invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_cancel_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change client invoice status to created
         * @param {number} invoiceId 
         * @param {ClientInvoiceCancellationSchema} clientInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut(invoiceId: number, clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceDetailSchema> {
            return localVarFp.clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut(invoiceId, clientInvoiceCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client invoice delivery status.  Only for status \"conducted\". Unable to set the delivery status to \"shipped\" if the invoice delivery type is not \"self_delivery\".  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update delivery status for conducted invoice
         * @param {number} invoiceId 
         * @param {ClientInvoiceDeliveryStatusUpdateSchema} clientInvoiceDeliveryStatusUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut(invoiceId: number, clientInvoiceDeliveryStatusUpdateSchema: ClientInvoiceDeliveryStatusUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceDetailSchema> {
            return localVarFp.clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut(invoiceId, clientInvoiceDeliveryStatusUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change client invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change client invoice status to deleted
         * @param {number} invoiceId 
         * @param {ClientInvoiceCancellationSchema} clientInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut(invoiceId: number, clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceDetailSchema> {
            return localVarFp.clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut(invoiceId, clientInvoiceCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update client invoice
         * @param {number} invoiceId 
         * @param {ClientInvoiceUpdateSchema} clientInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut(invoiceId: number, clientInvoiceUpdateSchema: ClientInvoiceUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoiceDetailSchema> {
            return localVarFp.clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut(invoiceId, clientInvoiceUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice CMR data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet(invoiceId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice delivery note data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet(invoiceId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export invoice data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet(invoiceId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export packaging list data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
         * @summary Export client invoice packaging list data.
         * @param {number} invoiceId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet(invoiceId: number, exportType: DataExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet(invoiceId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGetRequest
 */
export interface InvoicesClientApiClientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPutRequest
 */
export interface InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {AdditionalExpenseUpdateCommentsSchema}
     * @memberof InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut
     */
    readonly additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesCreateOneInvoicesClientsPost operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesCreateOneInvoicesClientsPostRequest
 */
export interface InvoicesClientApiClientInvoicesCreateOneInvoicesClientsPostRequest {
    /**
     * 
     * @type {ClientInvoiceCreateSchema}
     * @memberof InvoicesClientApiClientInvoicesCreateOneInvoicesClientsPost
     */
    readonly clientInvoiceCreateSchema: ClientInvoiceCreateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesCreateOneInvoicesClientsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGetRequest
 */
export interface InvoicesClientApiClientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesGetOneInvoicesClientsInvoiceIdGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesGetOneInvoicesClientsInvoiceIdGetRequest
 */
export interface InvoicesClientApiClientInvoicesGetOneInvoicesClientsInvoiceIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesGetOneInvoicesClientsInvoiceIdGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesGetOneInvoicesClientsInvoiceIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGetRequest
 */
export interface InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet
     */
    readonly invoiceId: number

    /**
     * Filtering by unit. All units is default.
     * @type {UnitFilter}
     * @memberof InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet
     */
    readonly unit?: UnitFilter

    /**
     * Search by name or vendor code.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesListInvoicesClientsGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesListInvoicesClientsGetRequest
 */
export interface InvoicesClientApiClientInvoicesListInvoicesClientsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseInvoiceQueryOrder}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly order?: BaseInvoiceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly dateConductionTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly status?: InvoiceStatuses

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly staffId?: string

    /**
     * Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly excludeInactiveForAdditionalExpense?: boolean

    /**
     * Filter by invoices with sum to pay &gt; 0.
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly hasDebt?: boolean

    /**
     * Search by documentNumber(year, number, suffix)
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly searchFilterSelect?: string

    /**
     * Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly clientCategoryId?: number

    /**
     * 
     * @type {ClientTypes}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly clientType?: ClientTypes

    /**
     * Filtering by payment kind
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly isCashPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {InvoiceDeliveryStatuses}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly deliveryStatus?: InvoiceDeliveryStatuses

    /**
     * 
     * @type {ClientInvoiceLabels}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly labels?: ClientInvoiceLabels

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListInvoicesClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGetRequest
 */
export interface InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGetRequest {
    /**
     * 
     * @type {BaseInvoiceQueryOrder}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly order?: BaseInvoiceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly dateConductionTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly status?: InvoiceStatuses

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly staffId?: string

    /**
     * Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly excludeInactiveForAdditionalExpense?: boolean

    /**
     * Filter by invoices with sum to pay &gt; 0.
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly hasDebt?: boolean

    /**
     * Search by documentNumber(year, number, suffix)
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly searchFilterSelect?: string

    /**
     * Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly clientCategoryId?: number

    /**
     * 
     * @type {ClientTypes}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly clientType?: ClientTypes

    /**
     * Filtering by payment kind
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly isCashPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {InvoiceDeliveryStatuses}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly deliveryStatus?: InvoiceDeliveryStatuses

    /**
     * 
     * @type {ClientInvoiceLabels}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly labels?: ClientInvoiceLabels

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesListSelectInvoicesClientsSelectGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGetRequest
 */
export interface InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseInvoiceQueryOrder}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly order?: BaseInvoiceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly dateConductionTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly status?: InvoiceStatuses

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly staffId?: string

    /**
     * Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly excludeInactiveForAdditionalExpense?: boolean

    /**
     * Filter by invoices with sum to pay &gt; 0.
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly hasDebt?: boolean

    /**
     * Search by documentNumber(year, number, suffix)
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Search by id, documentNumber(year, number, suffix), client(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly clientCategoryId?: number

    /**
     * 
     * @type {ClientTypes}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly clientType?: ClientTypes

    /**
     * Filtering by payment kind
     * @type {boolean}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly isCashPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {InvoiceDeliveryStatuses}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly deliveryStatus?: InvoiceDeliveryStatuses

    /**
     * 
     * @type {ClientInvoiceLabels}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly labels?: ClientInvoiceLabels

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPutRequest
 */
export interface InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {ClientInvoiceCancellationSchema}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut
     */
    readonly clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPutRequest
 */
export interface InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {ClientInvoiceDeliveryStatusUpdateSchema}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut
     */
    readonly clientInvoiceDeliveryStatusUpdateSchema: ClientInvoiceDeliveryStatusUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePutRequest
 */
export interface InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {ClientInvoiceCancellationSchema}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut
     */
    readonly clientInvoiceCancellationSchema: ClientInvoiceCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPutRequest
 */
export interface InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {ClientInvoiceUpdateSchema}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPut
     */
    readonly clientInvoiceUpdateSchema: ClientInvoiceUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGetRequest
 */
export interface InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGetRequest
 */
export interface InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGetRequest
 */
export interface InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet operation in InvoicesClientApi.
 * @export
 * @interface InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGetRequest
 */
export interface InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * InvoicesClientApi - object-oriented interface
 * @export
 * @class InvoicesClientApi
 * @extends {BaseAPI}
 */
export class InvoicesClientApi extends BaseAPI {
    /**
     * Get additional expense list for client invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: crm_view_client_invoice.
     * @summary Get additional expenses for client invoice.
     * @param {InvoicesClientApiClientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet(requestParameters: InvoicesClientApiClientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesAdditionalExpensesListInvoicesClientsInvoiceIdAdditionalExpensesGet(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update comments for client additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
     * @summary Update comments for client additional expenses
     * @param {InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut(requestParameters: InvoicesClientApiClientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPutRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesAdditionalExpensesUpdateOneCommentsInvoicesClientsInvoiceIdAdditionalExpensesCommentsPut(requestParameters.invoiceId, requestParameters.additionalExpenseUpdateCommentsSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new client invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
     * @summary Create new client invoice
     * @param {InvoicesClientApiClientInvoicesCreateOneInvoicesClientsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesCreateOneInvoicesClientsPost(requestParameters: InvoicesClientApiClientInvoicesCreateOneInvoicesClientsPostRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesCreateOneInvoicesClientsPost(requestParameters.clientInvoiceCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get income by client invoice. Only for invoices with \"conducted\" status.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
     * @summary Get income by client invoice
     * @param {InvoicesClientApiClientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet(requestParameters: InvoicesClientApiClientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesGetOneIncomeInvoicesClientsInvoiceIdIncomeGet(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_invoice\'.
     * @summary Get client invoice detail
     * @param {InvoicesClientApiClientInvoicesGetOneInvoicesClientsInvoiceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesGetOneInvoicesClientsInvoiceIdGet(requestParameters: InvoicesClientApiClientInvoicesGetOneInvoicesClientsInvoiceIdGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesGetOneInvoicesClientsInvoiceIdGet(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
     * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
     * @param {InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet(requestParameters: InvoicesClientApiClientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesInvoiceNomenclaturesGetAllInvoicesClientsInvoiceIdInvoiceNomenclaturesGet(requestParameters.invoiceId, requestParameters.unit, requestParameters.searchFilter, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
     * @summary Get client invoice list.
     * @param {InvoicesClientApiClientInvoicesListInvoicesClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesListInvoicesClientsGet(requestParameters: InvoicesClientApiClientInvoicesListInvoicesClientsGetRequest = {}, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesListInvoicesClientsGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.excludeInactiveForAdditionalExpense, requestParameters.hasDebt, requestParameters.searchFilterSelect, requestParameters.searchFilter, requestParameters.clientCategoryId, requestParameters.clientType, requestParameters.isCashPayment, requestParameters.agentId, requestParameters.deliveryStatus, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client invoice list without pagination.  Role check: is_staff.  Permission: crm_view_client_invoice.
     * @summary Get client invoice list without pagination.
     * @param {InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet(requestParameters: InvoicesClientApiClientInvoicesListNoPaginationInvoicesClientsNoPaginationGetRequest = {}, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesListNoPaginationInvoicesClientsNoPaginationGet(requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.excludeInactiveForAdditionalExpense, requestParameters.hasDebt, requestParameters.searchFilterSelect, requestParameters.searchFilter, requestParameters.clientCategoryId, requestParameters.clientType, requestParameters.isCashPayment, requestParameters.agentId, requestParameters.deliveryStatus, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a client invoice list.  Role check: is_staff.  Permission: crm_view_client_invoice.
     * @summary Get client invoice list.
     * @param {InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesListSelectInvoicesClientsSelectGet(requestParameters: InvoicesClientApiClientInvoicesListSelectInvoicesClientsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesListSelectInvoicesClientsSelectGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.excludeInactiveForAdditionalExpense, requestParameters.hasDebt, requestParameters.searchFilterSelect, requestParameters.searchFilter, requestParameters.clientCategoryId, requestParameters.clientType, requestParameters.isCashPayment, requestParameters.agentId, requestParameters.deliveryStatus, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change client invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'crm_cancel_client_invoice\'.  Role needed: \'is_staff\'.
     * @summary Change client invoice status to created
     * @param {InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut(requestParameters: InvoicesClientApiClientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPutRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesUpdateOneCancelInvoicesClientsInvoiceIdCancelPut(requestParameters.invoiceId, requestParameters.clientInvoiceCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client invoice delivery status.  Only for status \"conducted\". Unable to set the delivery status to \"shipped\" if the invoice delivery type is not \"self_delivery\".  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
     * @summary Update delivery status for conducted invoice
     * @param {InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut(requestParameters: InvoicesClientApiClientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPutRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesUpdateOneChangeDeliveryStatusInvoicesClientsInvoiceIdChangeDeliveryStatusPut(requestParameters.invoiceId, requestParameters.clientInvoiceDeliveryStatusUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change client invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
     * @summary Change client invoice status to deleted
     * @param {InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut(requestParameters: InvoicesClientApiClientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePutRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesUpdateOneDeleteInvoicesClientsInvoiceIdDeletePut(requestParameters.invoiceId, requestParameters.clientInvoiceCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/clients/{order_id}/order-nomenclatures/  Perms needed: \'crm_change_client_invoice\'.  Role needed: \'is_staff\'.
     * @summary Update client invoice
     * @param {InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut(requestParameters: InvoicesClientApiClientInvoicesUpdateOneInvoicesClientsInvoiceIdPutRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).clientInvoicesUpdateOneInvoicesClientsInvoiceIdPut(requestParameters.invoiceId, requestParameters.clientInvoiceUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
     * @summary Export client invoice CMR data.
     * @param {InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet(requestParameters: InvoicesClientApiCrmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).crmClientInvoiceExportCmrInvoicesClientsInvoiceIdInvoiceCmrExportTypeGet(requestParameters.invoiceId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export delivery note data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
     * @summary Export client invoice delivery note data.
     * @param {InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet(requestParameters: InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceDeliveryNoteExportTypeGet(requestParameters.invoiceId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export invoice data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
     * @summary Export client proforma data.
     * @param {InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet(requestParameters: InvoicesClientApiCrmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).crmClientInvoiceExportInvoicesClientsInvoiceIdInvoiceExportTypeGet(requestParameters.invoiceId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export packaging list data.  Role check: is_staff  Permission: crm_view_client_invoice  accept-language header does not affect the document language. invoice.order.user.document_language is used for the export instead.
     * @summary Export client invoice packaging list data.
     * @param {InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesClientApi
     */
    public crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet(requestParameters: InvoicesClientApiCrmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGetRequest, options?: AxiosRequestConfig) {
        return InvoicesClientApiFp(this.configuration).crmClientInvoiceExportPackagingListInvoicesClientsInvoiceIdInvoicePackagingListExportTypeGet(requestParameters.invoiceId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesSupplierApi - axios parameter creator
 * @export
 */
export const InvoicesSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new supplier invoice(Additional expense).  If there are errors in the invoiceNomenclature formset, the object indexes will be returned.  (Endpoint) get available nomenclatures - /nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier invoice(Additional expense)
         * @param {SupplierAdditionalInvoiceCreateSchema} supplierAdditionalInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost: async (supplierAdditionalInvoiceCreateSchema: SupplierAdditionalInvoiceCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierAdditionalInvoiceCreateSchema' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost', 'supplierAdditionalInvoiceCreateSchema', supplierAdditionalInvoiceCreateSchema)
            const localVarPath = `/invoices/suppliers/additional-expense/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierAdditionalInvoiceCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get additional expense list for standard supplier invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get additional expenses for standard supplier invoice.
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/suppliers/{invoice_id}/additional-expenses/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update comments for supplier additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Only standard supplier invoices.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update comments for supplier additional expenses
         * @param {number} invoiceId 
         * @param {AdditionalExpenseUpdateCommentsSchema} additionalExpenseUpdateCommentsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut: async (invoiceId: number, additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut', 'invoiceId', invoiceId)
            // verify required parameter 'additionalExpenseUpdateCommentsSchema' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut', 'additionalExpenseUpdateCommentsSchema', additionalExpenseUpdateCommentsSchema)
            const localVarPath = `/invoices/suppliers/{invoice_id}/additional-expenses/comments/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(additionalExpenseUpdateCommentsSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier invoice detail(Additional expense).  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
         * @summary Get supplier invoice detail(Additional expense)
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/suppliers/additional-expense/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier invoice(Additional expense) status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to created(Additional expense)
         * @param {number} invoiceId 
         * @param {SupplierInvoiceCancellationSchema} supplierInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut: async (invoiceId: number, supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut', 'invoiceId', invoiceId)
            // verify required parameter 'supplierInvoiceCancellationSchema' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut', 'supplierInvoiceCancellationSchema', supplierInvoiceCancellationSchema)
            const localVarPath = `/invoices/suppliers/additional-expense/{invoice_id}/cancel/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierInvoiceCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier invoice(Additional expense) status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to deleted(Additional expense)
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/suppliers/additional-expense/{invoice_id}/delete/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update supplier invoice(Additional expense).  Only for status \"created\".  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update supplier invoice(Additional expense)
         * @param {number} invoiceId 
         * @param {SupplierAdditionalInvoiceUpdateSchema} supplierAdditionalInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut: async (invoiceId: number, supplierAdditionalInvoiceUpdateSchema: SupplierAdditionalInvoiceUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut', 'invoiceId', invoiceId)
            // verify required parameter 'supplierAdditionalInvoiceUpdateSchema' is not null or undefined
            assertParamExists('supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut', 'supplierAdditionalInvoiceUpdateSchema', supplierAdditionalInvoiceUpdateSchema)
            const localVarPath = `/invoices/suppliers/additional-expense/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierAdditionalInvoiceUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new supplier invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier invoice
         * @param {SupplierInvoiceCreateSchema} supplierInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesCreateOneInvoicesSuppliersPost: async (supplierInvoiceCreateSchema: SupplierInvoiceCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierInvoiceCreateSchema' is not null or undefined
            assertParamExists('supplierInvoicesCreateOneInvoicesSuppliersPost', 'supplierInvoiceCreateSchema', supplierInvoiceCreateSchema)
            const localVarPath = `/invoices/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierInvoiceCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
         * @summary Get supplier invoice detail
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/suppliers/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all nomenclature incomes from conducted supplier invoices.  Role check: is_staff.
         * @summary Get all nomenclature incomes from conducted supplier invoices.
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductionFrom] Date range. Filtering by supplier invoice date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by supplier invoice date conduction. Date conduction to.
         * @param {string} [searchFilter] Search by supplier invoice documentNumber(year, number, suffix), supplier(email, name, phone, vatNumber, registrationNumber)
         * @param {number} [currencyId] Filtering by currency.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet: async (nomenclatureId: number, page?: number, pageSize?: number, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, currencyId?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/invoices/suppliers/incomes/{nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_invoice.
         * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
         * @param {number} invoiceId 
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet: async (invoiceId: number, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/suppliers/{invoice_id}/invoice-nomenclatures/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesListInvoicesSuppliersGet: async (page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (excludeInactiveForAdditionalExpense !== undefined) {
                localVarQueryParameter['excludeInactiveForAdditionalExpense'] = excludeInactiveForAdditionalExpense;
            }

            if (hasDebt !== undefined) {
                localVarQueryParameter['hasDebt'] = hasDebt;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier invoice list without pagination.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list without pagination.
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet: async (order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/suppliers/no-pagination/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (excludeInactiveForAdditionalExpense !== undefined) {
                localVarQueryParameter['excludeInactiveForAdditionalExpense'] = excludeInactiveForAdditionalExpense;
            }

            if (hasDebt !== undefined) {
                localVarQueryParameter['hasDebt'] = hasDebt;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesListSelectInvoicesSuppliersSelectGet: async (page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/suppliers/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (excludeInactiveForAdditionalExpense !== undefined) {
                localVarQueryParameter['excludeInactiveForAdditionalExpense'] = excludeInactiveForAdditionalExpense;
            }

            if (hasDebt !== undefined) {
                localVarQueryParameter['hasDebt'] = hasDebt;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to created
         * @param {number} invoiceId 
         * @param {SupplierInvoiceCancellationSchema} supplierInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut: async (invoiceId: number, supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut', 'invoiceId', invoiceId)
            // verify required parameter 'supplierInvoiceCancellationSchema' is not null or undefined
            assertParamExists('supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut', 'supplierInvoiceCancellationSchema', supplierInvoiceCancellationSchema)
            const localVarPath = `/invoices/suppliers/{invoice_id}/cancel/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierInvoiceCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to deleted
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut: async (invoiceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/suppliers/{invoice_id}/delete/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update supplier invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update supplier invoice
         * @param {number} invoiceId 
         * @param {SupplierInvoiceUpdateSchema} supplierInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut: async (invoiceId: number, supplierInvoiceUpdateSchema: SupplierInvoiceUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut', 'invoiceId', invoiceId)
            // verify required parameter 'supplierInvoiceUpdateSchema' is not null or undefined
            assertParamExists('supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut', 'supplierInvoiceUpdateSchema', supplierInvoiceUpdateSchema)
            const localVarPath = `/invoices/suppliers/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierInvoiceUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesSupplierApi - functional programming interface
 * @export
 */
export const InvoicesSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new supplier invoice(Additional expense).  If there are errors in the invoiceNomenclature formset, the object indexes will be returned.  (Endpoint) get available nomenclatures - /nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier invoice(Additional expense)
         * @param {SupplierAdditionalInvoiceCreateSchema} supplierAdditionalInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost(supplierAdditionalInvoiceCreateSchema: SupplierAdditionalInvoiceCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierAdditionalInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost(supplierAdditionalInvoiceCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get additional expense list for standard supplier invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get additional expenses for standard supplier invoice.
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupplierNomenclatureAdditionalExpenseListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update comments for supplier additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Only standard supplier invoices.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update comments for supplier additional expenses
         * @param {number} invoiceId 
         * @param {AdditionalExpenseUpdateCommentsSchema} additionalExpenseUpdateCommentsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut(invoiceId: number, additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupplierNomenclatureAdditionalExpenseListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut(invoiceId, additionalExpenseUpdateCommentsSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier invoice detail(Additional expense).  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
         * @summary Get supplier invoice detail(Additional expense)
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierAdditionalInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier invoice(Additional expense) status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to created(Additional expense)
         * @param {number} invoiceId 
         * @param {SupplierInvoiceCancellationSchema} supplierInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut(invoiceId: number, supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierAdditionalInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut(invoiceId, supplierInvoiceCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier invoice(Additional expense) status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to deleted(Additional expense)
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierAdditionalInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update supplier invoice(Additional expense).  Only for status \"created\".  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update supplier invoice(Additional expense)
         * @param {number} invoiceId 
         * @param {SupplierAdditionalInvoiceUpdateSchema} supplierAdditionalInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut(invoiceId: number, supplierAdditionalInvoiceUpdateSchema: SupplierAdditionalInvoiceUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierAdditionalInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut(invoiceId, supplierAdditionalInvoiceUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new supplier invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier invoice
         * @param {SupplierInvoiceCreateSchema} supplierInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesCreateOneInvoicesSuppliersPost(supplierInvoiceCreateSchema: SupplierInvoiceCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesCreateOneInvoicesSuppliersPost(supplierInvoiceCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
         * @summary Get supplier invoice detail
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all nomenclature incomes from conducted supplier invoices.  Role check: is_staff.
         * @summary Get all nomenclature incomes from conducted supplier invoices.
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductionFrom] Date range. Filtering by supplier invoice date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by supplier invoice date conduction. Date conduction to.
         * @param {string} [searchFilter] Search by supplier invoice documentNumber(year, number, suffix), supplier(email, name, phone, vatNumber, registrationNumber)
         * @param {number} [currencyId] Filtering by currency.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet(nomenclatureId: number, page?: number, pageSize?: number, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, currencyId?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceNomenclatureIncomePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet(nomenclatureId, page, pageSize, dateConductionFrom, dateConductionTo, searchFilter, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_invoice.
         * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
         * @param {number} invoiceId 
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet(invoiceId: number, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceNomenclaturePageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet(invoiceId, unit, searchFilter, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesListInvoicesSuppliersGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoicePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesListInvoicesSuppliersGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, supplierCategoryId, type, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier invoice list without pagination.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list without pagination.
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet(order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupplierInvoiceListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet(order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, supplierCategoryId, type, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesListSelectInvoicesSuppliersSelectGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectInvoicePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesListSelectInvoicesSuppliersSelectGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, supplierCategoryId, type, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to created
         * @param {number} invoiceId 
         * @param {SupplierInvoiceCancellationSchema} supplierInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut(invoiceId: number, supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut(invoiceId, supplierInvoiceCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to deleted
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut(invoiceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut(invoiceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update supplier invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update supplier invoice
         * @param {number} invoiceId 
         * @param {SupplierInvoiceUpdateSchema} supplierInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut(invoiceId: number, supplierInvoiceUpdateSchema: SupplierInvoiceUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierInvoiceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut(invoiceId, supplierInvoiceUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesSupplierApi - factory interface
 * @export
 */
export const InvoicesSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesSupplierApiFp(configuration)
    return {
        /**
         * Create new supplier invoice(Additional expense).  If there are errors in the invoiceNomenclature formset, the object indexes will be returned.  (Endpoint) get available nomenclatures - /nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier invoice(Additional expense)
         * @param {SupplierAdditionalInvoiceCreateSchema} supplierAdditionalInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost(supplierAdditionalInvoiceCreateSchema: SupplierAdditionalInvoiceCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierAdditionalInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost(supplierAdditionalInvoiceCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get additional expense list for standard supplier invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get additional expenses for standard supplier invoice.
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<Array<SupplierNomenclatureAdditionalExpenseListSchema>> {
            return localVarFp.supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update comments for supplier additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Only standard supplier invoices.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update comments for supplier additional expenses
         * @param {number} invoiceId 
         * @param {AdditionalExpenseUpdateCommentsSchema} additionalExpenseUpdateCommentsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut(invoiceId: number, additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema, acceptLanguage?: string, options?: any): AxiosPromise<Array<SupplierNomenclatureAdditionalExpenseListSchema>> {
            return localVarFp.supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut(invoiceId, additionalExpenseUpdateCommentsSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier invoice detail(Additional expense).  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
         * @summary Get supplier invoice detail(Additional expense)
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierAdditionalInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier invoice(Additional expense) status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to created(Additional expense)
         * @param {number} invoiceId 
         * @param {SupplierInvoiceCancellationSchema} supplierInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut(invoiceId: number, supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierAdditionalInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut(invoiceId, supplierInvoiceCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier invoice(Additional expense) status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to deleted(Additional expense)
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierAdditionalInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update supplier invoice(Additional expense).  Only for status \"created\".  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update supplier invoice(Additional expense)
         * @param {number} invoiceId 
         * @param {SupplierAdditionalInvoiceUpdateSchema} supplierAdditionalInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut(invoiceId: number, supplierAdditionalInvoiceUpdateSchema: SupplierAdditionalInvoiceUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierAdditionalInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut(invoiceId, supplierAdditionalInvoiceUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new supplier invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier invoice
         * @param {SupplierInvoiceCreateSchema} supplierInvoiceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesCreateOneInvoicesSuppliersPost(supplierInvoiceCreateSchema: SupplierInvoiceCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesCreateOneInvoicesSuppliersPost(supplierInvoiceCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
         * @summary Get supplier invoice detail
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all nomenclature incomes from conducted supplier invoices.  Role check: is_staff.
         * @summary Get all nomenclature incomes from conducted supplier invoices.
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductionFrom] Date range. Filtering by supplier invoice date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by supplier invoice date conduction. Date conduction to.
         * @param {string} [searchFilter] Search by supplier invoice documentNumber(year, number, suffix), supplier(email, name, phone, vatNumber, registrationNumber)
         * @param {number} [currencyId] Filtering by currency.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet(nomenclatureId: number, page?: number, pageSize?: number, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, currencyId?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceNomenclatureIncomePage> {
            return localVarFp.supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet(nomenclatureId, page, pageSize, dateConductionFrom, dateConductionTo, searchFilter, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_invoice.
         * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
         * @param {number} invoiceId 
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet(invoiceId: number, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceNomenclaturePageSchema> {
            return localVarFp.supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet(invoiceId, unit, searchFilter, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesListInvoicesSuppliersGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoicePage> {
            return localVarFp.supplierInvoicesListInvoicesSuppliersGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, supplierCategoryId, type, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier invoice list without pagination.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list without pagination.
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet(order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options?: any): AxiosPromise<Array<SupplierInvoiceListSchema>> {
            return localVarFp.supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet(order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, supplierCategoryId, type, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
         * @summary Get supplier invoice list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseInvoiceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {InvoiceStatuses} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {boolean} [excludeInactiveForAdditionalExpense] Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
         * @param {boolean} [hasDebt] Filter by invoices with sum to pay &gt; 0.
         * @param {string} [searchFilterSelect] Search by documentNumber(year, number, suffix)
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
         * @param {number} [supplierCategoryId] 
         * @param {SupplierInvoiceTypes} [type] Filter by invoice type
         * @param {SupplierInvoiceLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesListSelectInvoicesSuppliersSelectGet(page?: number, pageSize?: number, order?: BaseInvoiceQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: InvoiceStatuses, userId?: string, staffId?: string, excludeInactiveForAdditionalExpense?: boolean, hasDebt?: boolean, searchFilterSelect?: string, searchFilter?: string, supplierCategoryId?: number, type?: SupplierInvoiceTypes, labels?: SupplierInvoiceLabels, acceptLanguage?: string, options?: any): AxiosPromise<SelectInvoicePage> {
            return localVarFp.supplierInvoicesListSelectInvoicesSuppliersSelectGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, excludeInactiveForAdditionalExpense, hasDebt, searchFilterSelect, searchFilter, supplierCategoryId, type, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to created
         * @param {number} invoiceId 
         * @param {SupplierInvoiceCancellationSchema} supplierInvoiceCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut(invoiceId: number, supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut(invoiceId, supplierInvoiceCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Change supplier invoice status to deleted
         * @param {number} invoiceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut(invoiceId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut(invoiceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update supplier invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
         * @summary Update supplier invoice
         * @param {number} invoiceId 
         * @param {SupplierInvoiceUpdateSchema} supplierInvoiceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut(invoiceId: number, supplierInvoiceUpdateSchema: SupplierInvoiceUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierInvoiceDetailSchema> {
            return localVarFp.supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut(invoiceId, supplierInvoiceUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePostRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePostRequest {
    /**
     * 
     * @type {SupplierAdditionalInvoiceCreateSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost
     */
    readonly supplierAdditionalInvoiceCreateSchema: SupplierAdditionalInvoiceCreateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {AdditionalExpenseUpdateCommentsSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut
     */
    readonly additionalExpenseUpdateCommentsSchema: AdditionalExpenseUpdateCommentsSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {SupplierInvoiceCancellationSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut
     */
    readonly supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {SupplierAdditionalInvoiceUpdateSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut
     */
    readonly supplierAdditionalInvoiceUpdateSchema: SupplierAdditionalInvoiceUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesCreateOneInvoicesSuppliersPost operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesCreateOneInvoicesSuppliersPostRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesCreateOneInvoicesSuppliersPostRequest {
    /**
     * 
     * @type {SupplierInvoiceCreateSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesCreateOneInvoicesSuppliersPost
     */
    readonly supplierInvoiceCreateSchema: SupplierInvoiceCreateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesCreateOneInvoicesSuppliersPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesGetOneInvoicesSuppliersInvoiceIdGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesGetOneInvoicesSuppliersInvoiceIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly pageSize?: number

    /**
     * Date range. Filtering by supplier invoice date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by supplier invoice date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly dateConductionTo?: string

    /**
     * Search by supplier invoice documentNumber(year, number, suffix), supplier(email, name, phone, vatNumber, registrationNumber)
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by currency.
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet
     */
    readonly invoiceId: number

    /**
     * Filtering by unit. All units is default.
     * @type {UnitFilter}
     * @memberof InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet
     */
    readonly unit?: UnitFilter

    /**
     * Search by name or vendor code.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesListInvoicesSuppliersGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseInvoiceQueryOrder}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly order?: BaseInvoiceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly dateConductionTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly status?: InvoiceStatuses

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly staffId?: string

    /**
     * Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
     * @type {boolean}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly excludeInactiveForAdditionalExpense?: boolean

    /**
     * Filter by invoices with sum to pay &gt; 0.
     * @type {boolean}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly hasDebt?: boolean

    /**
     * Search by documentNumber(year, number, suffix)
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly searchFilterSelect?: string

    /**
     * Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly supplierCategoryId?: number

    /**
     * Filter by invoice type
     * @type {SupplierInvoiceTypes}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly type?: SupplierInvoiceTypes

    /**
     * 
     * @type {SupplierInvoiceLabels}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly labels?: SupplierInvoiceLabels

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGetRequest {
    /**
     * 
     * @type {BaseInvoiceQueryOrder}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly order?: BaseInvoiceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly dateConductionTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly status?: InvoiceStatuses

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly staffId?: string

    /**
     * Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
     * @type {boolean}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly excludeInactiveForAdditionalExpense?: boolean

    /**
     * Filter by invoices with sum to pay &gt; 0.
     * @type {boolean}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly hasDebt?: boolean

    /**
     * Search by documentNumber(year, number, suffix)
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly searchFilterSelect?: string

    /**
     * Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly supplierCategoryId?: number

    /**
     * Filter by invoice type
     * @type {SupplierInvoiceTypes}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly type?: SupplierInvoiceTypes

    /**
     * 
     * @type {SupplierInvoiceLabels}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly labels?: SupplierInvoiceLabels

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesListSelectInvoicesSuppliersSelectGet operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGetRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseInvoiceQueryOrder}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly order?: BaseInvoiceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly dateConductionTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {InvoiceStatuses}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly status?: InvoiceStatuses

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly staffId?: string

    /**
     * Exclude inactive invoices for additional expense. If True, will be returned only invoices with: type \&#39;standard\&#39;, status \&#39;conducted\&#39;, products, valid edit date.
     * @type {boolean}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly excludeInactiveForAdditionalExpense?: boolean

    /**
     * Filter by invoices with sum to pay &gt; 0.
     * @type {boolean}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly hasDebt?: boolean

    /**
     * Search by documentNumber(year, number, suffix)
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Search by id, documentNumber(year, number, suffix), supplier(name, phone, vatNumber, registrationNumber, region, city) and by order(documentNumber(year, number, suffix))
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly supplierCategoryId?: number

    /**
     * Filter by invoice type
     * @type {SupplierInvoiceTypes}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly type?: SupplierInvoiceTypes

    /**
     * 
     * @type {SupplierInvoiceLabels}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly labels?: SupplierInvoiceLabels

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {SupplierInvoiceCancellationSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut
     */
    readonly supplierInvoiceCancellationSchema: SupplierInvoiceCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut operation in InvoicesSupplierApi.
 * @export
 * @interface InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPutRequest
 */
export interface InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut
     */
    readonly invoiceId: number

    /**
     * 
     * @type {SupplierInvoiceUpdateSchema}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut
     */
    readonly supplierInvoiceUpdateSchema: SupplierInvoiceUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * InvoicesSupplierApi - object-oriented interface
 * @export
 * @class InvoicesSupplierApi
 * @extends {BaseAPI}
 */
export class InvoicesSupplierApi extends BaseAPI {
    /**
     * Create new supplier invoice(Additional expense).  If there are errors in the invoiceNomenclature formset, the object indexes will be returned.  (Endpoint) get available nomenclatures - /nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Create new supplier invoice(Additional expense)
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePostRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalCreateOneInvoicesSuppliersAdditionalExpensePost(requestParameters.supplierAdditionalInvoiceCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get additional expense list for standard supplier invoice.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
     * @summary Get additional expenses for standard supplier invoice.
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGetRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalExpensesListInvoicesSuppliersInvoiceIdAdditionalExpensesGet(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update comments for supplier additional expenses. Only for invoices with \"conducted\" status.  If response has status 200 and empty array([]), then there are no additional expenses for this invoice.  Only standard supplier invoices.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Update comments for supplier additional expenses
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalExpensesUpdateOneCommentsInvoicesSuppliersInvoiceIdAdditionalExpensesCommentsPut(requestParameters.invoiceId, requestParameters.additionalExpenseUpdateCommentsSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier invoice detail(Additional expense).  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
     * @summary Get supplier invoice detail(Additional expense)
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGetRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalGetOneInvoicesSuppliersAdditionalExpenseInvoiceIdGet(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier invoice(Additional expense) status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Change supplier invoice status to created(Additional expense)
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalUpdateOneCancelInvoicesSuppliersAdditionalExpenseInvoiceIdCancelPut(requestParameters.invoiceId, requestParameters.supplierInvoiceCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier invoice(Additional expense) status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Change supplier invoice status to deleted(Additional expense)
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalUpdateOneDeleteInvoicesSuppliersAdditionalExpenseInvoiceIdDeletePut(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update supplier invoice(Additional expense).  Only for status \"created\".  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Update supplier invoice(Additional expense)
     * @param {InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut(requestParameters: InvoicesSupplierApiSupplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesAdditionalUpdateOneInvoicesSuppliersAdditionalExpenseInvoiceIdPut(requestParameters.invoiceId, requestParameters.supplierAdditionalInvoiceUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new supplier invoice.  If there are errors in the invoiceNomenclature formset, the related orderNomenclature IDs will be returned.  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Create new supplier invoice
     * @param {InvoicesSupplierApiSupplierInvoicesCreateOneInvoicesSuppliersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesCreateOneInvoicesSuppliersPost(requestParameters: InvoicesSupplierApiSupplierInvoicesCreateOneInvoicesSuppliersPostRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesCreateOneInvoicesSuppliersPost(requestParameters.supplierInvoiceCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier invoice detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_invoice\'.
     * @summary Get supplier invoice detail
     * @param {InvoicesSupplierApiSupplierInvoicesGetOneInvoicesSuppliersInvoiceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet(requestParameters: InvoicesSupplierApiSupplierInvoicesGetOneInvoicesSuppliersInvoiceIdGetRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesGetOneInvoicesSuppliersInvoiceIdGet(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all nomenclature incomes from conducted supplier invoices.  Role check: is_staff.
     * @summary Get all nomenclature incomes from conducted supplier invoices.
     * @param {InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet(requestParameters: InvoicesSupplierApiSupplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGetRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesIncomesListInvoicesSuppliersIncomesNomenclatureIdGet(requestParameters.nomenclatureId, requestParameters.page, requestParameters.pageSize, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.searchFilter, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all invoice nomenclatures with an unused nomenclature quantity for product returns.  Only unused products are returned.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_invoice.
     * @summary Get all invoice nomenclatures with an unused nomenclature quantity for returns
     * @param {InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet(requestParameters: InvoicesSupplierApiSupplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGetRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesInvoiceNomenclaturesGetAllInvoicesSuppliersInvoiceIdInvoiceNomenclaturesGet(requestParameters.invoiceId, requestParameters.unit, requestParameters.searchFilter, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
     * @summary Get supplier invoice list.
     * @param {InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesListInvoicesSuppliersGet(requestParameters: InvoicesSupplierApiSupplierInvoicesListInvoicesSuppliersGetRequest = {}, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesListInvoicesSuppliersGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.excludeInactiveForAdditionalExpense, requestParameters.hasDebt, requestParameters.searchFilterSelect, requestParameters.searchFilter, requestParameters.supplierCategoryId, requestParameters.type, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier invoice list without pagination.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
     * @summary Get supplier invoice list without pagination.
     * @param {InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet(requestParameters: InvoicesSupplierApiSupplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGetRequest = {}, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesListNoPaginationInvoicesSuppliersNoPaginationGet(requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.excludeInactiveForAdditionalExpense, requestParameters.hasDebt, requestParameters.searchFilterSelect, requestParameters.searchFilter, requestParameters.supplierCategoryId, requestParameters.type, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier invoice list.  Role check: is_staff.  Permission: warehouse_view_supplier_invoice.
     * @summary Get supplier invoice list.
     * @param {InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesListSelectInvoicesSuppliersSelectGet(requestParameters: InvoicesSupplierApiSupplierInvoicesListSelectInvoicesSuppliersSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesListSelectInvoicesSuppliersSelectGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.excludeInactiveForAdditionalExpense, requestParameters.hasDebt, requestParameters.searchFilterSelect, requestParameters.searchFilter, requestParameters.supplierCategoryId, requestParameters.type, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier invoice status to \"created\". Only for invoices with \"conducted\" status.  Perms needed: \'warehouse_cancel_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Change supplier invoice status to created
     * @param {InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut(requestParameters: InvoicesSupplierApiSupplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesUpdateOneCancelInvoicesSuppliersInvoiceIdCancelPut(requestParameters.invoiceId, requestParameters.supplierInvoiceCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier invoice status to \"deleted\". Only for invoices with \"created\" status.  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Change supplier invoice status to deleted
     * @param {InvoicesSupplierApiSupplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut(requestParameters: InvoicesSupplierApiSupplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesUpdateOneDeleteInvoicesSuppliersInvoiceIdDeletePut(requestParameters.invoiceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update supplier invoice.  Only for status \"created\".  (Endpoint) get available order nomenclature - /orders/suppliers/{order_id}/order-nomenclatures/  Perms needed: \'warehouse_change_supplier_invoice\'.  Role needed: \'is_staff\'.
     * @summary Update supplier invoice
     * @param {InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesSupplierApi
     */
    public supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut(requestParameters: InvoicesSupplierApiSupplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPutRequest, options?: AxiosRequestConfig) {
        return InvoicesSupplierApiFp(this.configuration).supplierInvoicesUpdateOneInvoicesSuppliersInvoiceIdPut(requestParameters.invoiceId, requestParameters.supplierInvoiceUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuStickersApi - axios parameter creator
 * @export
 */
export const MenuStickersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get \'CRM\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'CRM\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuStickersCrmListMenuStickersCrmGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menu-stickers/crm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get \'Finances\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'Finances\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuStickersFinancesListMenuStickersFinancesGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menu-stickers/finances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get \'Warehouse\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'Warehouse\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuStickersWarehouseListMenuStickersWarehouseGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menu-stickers/warehouse/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuStickersApi - functional programming interface
 * @export
 */
export const MenuStickersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuStickersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get \'CRM\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'CRM\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async menuStickersCrmListMenuStickersCrmGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffCrmMenuStickerSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.menuStickersCrmListMenuStickersCrmGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get \'Finances\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'Finances\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async menuStickersFinancesListMenuStickersFinancesGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffFinancesMenuStickerSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.menuStickersFinancesListMenuStickersFinancesGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get \'Warehouse\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'Warehouse\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async menuStickersWarehouseListMenuStickersWarehouseGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffWarehouseMenuStickerSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.menuStickersWarehouseListMenuStickersWarehouseGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuStickersApi - factory interface
 * @export
 */
export const MenuStickersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuStickersApiFp(configuration)
    return {
        /**
         * Get \'CRM\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'CRM\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuStickersCrmListMenuStickersCrmGet(acceptLanguage?: string, options?: any): AxiosPromise<StaffCrmMenuStickerSchema> {
            return localVarFp.menuStickersCrmListMenuStickersCrmGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get \'Finances\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'Finances\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuStickersFinancesListMenuStickersFinancesGet(acceptLanguage?: string, options?: any): AxiosPromise<StaffFinancesMenuStickerSchema> {
            return localVarFp.menuStickersFinancesListMenuStickersFinancesGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get \'Warehouse\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
         * @summary Get \'Warehouse\' menu stickers for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuStickersWarehouseListMenuStickersWarehouseGet(acceptLanguage?: string, options?: any): AxiosPromise<StaffWarehouseMenuStickerSchema> {
            return localVarFp.menuStickersWarehouseListMenuStickersWarehouseGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for menuStickersCrmListMenuStickersCrmGet operation in MenuStickersApi.
 * @export
 * @interface MenuStickersApiMenuStickersCrmListMenuStickersCrmGetRequest
 */
export interface MenuStickersApiMenuStickersCrmListMenuStickersCrmGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MenuStickersApiMenuStickersCrmListMenuStickersCrmGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for menuStickersFinancesListMenuStickersFinancesGet operation in MenuStickersApi.
 * @export
 * @interface MenuStickersApiMenuStickersFinancesListMenuStickersFinancesGetRequest
 */
export interface MenuStickersApiMenuStickersFinancesListMenuStickersFinancesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MenuStickersApiMenuStickersFinancesListMenuStickersFinancesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for menuStickersWarehouseListMenuStickersWarehouseGet operation in MenuStickersApi.
 * @export
 * @interface MenuStickersApiMenuStickersWarehouseListMenuStickersWarehouseGetRequest
 */
export interface MenuStickersApiMenuStickersWarehouseListMenuStickersWarehouseGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MenuStickersApiMenuStickersWarehouseListMenuStickersWarehouseGet
     */
    readonly acceptLanguage?: string
}

/**
 * MenuStickersApi - object-oriented interface
 * @export
 * @class MenuStickersApi
 * @extends {BaseAPI}
 */
export class MenuStickersApi extends BaseAPI {
    /**
     * Get \'CRM\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
     * @summary Get \'CRM\' menu stickers for staff
     * @param {MenuStickersApiMenuStickersCrmListMenuStickersCrmGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuStickersApi
     */
    public menuStickersCrmListMenuStickersCrmGet(requestParameters: MenuStickersApiMenuStickersCrmListMenuStickersCrmGetRequest = {}, options?: AxiosRequestConfig) {
        return MenuStickersApiFp(this.configuration).menuStickersCrmListMenuStickersCrmGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get \'Finances\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
     * @summary Get \'Finances\' menu stickers for staff
     * @param {MenuStickersApiMenuStickersFinancesListMenuStickersFinancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuStickersApi
     */
    public menuStickersFinancesListMenuStickersFinancesGet(requestParameters: MenuStickersApiMenuStickersFinancesListMenuStickersFinancesGetRequest = {}, options?: AxiosRequestConfig) {
        return MenuStickersApiFp(this.configuration).menuStickersFinancesListMenuStickersFinancesGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get \'Warehouse\' menu stickers for staff.  Cashing is used for this endpoint. Cash is updated every minute.  Roles: is_staff.
     * @summary Get \'Warehouse\' menu stickers for staff
     * @param {MenuStickersApiMenuStickersWarehouseListMenuStickersWarehouseGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuStickersApi
     */
    public menuStickersWarehouseListMenuStickersWarehouseGet(requestParameters: MenuStickersApiMenuStickersWarehouseListMenuStickersWarehouseGetRequest = {}, options?: AxiosRequestConfig) {
        return MenuStickersApiFp(this.configuration).menuStickersWarehouseListMenuStickersWarehouseGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MutualSettlementsApi - axios parameter creator
 * @export
 */
export const MutualSettlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export packaging list data.  Role check: is_staff  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)
         * @summary Export mutual settlements packaging list data.
         * @param {string} userId 
         * @param {DataExportType} exportType 
         * @param {string} dateCreatedFrom Date range. Filtering by date created. Date created from.
         * @param {string} dateCreatedTo Date range. Filtering by date created. Date created to.
         * @param {number} currencyId Filtering by currency id.
         * @param {MutualSettlementUserKinds} userKind Filtering by user kind.
         * @param {AcceptLanguage} [exportLanguage] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet: async (userId: string, exportType: DataExportType, dateCreatedFrom: string, dateCreatedTo: string, currencyId: number, userKind: MutualSettlementUserKinds, exportLanguage?: AcceptLanguage, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet', 'userId', userId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet', 'exportType', exportType)
            // verify required parameter 'dateCreatedFrom' is not null or undefined
            assertParamExists('mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet', 'dateCreatedFrom', dateCreatedFrom)
            // verify required parameter 'dateCreatedTo' is not null or undefined
            assertParamExists('mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet', 'dateCreatedTo', dateCreatedTo)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet', 'currencyId', currencyId)
            // verify required parameter 'userKind' is not null or undefined
            assertParamExists('mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet', 'userKind', userKind)
            const localVarPath = `/mutual-settlements/{user_id}/{export_type}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (exportLanguage !== undefined) {
                localVarQueryParameter['export_language'] = exportLanguage;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (userKind !== undefined) {
                localVarQueryParameter['userKind'] = userKind;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get mutual settlements list.  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)  Role check: is_staff.
         * @summary Get mutual settlements list.
         * @param {string} userId 
         * @param {string} dateCreatedFrom Date range. Filtering by date created. Date created from.
         * @param {string} dateCreatedTo Date range. Filtering by date created. Date created to.
         * @param {number} currencyId Filtering by currency id.
         * @param {MutualSettlementUserKinds} userKind Filtering by user kind.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mutualSettlementsListMutualSettlementsUserIdGet: async (userId: string, dateCreatedFrom: string, dateCreatedTo: string, currencyId: number, userKind: MutualSettlementUserKinds, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mutualSettlementsListMutualSettlementsUserIdGet', 'userId', userId)
            // verify required parameter 'dateCreatedFrom' is not null or undefined
            assertParamExists('mutualSettlementsListMutualSettlementsUserIdGet', 'dateCreatedFrom', dateCreatedFrom)
            // verify required parameter 'dateCreatedTo' is not null or undefined
            assertParamExists('mutualSettlementsListMutualSettlementsUserIdGet', 'dateCreatedTo', dateCreatedTo)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('mutualSettlementsListMutualSettlementsUserIdGet', 'currencyId', currencyId)
            // verify required parameter 'userKind' is not null or undefined
            assertParamExists('mutualSettlementsListMutualSettlementsUserIdGet', 'userKind', userKind)
            const localVarPath = `/mutual-settlements/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (userKind !== undefined) {
                localVarQueryParameter['userKind'] = userKind;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MutualSettlementsApi - functional programming interface
 * @export
 */
export const MutualSettlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MutualSettlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export packaging list data.  Role check: is_staff  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)
         * @summary Export mutual settlements packaging list data.
         * @param {string} userId 
         * @param {DataExportType} exportType 
         * @param {string} dateCreatedFrom Date range. Filtering by date created. Date created from.
         * @param {string} dateCreatedTo Date range. Filtering by date created. Date created to.
         * @param {number} currencyId Filtering by currency id.
         * @param {MutualSettlementUserKinds} userKind Filtering by user kind.
         * @param {AcceptLanguage} [exportLanguage] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet(userId: string, exportType: DataExportType, dateCreatedFrom: string, dateCreatedTo: string, currencyId: number, userKind: MutualSettlementUserKinds, exportLanguage?: AcceptLanguage, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet(userId, exportType, dateCreatedFrom, dateCreatedTo, currencyId, userKind, exportLanguage, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get mutual settlements list.  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)  Role check: is_staff.
         * @summary Get mutual settlements list.
         * @param {string} userId 
         * @param {string} dateCreatedFrom Date range. Filtering by date created. Date created from.
         * @param {string} dateCreatedTo Date range. Filtering by date created. Date created to.
         * @param {number} currencyId Filtering by currency id.
         * @param {MutualSettlementUserKinds} userKind Filtering by user kind.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mutualSettlementsListMutualSettlementsUserIdGet(userId: string, dateCreatedFrom: string, dateCreatedTo: string, currencyId: number, userKind: MutualSettlementUserKinds, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MutualSettlementPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mutualSettlementsListMutualSettlementsUserIdGet(userId, dateCreatedFrom, dateCreatedTo, currencyId, userKind, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MutualSettlementsApi - factory interface
 * @export
 */
export const MutualSettlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MutualSettlementsApiFp(configuration)
    return {
        /**
         * Export packaging list data.  Role check: is_staff  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)
         * @summary Export mutual settlements packaging list data.
         * @param {string} userId 
         * @param {DataExportType} exportType 
         * @param {string} dateCreatedFrom Date range. Filtering by date created. Date created from.
         * @param {string} dateCreatedTo Date range. Filtering by date created. Date created to.
         * @param {number} currencyId Filtering by currency id.
         * @param {MutualSettlementUserKinds} userKind Filtering by user kind.
         * @param {AcceptLanguage} [exportLanguage] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet(userId: string, exportType: DataExportType, dateCreatedFrom: string, dateCreatedTo: string, currencyId: number, userKind: MutualSettlementUserKinds, exportLanguage?: AcceptLanguage, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet(userId, exportType, dateCreatedFrom, dateCreatedTo, currencyId, userKind, exportLanguage, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get mutual settlements list.  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)  Role check: is_staff.
         * @summary Get mutual settlements list.
         * @param {string} userId 
         * @param {string} dateCreatedFrom Date range. Filtering by date created. Date created from.
         * @param {string} dateCreatedTo Date range. Filtering by date created. Date created to.
         * @param {number} currencyId Filtering by currency id.
         * @param {MutualSettlementUserKinds} userKind Filtering by user kind.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mutualSettlementsListMutualSettlementsUserIdGet(userId: string, dateCreatedFrom: string, dateCreatedTo: string, currencyId: number, userKind: MutualSettlementUserKinds, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<MutualSettlementPage> {
            return localVarFp.mutualSettlementsListMutualSettlementsUserIdGet(userId, dateCreatedFrom, dateCreatedTo, currencyId, userKind, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet operation in MutualSettlementsApi.
 * @export
 * @interface MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGetRequest
 */
export interface MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly userId: string

    /**
     * 
     * @type {DataExportType}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly dateCreatedFrom: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly dateCreatedTo: string

    /**
     * Filtering by currency id.
     * @type {number}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly currencyId: number

    /**
     * Filtering by user kind.
     * @type {MutualSettlementUserKinds}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly userKind: MutualSettlementUserKinds

    /**
     * 
     * @type {AcceptLanguage}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly exportLanguage?: AcceptLanguage

    /**
     * 
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for mutualSettlementsListMutualSettlementsUserIdGet operation in MutualSettlementsApi.
 * @export
 * @interface MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGetRequest
 */
export interface MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly userId: string

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly dateCreatedFrom: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly dateCreatedTo: string

    /**
     * Filtering by currency id.
     * @type {number}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly currencyId: number

    /**
     * Filtering by user kind.
     * @type {MutualSettlementUserKinds}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly userKind: MutualSettlementUserKinds

    /**
     * 
     * @type {number}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * MutualSettlementsApi - object-oriented interface
 * @export
 * @class MutualSettlementsApi
 * @extends {BaseAPI}
 */
export class MutualSettlementsApi extends BaseAPI {
    /**
     * Export packaging list data.  Role check: is_staff  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)
     * @summary Export mutual settlements packaging list data.
     * @param {MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MutualSettlementsApi
     */
    public mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet(requestParameters: MutualSettlementsApiMutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGetRequest, options?: AxiosRequestConfig) {
        return MutualSettlementsApiFp(this.configuration).mutualSettlementsExportPackagingListMutualSettlementsUserIdExportTypeGet(requestParameters.userId, requestParameters.exportType, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.currencyId, requestParameters.userKind, requestParameters.exportLanguage, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get mutual settlements list.  Permission: crm_view_clients || crm_view_suppliers || (crm_view_clients && crm_view_suppliers)  Role check: is_staff.
     * @summary Get mutual settlements list.
     * @param {MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MutualSettlementsApi
     */
    public mutualSettlementsListMutualSettlementsUserIdGet(requestParameters: MutualSettlementsApiMutualSettlementsListMutualSettlementsUserIdGetRequest, options?: AxiosRequestConfig) {
        return MutualSettlementsApiFp(this.configuration).mutualSettlementsListMutualSettlementsUserIdGet(requestParameters.userId, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.currencyId, requestParameters.userKind, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NomenclaturesApi - axios parameter creator
 * @export
 */
export const NomenclaturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get nomenclature additional info for sites.  Role needed: \'is_staff\'.
         * @summary Get nomenclature additional info for sites
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet: async (nomenclatureId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/additional_info/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update nomenclature additional info for sites.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Update additional info for nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {Array<File>} [images] Nomenclature image, not more than 5 pc, not more than 5MB. JPG/PNG/GIF/JPEG formats are supported.Uncheck to load empty value
         * @param {Array<string>} [imageIdsForDelete] List of IDs for deleting images from the DB. Images whose IDs are not in the list will be saved.
         * @param {Array<string>} [videoLinks] List of video links. Links that were not received will be removed from the DB. Uncheck to load empty value
         * @param {string} [description] Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut: async (nomenclatureId: number, acceptLanguage?: string, images?: Array<File>, imageIdsForDelete?: Array<string>, videoLinks?: Array<string>, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/additional_info/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }

            if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageIdsForDelete) {
                localVarFormParams.append('imageIdsForDelete', imageIdsForDelete.join(COLLECTION_FORMATS.csv));
            }

                if (videoLinks) {
                localVarFormParams.append('videoLinks', videoLinks.join(COLLECTION_FORMATS.csv));
            }

    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an analog to the nomenclature. Products or services can be added.  Use /nomenclatures/?excludeAnalogsForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Add an analog to the nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureAnalogsAddSchema} nomenclatureAnalogsAddSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut: async (nomenclatureId: number, nomenclatureAnalogsAddSchema: NomenclatureAnalogsAddSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'nomenclatureAnalogsAddSchema' is not null or undefined
            assertParamExists('nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut', 'nomenclatureAnalogsAddSchema', nomenclatureAnalogsAddSchema)
            const localVarPath = `/nomenclatures/{nomenclature_id}/analogs/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nomenclatureAnalogsAddSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all nomenclature analogs.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature analogs
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet: async (nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/analogs/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove analog from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Remove analog from the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} analogId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete: async (nomenclatureId: number, analogId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'analogId' is not null or undefined
            assertParamExists('nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete', 'analogId', analogId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/analogs/{analog_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)))
                .replace(`{${"analog_id"}}`, encodeURIComponent(String(analogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new product/service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Create new product or service nomenclature
         * @param {NomenclatureCreateSchema} nomenclatureCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesCreateOneNomenclaturesPost: async (nomenclatureCreateSchema: NomenclatureCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureCreateSchema' is not null or undefined
            assertParamExists('nomenclaturesCreateOneNomenclaturesPost', 'nomenclatureCreateSchema', nomenclatureCreateSchema)
            const localVarPath = `/nomenclatures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nomenclatureCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete nomenclature.  Deletion is not available if the nomenclature is applied somewhere.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Delete nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete: async (nomenclatureId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current nomenclatures.  Pagination and dynamic column is used.  Dynamic loading of existing warehouses with obtaining the total number of nomenclatures and reserves.  (Endpoint) get orders with nomenclature reserve - /orders/clients/reserve/nomenclature/{nomenclature_id}/ (Endpoint) get orders with expected nomenclature - /orders/suppliers/expected/nomenclatures/{nomenclature_id}/  Role needed: \'is_staff\'.
         * @summary Get all nomenclatures
         * @param {TypeFilter} [type] Filtering by type.
         * @param {Array<number>} [brand] Filtering by brand ID. Several brand IDs can be selected.
         * @param {Array<number>} [country] Filtering by country ID. Several country IDs can be selected.
         * @param {Array<number>} [category] Filtering by category ID. Several category IDs can be selected.
         * @param {Array<number>} [subcategory] The filter is not available until at least one category is selected. Filtering by subcategories. If None, but the category(s) is selected, all items for the category(s) will be displayed, otherwise filtering by category + its subcategories.
         * @param {string} [searchFilter] Search by name, vendor code and customs code.
         * @param {UnitFilter} [unit] Filtering by unit.
         * @param {boolean} [isActive] Filtering by status. If None - all statuses will be shown.
         * @param {boolean} [isShow] Filtering by show on the site status. If None - all shown statuses will be shown.
         * @param {boolean} [hasReserve] Filtering by has reserve nomenclature in warehouses. All nomenclatures is default.
         * @param {boolean} [hasComment] Filtering by has comment nomenclature. All nomenclatures is default.
         * @param {ExpectedFilter} [isExpected] Filtering by the expected nomenclature. All nomenclatures is default.
         * @param {number} [excludeAnalogsForNomenclatureId] Exclude analogs from the list for a specific nomenclature. If None - all nomenclatures will be shown.
         * @param {number} [excludeRelatedNomenclaturesForNomenclatureId] Exclude related nomenclatures from the list for a specific nomenclature. If None - all nomenclatures will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesGetAllNomenclaturesGet: async (type?: TypeFilter, brand?: Array<number>, country?: Array<number>, category?: Array<number>, subcategory?: Array<number>, searchFilter?: string, unit?: UnitFilter, isActive?: boolean, isShow?: boolean, hasReserve?: boolean, hasComment?: boolean, isExpected?: ExpectedFilter, excludeAnalogsForNomenclatureId?: number, excludeRelatedNomenclaturesForNomenclatureId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/nomenclatures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (brand) {
                localVarQueryParameter['brand'] = brand;
            }

            if (country) {
                localVarQueryParameter['country'] = country;
            }

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (subcategory) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (isShow !== undefined) {
                localVarQueryParameter['isShow'] = isShow;
            }

            if (hasReserve !== undefined) {
                localVarQueryParameter['hasReserve'] = hasReserve;
            }

            if (hasComment !== undefined) {
                localVarQueryParameter['hasComment'] = hasComment;
            }

            if (isExpected !== undefined) {
                localVarQueryParameter['isExpected'] = isExpected;
            }

            if (excludeAnalogsForNomenclatureId !== undefined) {
                localVarQueryParameter['excludeAnalogsForNomenclatureId'] = excludeAnalogsForNomenclatureId;
            }

            if (excludeRelatedNomenclaturesForNomenclatureId !== undefined) {
                localVarQueryParameter['excludeRelatedNomenclaturesForNomenclatureId'] = excludeRelatedNomenclaturesForNomenclatureId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get nomenclature detail(product or service).  Role needed: \'is_staff\'.
         * @summary Get nomenclature detail
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesGetOneNomenclaturesNomenclatureIdGet: async (nomenclatureId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesGetOneNomenclaturesNomenclatureIdGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current balances of product nomenclature on the warehouses.  Use for nomenclature movement page.  Role needed: \'is_staff\'.
         * @summary Get current balances of nomenclature on the warehouses
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet: async (nomenclatureId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/total_balances/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all movements for product nomenclature.  Pagination and filtering is used.  Role needed: \'is_staff\'.
         * @summary Get all movements for product nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {ProductMovementOperationInfos} [info] Filtering by info. If None - all movement operations will be shown.
         * @param {string} [searchFilter] Search by document number(invoices, product returns and product movement).
         * @param {string} [creator] Filtering by creator. If None - all movement operations will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet: async (nomenclatureId: number, dateCreatedFrom?: string, dateCreatedTo?: string, info?: ProductMovementOperationInfos, searchFilter?: string, creator?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/movements/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all prices for nomenclature.  Product nomenclature: average market price, cost price and prices from settings. If any active price category from the settings is not configured for the nomenclature, it will be \"isComplete=False\"  Service nomenclature: only average market price and fixed price. If the fixed price is empty, will get the status \"isComplete=False\"  Role needed: \'is_staff\'.
         * @summary Get all prices for nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet: async (nomenclatureId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/prices/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update price list for product nomenclature.  If any of the prices for the nomenclature is active, the value field must be filled.  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
         * @summary Update price list for product nomenclature
         * @param {number} nomenclatureId 
         * @param {ProductNomenclaturePriceListUpdateSchema} productNomenclaturePriceListUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut: async (nomenclatureId: number, productNomenclaturePriceListUpdateSchema: ProductNomenclaturePriceListUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'productNomenclaturePriceListUpdateSchema' is not null or undefined
            assertParamExists('nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut', 'productNomenclaturePriceListUpdateSchema', productNomenclaturePriceListUpdateSchema)
            const localVarPath = `/nomenclatures/{nomenclature_id}/prices/product/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productNomenclaturePriceListUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update fixed price for service nomenclature.  If the fixed price field is empty, the nomenclature will receive the status \"isComplete=False\"  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
         * @summary Update fixed price for service nomenclature
         * @param {number} nomenclatureId 
         * @param {ServiceNomenclaturePriceListUpdateSchema} serviceNomenclaturePriceListUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut: async (nomenclatureId: number, serviceNomenclaturePriceListUpdateSchema: ServiceNomenclaturePriceListUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'serviceNomenclaturePriceListUpdateSchema' is not null or undefined
            assertParamExists('nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut', 'serviceNomenclaturePriceListUpdateSchema', serviceNomenclaturePriceListUpdateSchema)
            const localVarPath = `/nomenclatures/{nomenclature_id}/prices/service/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceNomenclaturePriceListUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a related nomenclatures to the nomenclature. Products or services can be added.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Add a related nomenclatures to the nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureRelatedNomenclaturesAddSchema} nomenclatureRelatedNomenclaturesAddSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut: async (nomenclatureId: number, nomenclatureRelatedNomenclaturesAddSchema: NomenclatureRelatedNomenclaturesAddSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'nomenclatureRelatedNomenclaturesAddSchema' is not null or undefined
            assertParamExists('nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut', 'nomenclatureRelatedNomenclaturesAddSchema', nomenclatureRelatedNomenclaturesAddSchema)
            const localVarPath = `/nomenclatures/{nomenclature_id}/related_nomenclatures/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nomenclatureRelatedNomenclaturesAddSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all nomenclature related nomenclatures.  Use /nomenclatures/?excludeRelatedNomenclaturesForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature related nomenclatures
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet: async (nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/related_nomenclatures/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove related nomenclature from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Remove related nomenclature from the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} relatedNomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete: async (nomenclatureId: number, relatedNomenclatureId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'relatedNomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete', 'relatedNomenclatureId', relatedNomenclatureId)
            const localVarPath = `/nomenclatures/{nomenclature_id}/related_nomenclatures/{related_nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)))
                .replace(`{${"related_nomenclature_id"}}`, encodeURIComponent(String(relatedNomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update new product or service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Update product or service nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureUpdateSchema} nomenclatureUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut: async (nomenclatureId: number, nomenclatureUpdateSchema: NomenclatureUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut', 'nomenclatureId', nomenclatureId)
            // verify required parameter 'nomenclatureUpdateSchema' is not null or undefined
            assertParamExists('nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut', 'nomenclatureUpdateSchema', nomenclatureUpdateSchema)
            const localVarPath = `/nomenclatures/{nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nomenclatureUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NomenclaturesApi - functional programming interface
 * @export
 */
export const NomenclaturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NomenclaturesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get nomenclature additional info for sites.  Role needed: \'is_staff\'.
         * @summary Get nomenclature additional info for sites
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet(nomenclatureId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureAdditionalInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet(nomenclatureId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update nomenclature additional info for sites.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Update additional info for nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {Array<File>} [images] Nomenclature image, not more than 5 pc, not more than 5MB. JPG/PNG/GIF/JPEG formats are supported.Uncheck to load empty value
         * @param {Array<string>} [imageIdsForDelete] List of IDs for deleting images from the DB. Images whose IDs are not in the list will be saved.
         * @param {Array<string>} [videoLinks] List of video links. Links that were not received will be removed from the DB. Uncheck to load empty value
         * @param {string} [description] Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut(nomenclatureId: number, acceptLanguage?: string, images?: Array<File>, imageIdsForDelete?: Array<string>, videoLinks?: Array<string>, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureAdditionalInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut(nomenclatureId, acceptLanguage, images, imageIdsForDelete, videoLinks, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an analog to the nomenclature. Products or services can be added.  Use /nomenclatures/?excludeAnalogsForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Add an analog to the nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureAnalogsAddSchema} nomenclatureAnalogsAddSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut(nomenclatureId: number, nomenclatureAnalogsAddSchema: NomenclatureAnalogsAddSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureAnalogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut(nomenclatureId, nomenclatureAnalogsAddSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all nomenclature analogs.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature analogs
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureAnalogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet(nomenclatureId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove analog from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Remove analog from the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} analogId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete(nomenclatureId: number, analogId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete(nomenclatureId, analogId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new product/service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Create new product or service nomenclature
         * @param {NomenclatureCreateSchema} nomenclatureCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesCreateOneNomenclaturesPost(nomenclatureCreateSchema: NomenclatureCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesCreateOneNomenclaturesPost(nomenclatureCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete nomenclature.  Deletion is not available if the nomenclature is applied somewhere.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Delete nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete(nomenclatureId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete(nomenclatureId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current nomenclatures.  Pagination and dynamic column is used.  Dynamic loading of existing warehouses with obtaining the total number of nomenclatures and reserves.  (Endpoint) get orders with nomenclature reserve - /orders/clients/reserve/nomenclature/{nomenclature_id}/ (Endpoint) get orders with expected nomenclature - /orders/suppliers/expected/nomenclatures/{nomenclature_id}/  Role needed: \'is_staff\'.
         * @summary Get all nomenclatures
         * @param {TypeFilter} [type] Filtering by type.
         * @param {Array<number>} [brand] Filtering by brand ID. Several brand IDs can be selected.
         * @param {Array<number>} [country] Filtering by country ID. Several country IDs can be selected.
         * @param {Array<number>} [category] Filtering by category ID. Several category IDs can be selected.
         * @param {Array<number>} [subcategory] The filter is not available until at least one category is selected. Filtering by subcategories. If None, but the category(s) is selected, all items for the category(s) will be displayed, otherwise filtering by category + its subcategories.
         * @param {string} [searchFilter] Search by name, vendor code and customs code.
         * @param {UnitFilter} [unit] Filtering by unit.
         * @param {boolean} [isActive] Filtering by status. If None - all statuses will be shown.
         * @param {boolean} [isShow] Filtering by show on the site status. If None - all shown statuses will be shown.
         * @param {boolean} [hasReserve] Filtering by has reserve nomenclature in warehouses. All nomenclatures is default.
         * @param {boolean} [hasComment] Filtering by has comment nomenclature. All nomenclatures is default.
         * @param {ExpectedFilter} [isExpected] Filtering by the expected nomenclature. All nomenclatures is default.
         * @param {number} [excludeAnalogsForNomenclatureId] Exclude analogs from the list for a specific nomenclature. If None - all nomenclatures will be shown.
         * @param {number} [excludeRelatedNomenclaturesForNomenclatureId] Exclude related nomenclatures from the list for a specific nomenclature. If None - all nomenclatures will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesGetAllNomenclaturesGet(type?: TypeFilter, brand?: Array<number>, country?: Array<number>, category?: Array<number>, subcategory?: Array<number>, searchFilter?: string, unit?: UnitFilter, isActive?: boolean, isShow?: boolean, hasReserve?: boolean, hasComment?: boolean, isExpected?: ExpectedFilter, excludeAnalogsForNomenclatureId?: number, excludeRelatedNomenclaturesForNomenclatureId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesGetAllNomenclaturesGet(type, brand, country, category, subcategory, searchFilter, unit, isActive, isShow, hasReserve, hasComment, isExpected, excludeAnalogsForNomenclatureId, excludeRelatedNomenclaturesForNomenclatureId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get nomenclature detail(product or service).  Role needed: \'is_staff\'.
         * @summary Get nomenclature detail
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesGetOneNomenclaturesNomenclatureIdGet(nomenclatureId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesGetOneNomenclaturesNomenclatureIdGet(nomenclatureId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current balances of product nomenclature on the warehouses.  Use for nomenclature movement page.  Role needed: \'is_staff\'.
         * @summary Get current balances of nomenclature on the warehouses
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet(nomenclatureId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureTotalBalanceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet(nomenclatureId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all movements for product nomenclature.  Pagination and filtering is used.  Role needed: \'is_staff\'.
         * @summary Get all movements for product nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {ProductMovementOperationInfos} [info] Filtering by info. If None - all movement operations will be shown.
         * @param {string} [searchFilter] Search by document number(invoices, product returns and product movement).
         * @param {string} [creator] Filtering by creator. If None - all movement operations will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet(nomenclatureId: number, dateCreatedFrom?: string, dateCreatedTo?: string, info?: ProductMovementOperationInfos, searchFilter?: string, creator?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementOperationsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet(nomenclatureId, dateCreatedFrom, dateCreatedTo, info, searchFilter, creator, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all prices for nomenclature.  Product nomenclature: average market price, cost price and prices from settings. If any active price category from the settings is not configured for the nomenclature, it will be \"isComplete=False\"  Service nomenclature: only average market price and fixed price. If the fixed price is empty, will get the status \"isComplete=False\"  Role needed: \'is_staff\'.
         * @summary Get all prices for nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet(nomenclatureId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturePriceListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet(nomenclatureId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update price list for product nomenclature.  If any of the prices for the nomenclature is active, the value field must be filled.  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
         * @summary Update price list for product nomenclature
         * @param {number} nomenclatureId 
         * @param {ProductNomenclaturePriceListUpdateSchema} productNomenclaturePriceListUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut(nomenclatureId: number, productNomenclaturePriceListUpdateSchema: ProductNomenclaturePriceListUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturePriceListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut(nomenclatureId, productNomenclaturePriceListUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update fixed price for service nomenclature.  If the fixed price field is empty, the nomenclature will receive the status \"isComplete=False\"  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
         * @summary Update fixed price for service nomenclature
         * @param {number} nomenclatureId 
         * @param {ServiceNomenclaturePriceListUpdateSchema} serviceNomenclaturePriceListUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut(nomenclatureId: number, serviceNomenclaturePriceListUpdateSchema: ServiceNomenclaturePriceListUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturePriceListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut(nomenclatureId, serviceNomenclaturePriceListUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a related nomenclatures to the nomenclature. Products or services can be added.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Add a related nomenclatures to the nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureRelatedNomenclaturesAddSchema} nomenclatureRelatedNomenclaturesAddSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut(nomenclatureId: number, nomenclatureRelatedNomenclaturesAddSchema: NomenclatureRelatedNomenclaturesAddSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureRelatedNomenclaturesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut(nomenclatureId, nomenclatureRelatedNomenclaturesAddSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all nomenclature related nomenclatures.  Use /nomenclatures/?excludeRelatedNomenclaturesForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature related nomenclatures
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureRelatedNomenclaturesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet(nomenclatureId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove related nomenclature from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Remove related nomenclature from the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} relatedNomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete(nomenclatureId: number, relatedNomenclatureId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete(nomenclatureId, relatedNomenclatureId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update new product or service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Update product or service nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureUpdateSchema} nomenclatureUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut(nomenclatureId: number, nomenclatureUpdateSchema: NomenclatureUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut(nomenclatureId, nomenclatureUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NomenclaturesApi - factory interface
 * @export
 */
export const NomenclaturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NomenclaturesApiFp(configuration)
    return {
        /**
         * Get nomenclature additional info for sites.  Role needed: \'is_staff\'.
         * @summary Get nomenclature additional info for sites
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet(nomenclatureId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureAdditionalInfoSchema> {
            return localVarFp.nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet(nomenclatureId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update nomenclature additional info for sites.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Update additional info for nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {Array<File>} [images] Nomenclature image, not more than 5 pc, not more than 5MB. JPG/PNG/GIF/JPEG formats are supported.Uncheck to load empty value
         * @param {Array<string>} [imageIdsForDelete] List of IDs for deleting images from the DB. Images whose IDs are not in the list will be saved.
         * @param {Array<string>} [videoLinks] List of video links. Links that were not received will be removed from the DB. Uncheck to load empty value
         * @param {string} [description] Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut(nomenclatureId: number, acceptLanguage?: string, images?: Array<File>, imageIdsForDelete?: Array<string>, videoLinks?: Array<string>, description?: string, options?: any): AxiosPromise<NomenclatureAdditionalInfoSchema> {
            return localVarFp.nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut(nomenclatureId, acceptLanguage, images, imageIdsForDelete, videoLinks, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an analog to the nomenclature. Products or services can be added.  Use /nomenclatures/?excludeAnalogsForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Add an analog to the nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureAnalogsAddSchema} nomenclatureAnalogsAddSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut(nomenclatureId: number, nomenclatureAnalogsAddSchema: NomenclatureAnalogsAddSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureAnalogsPage> {
            return localVarFp.nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut(nomenclatureId, nomenclatureAnalogsAddSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all nomenclature analogs.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature analogs
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureAnalogsPage> {
            return localVarFp.nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet(nomenclatureId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove analog from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Remove analog from the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} analogId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete(nomenclatureId: number, analogId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete(nomenclatureId, analogId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new product/service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Create new product or service nomenclature
         * @param {NomenclatureCreateSchema} nomenclatureCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesCreateOneNomenclaturesPost(nomenclatureCreateSchema: NomenclatureCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureDetailSchema> {
            return localVarFp.nomenclaturesCreateOneNomenclaturesPost(nomenclatureCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete nomenclature.  Deletion is not available if the nomenclature is applied somewhere.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Delete nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete(nomenclatureId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete(nomenclatureId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current nomenclatures.  Pagination and dynamic column is used.  Dynamic loading of existing warehouses with obtaining the total number of nomenclatures and reserves.  (Endpoint) get orders with nomenclature reserve - /orders/clients/reserve/nomenclature/{nomenclature_id}/ (Endpoint) get orders with expected nomenclature - /orders/suppliers/expected/nomenclatures/{nomenclature_id}/  Role needed: \'is_staff\'.
         * @summary Get all nomenclatures
         * @param {TypeFilter} [type] Filtering by type.
         * @param {Array<number>} [brand] Filtering by brand ID. Several brand IDs can be selected.
         * @param {Array<number>} [country] Filtering by country ID. Several country IDs can be selected.
         * @param {Array<number>} [category] Filtering by category ID. Several category IDs can be selected.
         * @param {Array<number>} [subcategory] The filter is not available until at least one category is selected. Filtering by subcategories. If None, but the category(s) is selected, all items for the category(s) will be displayed, otherwise filtering by category + its subcategories.
         * @param {string} [searchFilter] Search by name, vendor code and customs code.
         * @param {UnitFilter} [unit] Filtering by unit.
         * @param {boolean} [isActive] Filtering by status. If None - all statuses will be shown.
         * @param {boolean} [isShow] Filtering by show on the site status. If None - all shown statuses will be shown.
         * @param {boolean} [hasReserve] Filtering by has reserve nomenclature in warehouses. All nomenclatures is default.
         * @param {boolean} [hasComment] Filtering by has comment nomenclature. All nomenclatures is default.
         * @param {ExpectedFilter} [isExpected] Filtering by the expected nomenclature. All nomenclatures is default.
         * @param {number} [excludeAnalogsForNomenclatureId] Exclude analogs from the list for a specific nomenclature. If None - all nomenclatures will be shown.
         * @param {number} [excludeRelatedNomenclaturesForNomenclatureId] Exclude related nomenclatures from the list for a specific nomenclature. If None - all nomenclatures will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesGetAllNomenclaturesGet(type?: TypeFilter, brand?: Array<number>, country?: Array<number>, category?: Array<number>, subcategory?: Array<number>, searchFilter?: string, unit?: UnitFilter, isActive?: boolean, isShow?: boolean, hasReserve?: boolean, hasComment?: boolean, isExpected?: ExpectedFilter, excludeAnalogsForNomenclatureId?: number, excludeRelatedNomenclaturesForNomenclatureId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturesPage> {
            return localVarFp.nomenclaturesGetAllNomenclaturesGet(type, brand, country, category, subcategory, searchFilter, unit, isActive, isShow, hasReserve, hasComment, isExpected, excludeAnalogsForNomenclatureId, excludeRelatedNomenclaturesForNomenclatureId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get nomenclature detail(product or service).  Role needed: \'is_staff\'.
         * @summary Get nomenclature detail
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesGetOneNomenclaturesNomenclatureIdGet(nomenclatureId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureDetailSchema> {
            return localVarFp.nomenclaturesGetOneNomenclaturesNomenclatureIdGet(nomenclatureId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current balances of product nomenclature on the warehouses.  Use for nomenclature movement page.  Role needed: \'is_staff\'.
         * @summary Get current balances of nomenclature on the warehouses
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet(nomenclatureId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureTotalBalanceSchema> {
            return localVarFp.nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet(nomenclatureId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all movements for product nomenclature.  Pagination and filtering is used.  Role needed: \'is_staff\'.
         * @summary Get all movements for product nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {ProductMovementOperationInfos} [info] Filtering by info. If None - all movement operations will be shown.
         * @param {string} [searchFilter] Search by document number(invoices, product returns and product movement).
         * @param {string} [creator] Filtering by creator. If None - all movement operations will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet(nomenclatureId: number, dateCreatedFrom?: string, dateCreatedTo?: string, info?: ProductMovementOperationInfos, searchFilter?: string, creator?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementOperationsPage> {
            return localVarFp.nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet(nomenclatureId, dateCreatedFrom, dateCreatedTo, info, searchFilter, creator, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all prices for nomenclature.  Product nomenclature: average market price, cost price and prices from settings. If any active price category from the settings is not configured for the nomenclature, it will be \"isComplete=False\"  Service nomenclature: only average market price and fixed price. If the fixed price is empty, will get the status \"isComplete=False\"  Role needed: \'is_staff\'.
         * @summary Get all prices for nomenclature
         * @param {number} nomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet(nomenclatureId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturePriceListSchema> {
            return localVarFp.nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet(nomenclatureId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update price list for product nomenclature.  If any of the prices for the nomenclature is active, the value field must be filled.  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
         * @summary Update price list for product nomenclature
         * @param {number} nomenclatureId 
         * @param {ProductNomenclaturePriceListUpdateSchema} productNomenclaturePriceListUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut(nomenclatureId: number, productNomenclaturePriceListUpdateSchema: ProductNomenclaturePriceListUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturePriceListSchema> {
            return localVarFp.nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut(nomenclatureId, productNomenclaturePriceListUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update fixed price for service nomenclature.  If the fixed price field is empty, the nomenclature will receive the status \"isComplete=False\"  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
         * @summary Update fixed price for service nomenclature
         * @param {number} nomenclatureId 
         * @param {ServiceNomenclaturePriceListUpdateSchema} serviceNomenclaturePriceListUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut(nomenclatureId: number, serviceNomenclaturePriceListUpdateSchema: ServiceNomenclaturePriceListUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturePriceListSchema> {
            return localVarFp.nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut(nomenclatureId, serviceNomenclaturePriceListUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a related nomenclatures to the nomenclature. Products or services can be added.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Add a related nomenclatures to the nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureRelatedNomenclaturesAddSchema} nomenclatureRelatedNomenclaturesAddSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut(nomenclatureId: number, nomenclatureRelatedNomenclaturesAddSchema: NomenclatureRelatedNomenclaturesAddSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureRelatedNomenclaturesPage> {
            return localVarFp.nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut(nomenclatureId, nomenclatureRelatedNomenclaturesAddSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all nomenclature related nomenclatures.  Use /nomenclatures/?excludeRelatedNomenclaturesForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature related nomenclatures
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureRelatedNomenclaturesPage> {
            return localVarFp.nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet(nomenclatureId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove related nomenclature from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Remove related nomenclature from the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} relatedNomenclatureId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete(nomenclatureId: number, relatedNomenclatureId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete(nomenclatureId, relatedNomenclatureId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update new product or service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Update product or service nomenclature
         * @param {number} nomenclatureId 
         * @param {NomenclatureUpdateSchema} nomenclatureUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut(nomenclatureId: number, nomenclatureUpdateSchema: NomenclatureUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureDetailSchema> {
            return localVarFp.nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut(nomenclatureId, nomenclatureUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGetRequest
 */
export interface NomenclaturesApiNomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPutRequest
 */
export interface NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPutRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut
     */
    readonly acceptLanguage?: string

    /**
     * Nomenclature image, not more than 5 pc, not more than 5MB. JPG/PNG/GIF/JPEG formats are supported.Uncheck to load empty value
     * @type {Array<File>}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut
     */
    readonly images?: Array<File>

    /**
     * List of IDs for deleting images from the DB. Images whose IDs are not in the list will be saved.
     * @type {Array<string>}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut
     */
    readonly imageIdsForDelete?: Array<string>

    /**
     * List of video links. Links that were not received will be removed from the DB. Uncheck to load empty value
     * @type {Array<string>}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut
     */
    readonly videoLinks?: Array<string>

    /**
     * Comment
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut
     */
    readonly description?: string
}

/**
 * Request parameters for nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPutRequest
 */
export interface NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPutRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {NomenclatureAnalogsAddSchema}
     * @memberof NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut
     */
    readonly nomenclatureAnalogsAddSchema: NomenclatureAnalogsAddSchema

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGetRequest
 */
export interface NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDeleteRequest
 */
export interface NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete
     */
    readonly analogId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesCreateOneNomenclaturesPost operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesCreateOneNomenclaturesPostRequest
 */
export interface NomenclaturesApiNomenclaturesCreateOneNomenclaturesPostRequest {
    /**
     * 
     * @type {NomenclatureCreateSchema}
     * @memberof NomenclaturesApiNomenclaturesCreateOneNomenclaturesPost
     */
    readonly nomenclatureCreateSchema: NomenclatureCreateSchema

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesCreateOneNomenclaturesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesDeleteOneNomenclaturesNomenclatureIdDeleteRequest
 */
export interface NomenclaturesApiNomenclaturesDeleteOneNomenclaturesNomenclatureIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesGetAllNomenclaturesGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesGetAllNomenclaturesGetRequest
 */
export interface NomenclaturesApiNomenclaturesGetAllNomenclaturesGetRequest {
    /**
     * Filtering by type.
     * @type {TypeFilter}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly type?: TypeFilter

    /**
     * Filtering by brand ID. Several brand IDs can be selected.
     * @type {Array<number>}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly brand?: Array<number>

    /**
     * Filtering by country ID. Several country IDs can be selected.
     * @type {Array<number>}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly country?: Array<number>

    /**
     * Filtering by category ID. Several category IDs can be selected.
     * @type {Array<number>}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly category?: Array<number>

    /**
     * The filter is not available until at least one category is selected. Filtering by subcategories. If None, but the category(s) is selected, all items for the category(s) will be displayed, otherwise filtering by category + its subcategories.
     * @type {Array<number>}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly subcategory?: Array<number>

    /**
     * Search by name, vendor code and customs code.
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by unit.
     * @type {UnitFilter}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly unit?: UnitFilter

    /**
     * Filtering by status. If None - all statuses will be shown.
     * @type {boolean}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly isActive?: boolean

    /**
     * Filtering by show on the site status. If None - all shown statuses will be shown.
     * @type {boolean}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly isShow?: boolean

    /**
     * Filtering by has reserve nomenclature in warehouses. All nomenclatures is default.
     * @type {boolean}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly hasReserve?: boolean

    /**
     * Filtering by has comment nomenclature. All nomenclatures is default.
     * @type {boolean}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly hasComment?: boolean

    /**
     * Filtering by the expected nomenclature. All nomenclatures is default.
     * @type {ExpectedFilter}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly isExpected?: ExpectedFilter

    /**
     * Exclude analogs from the list for a specific nomenclature. If None - all nomenclatures will be shown.
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly excludeAnalogsForNomenclatureId?: number

    /**
     * Exclude related nomenclatures from the list for a specific nomenclature. If None - all nomenclatures will be shown.
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly excludeRelatedNomenclaturesForNomenclatureId?: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesGetAllNomenclaturesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesGetOneNomenclaturesNomenclatureIdGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesGetOneNomenclaturesNomenclatureIdGetRequest
 */
export interface NomenclaturesApiNomenclaturesGetOneNomenclaturesNomenclatureIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesGetOneNomenclaturesNomenclatureIdGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesGetOneNomenclaturesNomenclatureIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGetRequest
 */
export interface NomenclaturesApiNomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGetRequest
 */
export interface NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly nomenclatureId: number

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Filtering by info. If None - all movement operations will be shown.
     * @type {ProductMovementOperationInfos}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly info?: ProductMovementOperationInfos

    /**
     * Search by document number(invoices, product returns and product movement).
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by creator. If None - all movement operations will be shown.
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly creator?: string

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGetRequest
 */
export interface NomenclaturesApiNomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPutRequest
 */
export interface NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPutRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {ProductNomenclaturePriceListUpdateSchema}
     * @memberof NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut
     */
    readonly productNomenclaturePriceListUpdateSchema: ProductNomenclaturePriceListUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePutRequest
 */
export interface NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePutRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {ServiceNomenclaturePriceListUpdateSchema}
     * @memberof NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut
     */
    readonly serviceNomenclaturePriceListUpdateSchema: ServiceNomenclaturePriceListUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPutRequest
 */
export interface NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPutRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {NomenclatureRelatedNomenclaturesAddSchema}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut
     */
    readonly nomenclatureRelatedNomenclaturesAddSchema: NomenclatureRelatedNomenclaturesAddSchema

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGetRequest
 */
export interface NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDeleteRequest
 */
export interface NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete
     */
    readonly relatedNomenclatureId: number

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut operation in NomenclaturesApi.
 * @export
 * @interface NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPutRequest
 */
export interface NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPut
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {NomenclatureUpdateSchema}
     * @memberof NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPut
     */
    readonly nomenclatureUpdateSchema: NomenclatureUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * NomenclaturesApi - object-oriented interface
 * @export
 * @class NomenclaturesApi
 * @extends {BaseAPI}
 */
export class NomenclaturesApi extends BaseAPI {
    /**
     * Get nomenclature additional info for sites.  Role needed: \'is_staff\'.
     * @summary Get nomenclature additional info for sites
     * @param {NomenclaturesApiNomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet(requestParameters: NomenclaturesApiNomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesAdditionalInfoGetNomenclaturesNomenclatureIdAdditionalInfoGet(requestParameters.nomenclatureId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update nomenclature additional info for sites.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Update additional info for nomenclature
     * @param {NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut(requestParameters: NomenclaturesApiNomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPutRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesAdditionalInfoUpdateNomenclaturesNomenclatureIdAdditionalInfoPut(requestParameters.nomenclatureId, requestParameters.acceptLanguage, requestParameters.images, requestParameters.imageIdsForDelete, requestParameters.videoLinks, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an analog to the nomenclature. Products or services can be added.  Use /nomenclatures/?excludeAnalogsForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Add an analog to the nomenclature
     * @param {NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut(requestParameters: NomenclaturesApiNomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPutRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesAnalogsAddNomenclaturesNomenclatureIdAnalogsPut(requestParameters.nomenclatureId, requestParameters.nomenclatureAnalogsAddSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all nomenclature analogs.  Role needed: \'is_staff\'.
     * @summary Get all nomenclature analogs
     * @param {NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet(requestParameters: NomenclaturesApiNomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesAnalogsGetAllNomenclaturesNomenclatureIdAnalogsGet(requestParameters.nomenclatureId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove analog from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Remove analog from the nomenclature
     * @param {NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete(requestParameters: NomenclaturesApiNomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDeleteRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesAnalogsRemoveNomenclaturesNomenclatureIdAnalogsAnalogIdDelete(requestParameters.nomenclatureId, requestParameters.analogId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new product/service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Create new product or service nomenclature
     * @param {NomenclaturesApiNomenclaturesCreateOneNomenclaturesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesCreateOneNomenclaturesPost(requestParameters: NomenclaturesApiNomenclaturesCreateOneNomenclaturesPostRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesCreateOneNomenclaturesPost(requestParameters.nomenclatureCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete nomenclature.  Deletion is not available if the nomenclature is applied somewhere.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Delete nomenclature
     * @param {NomenclaturesApiNomenclaturesDeleteOneNomenclaturesNomenclatureIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete(requestParameters: NomenclaturesApiNomenclaturesDeleteOneNomenclaturesNomenclatureIdDeleteRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesDeleteOneNomenclaturesNomenclatureIdDelete(requestParameters.nomenclatureId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current nomenclatures.  Pagination and dynamic column is used.  Dynamic loading of existing warehouses with obtaining the total number of nomenclatures and reserves.  (Endpoint) get orders with nomenclature reserve - /orders/clients/reserve/nomenclature/{nomenclature_id}/ (Endpoint) get orders with expected nomenclature - /orders/suppliers/expected/nomenclatures/{nomenclature_id}/  Role needed: \'is_staff\'.
     * @summary Get all nomenclatures
     * @param {NomenclaturesApiNomenclaturesGetAllNomenclaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesGetAllNomenclaturesGet(requestParameters: NomenclaturesApiNomenclaturesGetAllNomenclaturesGetRequest = {}, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesGetAllNomenclaturesGet(requestParameters.type, requestParameters.brand, requestParameters.country, requestParameters.category, requestParameters.subcategory, requestParameters.searchFilter, requestParameters.unit, requestParameters.isActive, requestParameters.isShow, requestParameters.hasReserve, requestParameters.hasComment, requestParameters.isExpected, requestParameters.excludeAnalogsForNomenclatureId, requestParameters.excludeRelatedNomenclaturesForNomenclatureId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get nomenclature detail(product or service).  Role needed: \'is_staff\'.
     * @summary Get nomenclature detail
     * @param {NomenclaturesApiNomenclaturesGetOneNomenclaturesNomenclatureIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesGetOneNomenclaturesNomenclatureIdGet(requestParameters: NomenclaturesApiNomenclaturesGetOneNomenclaturesNomenclatureIdGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesGetOneNomenclaturesNomenclatureIdGet(requestParameters.nomenclatureId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current balances of product nomenclature on the warehouses.  Use for nomenclature movement page.  Role needed: \'is_staff\'.
     * @summary Get current balances of nomenclature on the warehouses
     * @param {NomenclaturesApiNomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet(requestParameters: NomenclaturesApiNomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesGetTotalBalancesNomenclaturesNomenclatureIdTotalBalancesGet(requestParameters.nomenclatureId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all movements for product nomenclature.  Pagination and filtering is used.  Role needed: \'is_staff\'.
     * @summary Get all movements for product nomenclature
     * @param {NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet(requestParameters: NomenclaturesApiNomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesMovementsGetAllNomenclaturesNomenclatureIdMovementsGet(requestParameters.nomenclatureId, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.info, requestParameters.searchFilter, requestParameters.creator, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all prices for nomenclature.  Product nomenclature: average market price, cost price and prices from settings. If any active price category from the settings is not configured for the nomenclature, it will be \"isComplete=False\"  Service nomenclature: only average market price and fixed price. If the fixed price is empty, will get the status \"isComplete=False\"  Role needed: \'is_staff\'.
     * @summary Get all prices for nomenclature
     * @param {NomenclaturesApiNomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet(requestParameters: NomenclaturesApiNomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesPricesGetAllNomenclaturesNomenclatureIdPricesGet(requestParameters.nomenclatureId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update price list for product nomenclature.  If any of the prices for the nomenclature is active, the value field must be filled.  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
     * @summary Update price list for product nomenclature
     * @param {NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut(requestParameters: NomenclaturesApiNomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPutRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesPricesUpdateProductNomenclaturesNomenclatureIdPricesProductPut(requestParameters.nomenclatureId, requestParameters.productNomenclaturePriceListUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update fixed price for service nomenclature.  If the fixed price field is empty, the nomenclature will receive the status \"isComplete=False\"  Perms needed: \'warehouse_change_nomenclature_price_access\'.  Role needed: \'is_staff\'.
     * @summary Update fixed price for service nomenclature
     * @param {NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut(requestParameters: NomenclaturesApiNomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePutRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesPricesUpdateServiceNomenclaturesNomenclatureIdPricesServicePut(requestParameters.nomenclatureId, requestParameters.serviceNomenclaturePriceListUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a related nomenclatures to the nomenclature. Products or services can be added.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Add a related nomenclatures to the nomenclature
     * @param {NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut(requestParameters: NomenclaturesApiNomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPutRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesRelatedNomenclaturesAddNomenclaturesNomenclatureIdRelatedNomenclaturesPut(requestParameters.nomenclatureId, requestParameters.nomenclatureRelatedNomenclaturesAddSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all nomenclature related nomenclatures.  Use /nomenclatures/?excludeRelatedNomenclaturesForNomenclatureId={nomenclature_id} for exclude analogs from the list.  Role needed: \'is_staff\'.
     * @summary Get all nomenclature related nomenclatures
     * @param {NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet(requestParameters: NomenclaturesApiNomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGetRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesRelatedNomenclaturesGetAllNomenclaturesNomenclatureIdRelatedNomenclaturesGet(requestParameters.nomenclatureId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove related nomenclature from the nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Remove related nomenclature from the nomenclature
     * @param {NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete(requestParameters: NomenclaturesApiNomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDeleteRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesRelatedNomenclaturesRemoveNomenclaturesNomenclatureIdRelatedNomenclaturesRelatedNomenclatureIdDelete(requestParameters.nomenclatureId, requestParameters.relatedNomenclatureId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update new product or service nomenclature.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Update product or service nomenclature
     * @param {NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NomenclaturesApi
     */
    public nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut(requestParameters: NomenclaturesApiNomenclaturesUpdateOneNomenclaturesNomenclatureIdPutRequest, options?: AxiosRequestConfig) {
        return NomenclaturesApiFp(this.configuration).nomenclaturesUpdateOneNomenclaturesNomenclatureIdPut(requestParameters.nomenclatureId, requestParameters.nomenclatureUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NoteFilesApi - axios parameter creator
 * @export
 */
export const NoteFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create note file
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {File} file 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noteFilesCreateNoteFilesNoteTypeNoteIdPost: async (noteType: NoteTypes, noteId: number, file: File, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteType' is not null or undefined
            assertParamExists('noteFilesCreateNoteFilesNoteTypeNoteIdPost', 'noteType', noteType)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('noteFilesCreateNoteFilesNoteTypeNoteIdPost', 'noteId', noteId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('noteFilesCreateNoteFilesNoteTypeNoteIdPost', 'file', file)
            const localVarPath = `/note-files/{note_type}/{note_id}/`
                .replace(`{${"note_type"}}`, encodeURIComponent(String(noteType)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete note file
         * @param {NoteTypes} noteType 
         * @param {number} noteFileId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete: async (noteType: NoteTypes, noteFileId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteType' is not null or undefined
            assertParamExists('noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete', 'noteType', noteType)
            // verify required parameter 'noteFileId' is not null or undefined
            assertParamExists('noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete', 'noteFileId', noteFileId)
            const localVarPath = `/note-files/{note_type}/{note_file_id}/`
                .replace(`{${"note_type"}}`, encodeURIComponent(String(noteType)))
                .replace(`{${"note_file_id"}}`, encodeURIComponent(String(noteFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteFilesApi - functional programming interface
 * @export
 */
export const NoteFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NoteFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create note file
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {File} file 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async noteFilesCreateNoteFilesNoteTypeNoteIdPost(noteType: NoteTypes, noteId: number, file: File, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteFileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.noteFilesCreateNoteFilesNoteTypeNoteIdPost(noteType, noteId, file, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete note file
         * @param {NoteTypes} noteType 
         * @param {number} noteFileId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete(noteType: NoteTypes, noteFileId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete(noteType, noteFileId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NoteFilesApi - factory interface
 * @export
 */
export const NoteFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoteFilesApiFp(configuration)
    return {
        /**
         * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create note file
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {File} file 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noteFilesCreateNoteFilesNoteTypeNoteIdPost(noteType: NoteTypes, noteId: number, file: File, acceptLanguage?: string, options?: any): AxiosPromise<NoteFileSchema> {
            return localVarFp.noteFilesCreateNoteFilesNoteTypeNoteIdPost(noteType, noteId, file, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete note file
         * @param {NoteTypes} noteType 
         * @param {number} noteFileId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete(noteType: NoteTypes, noteFileId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete(noteType, noteFileId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for noteFilesCreateNoteFilesNoteTypeNoteIdPost operation in NoteFilesApi.
 * @export
 * @interface NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPostRequest
 */
export interface NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPostRequest {
    /**
     * 
     * @type {NoteTypes}
     * @memberof NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPost
     */
    readonly noteType: NoteTypes

    /**
     * 
     * @type {number}
     * @memberof NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPost
     */
    readonly noteId: number

    /**
     * 
     * @type {File}
     * @memberof NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPost
     */
    readonly file: File

    /**
     * 
     * @type {string}
     * @memberof NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete operation in NoteFilesApi.
 * @export
 * @interface NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDeleteRequest
 */
export interface NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDeleteRequest {
    /**
     * 
     * @type {NoteTypes}
     * @memberof NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete
     */
    readonly noteType: NoteTypes

    /**
     * 
     * @type {number}
     * @memberof NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete
     */
    readonly noteFileId: number

    /**
     * 
     * @type {string}
     * @memberof NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * NoteFilesApi - object-oriented interface
 * @export
 * @class NoteFilesApi
 * @extends {BaseAPI}
 */
export class NoteFilesApi extends BaseAPI {
    /**
     * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Create note file
     * @param {NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteFilesApi
     */
    public noteFilesCreateNoteFilesNoteTypeNoteIdPost(requestParameters: NoteFilesApiNoteFilesCreateNoteFilesNoteTypeNoteIdPostRequest, options?: AxiosRequestConfig) {
        return NoteFilesApiFp(this.configuration).noteFilesCreateNoteFilesNoteTypeNoteIdPost(requestParameters.noteType, requestParameters.noteId, requestParameters.file, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Delete note file
     * @param {NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteFilesApi
     */
    public noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete(requestParameters: NoteFilesApiNoteFilesDeleteNoteFilesNoteTypeNoteFileIdDeleteRequest, options?: AxiosRequestConfig) {
        return NoteFilesApiFp(this.configuration).noteFilesDeleteNoteFilesNoteTypeNoteFileIdDelete(requestParameters.noteType, requestParameters.noteFileId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotesApi - axios parameter creator
 * @export
 */
export const NotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create note
         * @param {NoteTypes} noteType 
         * @param {string} userId 
         * @param {NoteCreateSchema} noteCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesCreateNotesNoteTypeUserIdPost: async (noteType: NoteTypes, userId: string, noteCreateSchema: NoteCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteType' is not null or undefined
            assertParamExists('notesCreateNotesNoteTypeUserIdPost', 'noteType', noteType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('notesCreateNotesNoteTypeUserIdPost', 'userId', userId)
            // verify required parameter 'noteCreateSchema' is not null or undefined
            assertParamExists('notesCreateNotesNoteTypeUserIdPost', 'noteCreateSchema', noteCreateSchema)
            const localVarPath = `/notes/{note_type}/{user_id}/`
                .replace(`{${"note_type"}}`, encodeURIComponent(String(noteType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete note
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesDeleteNotesNoteTypeNoteIdDelete: async (noteType: NoteTypes, noteId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteType' is not null or undefined
            assertParamExists('notesDeleteNotesNoteTypeNoteIdDelete', 'noteType', noteType)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesDeleteNotesNoteTypeNoteIdDelete', 'noteId', noteId)
            const localVarPath = `/notes/{note_type}/{note_id}/`
                .replace(`{${"note_type"}}`, encodeURIComponent(String(noteType)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notes.  Permission required to access client/client note: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
         * @summary Get notes
         * @param {NoteTypes} noteType 
         * @param {string} userId 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {number} [countryId] 
         * @param {string} [creatorId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesListNotesNoteTypeUserIdGet: async (noteType: NoteTypes, userId: string, dateCreatedFrom?: string, dateCreatedTo?: string, countryId?: number, creatorId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteType' is not null or undefined
            assertParamExists('notesListNotesNoteTypeUserIdGet', 'noteType', noteType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('notesListNotesNoteTypeUserIdGet', 'userId', userId)
            const localVarPath = `/notes/{note_type}/{user_id}/`
                .replace(`{${"note_type"}}`, encodeURIComponent(String(noteType)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Update note
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {NoteUpdateSchema} noteUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesUpdateNotesNoteTypeNoteIdPut: async (noteType: NoteTypes, noteId: number, noteUpdateSchema: NoteUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteType' is not null or undefined
            assertParamExists('notesUpdateNotesNoteTypeNoteIdPut', 'noteType', noteType)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesUpdateNotesNoteTypeNoteIdPut', 'noteId', noteId)
            // verify required parameter 'noteUpdateSchema' is not null or undefined
            assertParamExists('notesUpdateNotesNoteTypeNoteIdPut', 'noteUpdateSchema', noteUpdateSchema)
            const localVarPath = `/notes/{note_type}/{note_id}/`
                .replace(`{${"note_type"}}`, encodeURIComponent(String(noteType)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create note
         * @param {NoteTypes} noteType 
         * @param {string} userId 
         * @param {NoteCreateSchema} noteCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesCreateNotesNoteTypeUserIdPost(noteType: NoteTypes, userId: string, noteCreateSchema: NoteCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesCreateNotesNoteTypeUserIdPost(noteType, userId, noteCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete note
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesDeleteNotesNoteTypeNoteIdDelete(noteType: NoteTypes, noteId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesDeleteNotesNoteTypeNoteIdDelete(noteType, noteId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get notes.  Permission required to access client/client note: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
         * @summary Get notes
         * @param {NoteTypes} noteType 
         * @param {string} userId 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {number} [countryId] 
         * @param {string} [creatorId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesListNotesNoteTypeUserIdGet(noteType: NoteTypes, userId: string, dateCreatedFrom?: string, dateCreatedTo?: string, countryId?: number, creatorId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotePageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesListNotesNoteTypeUserIdGet(noteType, userId, dateCreatedFrom, dateCreatedTo, countryId, creatorId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Update note
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {NoteUpdateSchema} noteUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesUpdateNotesNoteTypeNoteIdPut(noteType: NoteTypes, noteId: number, noteUpdateSchema: NoteUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesUpdateNotesNoteTypeNoteIdPut(noteType, noteId, noteUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotesApiFp(configuration)
    return {
        /**
         * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Create note
         * @param {NoteTypes} noteType 
         * @param {string} userId 
         * @param {NoteCreateSchema} noteCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesCreateNotesNoteTypeUserIdPost(noteType: NoteTypes, userId: string, noteCreateSchema: NoteCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NoteDetailSchema> {
            return localVarFp.notesCreateNotesNoteTypeUserIdPost(noteType, userId, noteCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Delete note
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesDeleteNotesNoteTypeNoteIdDelete(noteType: NoteTypes, noteId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.notesDeleteNotesNoteTypeNoteIdDelete(noteType, noteId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get notes.  Permission required to access client/client note: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
         * @summary Get notes
         * @param {NoteTypes} noteType 
         * @param {string} userId 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {number} [countryId] 
         * @param {string} [creatorId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesListNotesNoteTypeUserIdGet(noteType: NoteTypes, userId: string, dateCreatedFrom?: string, dateCreatedTo?: string, countryId?: number, creatorId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<NotePageSchema> {
            return localVarFp.notesListNotesNoteTypeUserIdGet(noteType, userId, dateCreatedFrom, dateCreatedTo, countryId, creatorId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
         * @summary Update note
         * @param {NoteTypes} noteType 
         * @param {number} noteId 
         * @param {NoteUpdateSchema} noteUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesUpdateNotesNoteTypeNoteIdPut(noteType: NoteTypes, noteId: number, noteUpdateSchema: NoteUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NoteDetailSchema> {
            return localVarFp.notesUpdateNotesNoteTypeNoteIdPut(noteType, noteId, noteUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for notesCreateNotesNoteTypeUserIdPost operation in NotesApi.
 * @export
 * @interface NotesApiNotesCreateNotesNoteTypeUserIdPostRequest
 */
export interface NotesApiNotesCreateNotesNoteTypeUserIdPostRequest {
    /**
     * 
     * @type {NoteTypes}
     * @memberof NotesApiNotesCreateNotesNoteTypeUserIdPost
     */
    readonly noteType: NoteTypes

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesCreateNotesNoteTypeUserIdPost
     */
    readonly userId: string

    /**
     * 
     * @type {NoteCreateSchema}
     * @memberof NotesApiNotesCreateNotesNoteTypeUserIdPost
     */
    readonly noteCreateSchema: NoteCreateSchema

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesCreateNotesNoteTypeUserIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notesDeleteNotesNoteTypeNoteIdDelete operation in NotesApi.
 * @export
 * @interface NotesApiNotesDeleteNotesNoteTypeNoteIdDeleteRequest
 */
export interface NotesApiNotesDeleteNotesNoteTypeNoteIdDeleteRequest {
    /**
     * 
     * @type {NoteTypes}
     * @memberof NotesApiNotesDeleteNotesNoteTypeNoteIdDelete
     */
    readonly noteType: NoteTypes

    /**
     * 
     * @type {number}
     * @memberof NotesApiNotesDeleteNotesNoteTypeNoteIdDelete
     */
    readonly noteId: number

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesDeleteNotesNoteTypeNoteIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notesListNotesNoteTypeUserIdGet operation in NotesApi.
 * @export
 * @interface NotesApiNotesListNotesNoteTypeUserIdGetRequest
 */
export interface NotesApiNotesListNotesNoteTypeUserIdGetRequest {
    /**
     * 
     * @type {NoteTypes}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly noteType: NoteTypes

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly dateCreatedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly dateCreatedTo?: string

    /**
     * 
     * @type {number}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {number}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesListNotesNoteTypeUserIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notesUpdateNotesNoteTypeNoteIdPut operation in NotesApi.
 * @export
 * @interface NotesApiNotesUpdateNotesNoteTypeNoteIdPutRequest
 */
export interface NotesApiNotesUpdateNotesNoteTypeNoteIdPutRequest {
    /**
     * 
     * @type {NoteTypes}
     * @memberof NotesApiNotesUpdateNotesNoteTypeNoteIdPut
     */
    readonly noteType: NoteTypes

    /**
     * 
     * @type {number}
     * @memberof NotesApiNotesUpdateNotesNoteTypeNoteIdPut
     */
    readonly noteId: number

    /**
     * 
     * @type {NoteUpdateSchema}
     * @memberof NotesApiNotesUpdateNotesNoteTypeNoteIdPut
     */
    readonly noteUpdateSchema: NoteUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof NotesApiNotesUpdateNotesNoteTypeNoteIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI {
    /**
     * Create a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Create note
     * @param {NotesApiNotesCreateNotesNoteTypeUserIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesCreateNotesNoteTypeUserIdPost(requestParameters: NotesApiNotesCreateNotesNoteTypeUserIdPostRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesCreateNotesNoteTypeUserIdPost(requestParameters.noteType, requestParameters.userId, requestParameters.noteCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Delete note
     * @param {NotesApiNotesDeleteNotesNoteTypeNoteIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesDeleteNotesNoteTypeNoteIdDelete(requestParameters: NotesApiNotesDeleteNotesNoteTypeNoteIdDeleteRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesDeleteNotesNoteTypeNoteIdDelete(requestParameters.noteType, requestParameters.noteId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get notes.  Permission required to access client/client note: crm_view_clients, crm_view_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_view_suppliers, warehouse_view_other_manager_supplier_access (situational)  Permission required to access agent: crm_view_agent_access
     * @summary Get notes
     * @param {NotesApiNotesListNotesNoteTypeUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesListNotesNoteTypeUserIdGet(requestParameters: NotesApiNotesListNotesNoteTypeUserIdGetRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesListNotesNoteTypeUserIdGet(requestParameters.noteType, requestParameters.userId, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.countryId, requestParameters.creatorId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a note.  Roles: is_staff  Permission required to access client/client note: crm_change_clients, crm_change_other_manager_client_access (situational)  Permission required to access supplier/supplier note: warehouse_change_suppliers, warehouse_change_other_manager_supplier_access (situational)  Permission required to access agent: crm_change_agent_access
     * @summary Update note
     * @param {NotesApiNotesUpdateNotesNoteTypeNoteIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesUpdateNotesNoteTypeNoteIdPut(requestParameters: NotesApiNotesUpdateNotesNoteTypeNoteIdPutRequest, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesUpdateNotesNoteTypeNoteIdPut(requestParameters.noteType, requestParameters.noteId, requestParameters.noteUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all user notification.  Role check: \'is_staff\'.
         * @summary Delete all user notification
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteAllNotificationsDelete: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user notification.  Role check: \'is_staff\'.
         * @summary Delete user notification
         * @param {number} userNotificationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteOneNotificationsUserNotificationIdDelete: async (userNotificationId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userNotificationId' is not null or undefined
            assertParamExists('notificationsDeleteOneNotificationsUserNotificationIdDelete', 'userNotificationId', userNotificationId)
            const localVarPath = `/notifications/{user_notification_id}/`
                .replace(`{${"user_notification_id"}}`, encodeURIComponent(String(userNotificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user notification list.  Role check: is_staff.
         * @summary Get user notification list.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {number} [notificationTagId] Filter by notification tag id
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsListNotificationsGet: async (limit?: number, offset?: number, notificationTagId?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (notificationTagId !== undefined) {
                localVarQueryParameter['notificationTagId'] = notificationTagId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notification tags for staff.  Role needed: \'is_staff\'
         * @summary Get notification tags for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsTagsGetAllNotificationsTagsGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user notification to \'read\' status.  Role needed: \'is_staff\'
         * @summary Update user notification to \'read\' status
         * @param {number} userNotificationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotificationsUserNotificationIdPut: async (userNotificationId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userNotificationId' is not null or undefined
            assertParamExists('notificationsUpdateNotificationsUserNotificationIdPut', 'userNotificationId', userNotificationId)
            const localVarPath = `/notifications/{user_notification_id}/`
                .replace(`{${"user_notification_id"}}`, encodeURIComponent(String(userNotificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete all user notification.  Role check: \'is_staff\'.
         * @summary Delete all user notification
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsDeleteAllNotificationsDelete(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsDeleteAllNotificationsDelete(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete user notification.  Role check: \'is_staff\'.
         * @summary Delete user notification
         * @param {number} userNotificationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsDeleteOneNotificationsUserNotificationIdDelete(userNotificationId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsDeleteOneNotificationsUserNotificationIdDelete(userNotificationId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user notification list.  Role check: is_staff.
         * @summary Get user notification list.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {number} [notificationTagId] Filter by notification tag id
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsListNotificationsGet(limit?: number, offset?: number, notificationTagId?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNotificationPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsListNotificationsGet(limit, offset, notificationTagId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get notification tags for staff.  Role needed: \'is_staff\'
         * @summary Get notification tags for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsTagsGetAllNotificationsTagsGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationTagSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsTagsGetAllNotificationsTagsGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user notification to \'read\' status.  Role needed: \'is_staff\'
         * @summary Update user notification to \'read\' status
         * @param {number} userNotificationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsUpdateNotificationsUserNotificationIdPut(userNotificationId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNotificationSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsUpdateNotificationsUserNotificationIdPut(userNotificationId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Delete all user notification.  Role check: \'is_staff\'.
         * @summary Delete all user notification
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteAllNotificationsDelete(acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.notificationsDeleteAllNotificationsDelete(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user notification.  Role check: \'is_staff\'.
         * @summary Delete user notification
         * @param {number} userNotificationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteOneNotificationsUserNotificationIdDelete(userNotificationId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.notificationsDeleteOneNotificationsUserNotificationIdDelete(userNotificationId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user notification list.  Role check: is_staff.
         * @summary Get user notification list.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {number} [notificationTagId] Filter by notification tag id
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsListNotificationsGet(limit?: number, offset?: number, notificationTagId?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserNotificationPage> {
            return localVarFp.notificationsListNotificationsGet(limit, offset, notificationTagId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get notification tags for staff.  Role needed: \'is_staff\'
         * @summary Get notification tags for staff
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsTagsGetAllNotificationsTagsGet(acceptLanguage?: string, options?: any): AxiosPromise<Array<NotificationTagSchema>> {
            return localVarFp.notificationsTagsGetAllNotificationsTagsGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user notification to \'read\' status.  Role needed: \'is_staff\'
         * @summary Update user notification to \'read\' status
         * @param {number} userNotificationId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotificationsUserNotificationIdPut(userNotificationId: number, acceptLanguage?: string, options?: any): AxiosPromise<UserNotificationSchema> {
            return localVarFp.notificationsUpdateNotificationsUserNotificationIdPut(userNotificationId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for notificationsDeleteAllNotificationsDelete operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotificationsDeleteAllNotificationsDeleteRequest
 */
export interface NotificationsApiNotificationsDeleteAllNotificationsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotificationsDeleteAllNotificationsDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notificationsDeleteOneNotificationsUserNotificationIdDelete operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotificationsDeleteOneNotificationsUserNotificationIdDeleteRequest
 */
export interface NotificationsApiNotificationsDeleteOneNotificationsUserNotificationIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof NotificationsApiNotificationsDeleteOneNotificationsUserNotificationIdDelete
     */
    readonly userNotificationId: number

    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotificationsDeleteOneNotificationsUserNotificationIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notificationsListNotificationsGet operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotificationsListNotificationsGetRequest
 */
export interface NotificationsApiNotificationsListNotificationsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof NotificationsApiNotificationsListNotificationsGet
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof NotificationsApiNotificationsListNotificationsGet
     */
    readonly offset?: number

    /**
     * Filter by notification tag id
     * @type {number}
     * @memberof NotificationsApiNotificationsListNotificationsGet
     */
    readonly notificationTagId?: number

    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotificationsListNotificationsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notificationsTagsGetAllNotificationsTagsGet operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotificationsTagsGetAllNotificationsTagsGetRequest
 */
export interface NotificationsApiNotificationsTagsGetAllNotificationsTagsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotificationsTagsGetAllNotificationsTagsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for notificationsUpdateNotificationsUserNotificationIdPut operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotificationsUpdateNotificationsUserNotificationIdPutRequest
 */
export interface NotificationsApiNotificationsUpdateNotificationsUserNotificationIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof NotificationsApiNotificationsUpdateNotificationsUserNotificationIdPut
     */
    readonly userNotificationId: number

    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotificationsUpdateNotificationsUserNotificationIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Delete all user notification.  Role check: \'is_staff\'.
     * @summary Delete all user notification
     * @param {NotificationsApiNotificationsDeleteAllNotificationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsDeleteAllNotificationsDelete(requestParameters: NotificationsApiNotificationsDeleteAllNotificationsDeleteRequest = {}, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsDeleteAllNotificationsDelete(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user notification.  Role check: \'is_staff\'.
     * @summary Delete user notification
     * @param {NotificationsApiNotificationsDeleteOneNotificationsUserNotificationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsDeleteOneNotificationsUserNotificationIdDelete(requestParameters: NotificationsApiNotificationsDeleteOneNotificationsUserNotificationIdDeleteRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsDeleteOneNotificationsUserNotificationIdDelete(requestParameters.userNotificationId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user notification list.  Role check: is_staff.
     * @summary Get user notification list.
     * @param {NotificationsApiNotificationsListNotificationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsListNotificationsGet(requestParameters: NotificationsApiNotificationsListNotificationsGetRequest = {}, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsListNotificationsGet(requestParameters.limit, requestParameters.offset, requestParameters.notificationTagId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get notification tags for staff.  Role needed: \'is_staff\'
     * @summary Get notification tags for staff
     * @param {NotificationsApiNotificationsTagsGetAllNotificationsTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsTagsGetAllNotificationsTagsGet(requestParameters: NotificationsApiNotificationsTagsGetAllNotificationsTagsGetRequest = {}, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsTagsGetAllNotificationsTagsGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user notification to \'read\' status.  Role needed: \'is_staff\'
     * @summary Update user notification to \'read\' status
     * @param {NotificationsApiNotificationsUpdateNotificationsUserNotificationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsUpdateNotificationsUserNotificationIdPut(requestParameters: NotificationsApiNotificationsUpdateNotificationsUserNotificationIdPutRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsUpdateNotificationsUserNotificationIdPut(requestParameters.userNotificationId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersClientApi - axios parameter creator
 * @export
 */
export const OrdersClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new client order.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Create new client order
         * @param {ClientOrderCreateSchema} clientOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersCreateOneOrdersClientsPost: async (clientOrderCreateSchema: ClientOrderCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientOrderCreateSchema' is not null or undefined
            assertParamExists('clientOrdersCreateOneOrdersClientsPost', 'clientOrderCreateSchema', clientOrderCreateSchema)
            const localVarPath = `/orders/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientOrderCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client order detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_order\'.
         * @summary Get client order detail
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersGetOneOrdersClientsOrderIdGet: async (orderId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('clientOrdersGetOneOrdersClientsOrderIdGet', 'orderId', orderId)
            const localVarPath = `/orders/clients/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client order list.  Role check: is_staff.  Permission: crm_view_client_order.
         * @summary Get client order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseOrderQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {OrderStatusesQuery} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix) and client(name, phone, email, vatNumber, registrationNumber)
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {string} [agentId] 
         * @param {ClientOrderLabels} [labels] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersListOrdersClientsGet: async (page?: number, pageSize?: number, order?: BaseOrderQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: OrderStatusesQuery, userId?: string, staffId?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, agentId?: string, labels?: ClientOrderLabels, isCashPayment?: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all orders with a reserve for the nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all orders with a reserve for the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet: async (nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/orders/clients/reserve/nomenclatures/{nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all order nomenclatures with an unused nomenclature quantity
         * @param {number} orderId 
         * @param {OrderNomenclatureTypes} documentType The type of document for which you want to get unused order nomenclatures.
         * @param {TypeFilter} [type] Filtering by type. All types is default.
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet: async (orderId: number, documentType: OrderNomenclatureTypes, type?: TypeFilter, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet', 'orderId', orderId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet', 'documentType', documentType)
            const localVarPath = `/orders/clients/{order_id}/order-nomenclatures/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the created client order. Only for statuses created by client/manager.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Cancel the created(by client/manager) client order
         * @param {number} orderId 
         * @param {ClientOrderCancellationSchema} clientOrderCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut: async (orderId: number, clientOrderCancellationSchema: ClientOrderCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut', 'orderId', orderId)
            // verify required parameter 'clientOrderCancellationSchema' is not null or undefined
            assertParamExists('clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut', 'clientOrderCancellationSchema', clientOrderCancellationSchema)
            const localVarPath = `/orders/clients/{order_id}/cancel/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientOrderCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client order.  Only for status \"created\", \"is_progress\".  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Update client order
         * @param {number} orderId 
         * @param {ClientOrderUpdateSchema} clientOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersUpdateOneOrdersClientsOrderIdPut: async (orderId: number, clientOrderUpdateSchema: ClientOrderUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('clientOrdersUpdateOneOrdersClientsOrderIdPut', 'orderId', orderId)
            // verify required parameter 'clientOrderUpdateSchema' is not null or undefined
            assertParamExists('clientOrdersUpdateOneOrdersClientsOrderIdPut', 'clientOrderUpdateSchema', clientOrderUpdateSchema)
            const localVarPath = `/orders/clients/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientOrderUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersClientApi - functional programming interface
 * @export
 */
export const OrdersClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new client order.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Create new client order
         * @param {ClientOrderCreateSchema} clientOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersCreateOneOrdersClientsPost(clientOrderCreateSchema: ClientOrderCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersCreateOneOrdersClientsPost(clientOrderCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client order detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_order\'.
         * @summary Get client order detail
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersGetOneOrdersClientsOrderIdGet(orderId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersGetOneOrdersClientsOrderIdGet(orderId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client order list.  Role check: is_staff.  Permission: crm_view_client_order.
         * @summary Get client order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseOrderQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {OrderStatusesQuery} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix) and client(name, phone, email, vatNumber, registrationNumber)
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {string} [agentId] 
         * @param {ClientOrderLabels} [labels] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersListOrdersClientsGet(page?: number, pageSize?: number, order?: BaseOrderQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: OrderStatusesQuery, userId?: string, staffId?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, agentId?: string, labels?: ClientOrderLabels, isCashPayment?: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientOrderPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersListOrdersClientsGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, searchFilter, clientCategoryId, clientType, agentId, labels, isCashPayment, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all orders with a reserve for the nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all orders with a reserve for the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderNomenclatureReservePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet(nomenclatureId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all order nomenclatures with an unused nomenclature quantity
         * @param {number} orderId 
         * @param {OrderNomenclatureTypes} documentType The type of document for which you want to get unused order nomenclatures.
         * @param {TypeFilter} [type] Filtering by type. All types is default.
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet(orderId: number, documentType: OrderNomenclatureTypes, type?: TypeFilter, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientOrderNomenclaturePageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet(orderId, documentType, type, unit, searchFilter, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel the created client order. Only for statuses created by client/manager.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Cancel the created(by client/manager) client order
         * @param {number} orderId 
         * @param {ClientOrderCancellationSchema} clientOrderCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut(orderId: number, clientOrderCancellationSchema: ClientOrderCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut(orderId, clientOrderCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client order.  Only for status \"created\", \"is_progress\".  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Update client order
         * @param {number} orderId 
         * @param {ClientOrderUpdateSchema} clientOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrdersUpdateOneOrdersClientsOrderIdPut(orderId: number, clientOrderUpdateSchema: ClientOrderUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrdersUpdateOneOrdersClientsOrderIdPut(orderId, clientOrderUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersClientApi - factory interface
 * @export
 */
export const OrdersClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersClientApiFp(configuration)
    return {
        /**
         * Create new client order.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Create new client order
         * @param {ClientOrderCreateSchema} clientOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersCreateOneOrdersClientsPost(clientOrderCreateSchema: ClientOrderCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientOrderDetailSchema> {
            return localVarFp.clientOrdersCreateOneOrdersClientsPost(clientOrderCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client order detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_order\'.
         * @summary Get client order detail
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersGetOneOrdersClientsOrderIdGet(orderId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientOrderDetailSchema> {
            return localVarFp.clientOrdersGetOneOrdersClientsOrderIdGet(orderId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client order list.  Role check: is_staff.  Permission: crm_view_client_order.
         * @summary Get client order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseOrderQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {OrderStatusesQuery} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix) and client(name, phone, email, vatNumber, registrationNumber)
         * @param {number} [clientCategoryId] 
         * @param {ClientTypes} [clientType] 
         * @param {string} [agentId] 
         * @param {ClientOrderLabels} [labels] 
         * @param {boolean} [isCashPayment] Filtering by payment kind
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersListOrdersClientsGet(page?: number, pageSize?: number, order?: BaseOrderQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: OrderStatusesQuery, userId?: string, staffId?: string, searchFilter?: string, clientCategoryId?: number, clientType?: ClientTypes, agentId?: string, labels?: ClientOrderLabels, isCashPayment?: boolean, acceptLanguage?: string, options?: any): AxiosPromise<ClientOrderPage> {
            return localVarFp.clientOrdersListOrdersClientsGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, searchFilter, clientCategoryId, clientType, agentId, labels, isCashPayment, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all orders with a reserve for the nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all orders with a reserve for the nomenclature
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<OrderNomenclatureReservePage> {
            return localVarFp.clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet(nomenclatureId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
         * @summary Get all order nomenclatures with an unused nomenclature quantity
         * @param {number} orderId 
         * @param {OrderNomenclatureTypes} documentType The type of document for which you want to get unused order nomenclatures.
         * @param {TypeFilter} [type] Filtering by type. All types is default.
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet(orderId: number, documentType: OrderNomenclatureTypes, type?: TypeFilter, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientOrderNomenclaturePageSchema> {
            return localVarFp.clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet(orderId, documentType, type, unit, searchFilter, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel the created client order. Only for statuses created by client/manager.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Cancel the created(by client/manager) client order
         * @param {number} orderId 
         * @param {ClientOrderCancellationSchema} clientOrderCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut(orderId: number, clientOrderCancellationSchema: ClientOrderCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientOrderDetailSchema> {
            return localVarFp.clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut(orderId, clientOrderCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client order.  Only for status \"created\", \"is_progress\".  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
         * @summary Update client order
         * @param {number} orderId 
         * @param {ClientOrderUpdateSchema} clientOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrdersUpdateOneOrdersClientsOrderIdPut(orderId: number, clientOrderUpdateSchema: ClientOrderUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientOrderDetailSchema> {
            return localVarFp.clientOrdersUpdateOneOrdersClientsOrderIdPut(orderId, clientOrderUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for clientOrdersCreateOneOrdersClientsPost operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersCreateOneOrdersClientsPostRequest
 */
export interface OrdersClientApiClientOrdersCreateOneOrdersClientsPostRequest {
    /**
     * 
     * @type {ClientOrderCreateSchema}
     * @memberof OrdersClientApiClientOrdersCreateOneOrdersClientsPost
     */
    readonly clientOrderCreateSchema: ClientOrderCreateSchema

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersCreateOneOrdersClientsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientOrdersGetOneOrdersClientsOrderIdGet operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersGetOneOrdersClientsOrderIdGetRequest
 */
export interface OrdersClientApiClientOrdersGetOneOrdersClientsOrderIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersGetOneOrdersClientsOrderIdGet
     */
    readonly orderId: number

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersGetOneOrdersClientsOrderIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientOrdersListOrdersClientsGet operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersListOrdersClientsGetRequest
 */
export interface OrdersClientApiClientOrdersListOrdersClientsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseOrderQueryOrder}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly order?: BaseOrderQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly dateCreatedTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {OrderStatusesQuery}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly status?: OrderStatusesQuery

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly staffId?: string

    /**
     * Search by id, documentNumber(year, number, suffix) and client(name, phone, email, vatNumber, registrationNumber)
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly clientCategoryId?: number

    /**
     * 
     * @type {ClientTypes}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientOrderLabels}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly labels?: ClientOrderLabels

    /**
     * Filtering by payment kind
     * @type {boolean}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly isCashPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersListOrdersClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGetRequest
 */
export interface OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGetRequest
 */
export interface OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly orderId: number

    /**
     * The type of document for which you want to get unused order nomenclatures.
     * @type {OrderNomenclatureTypes}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly documentType: OrderNomenclatureTypes

    /**
     * Filtering by type. All types is default.
     * @type {TypeFilter}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly type?: TypeFilter

    /**
     * Filtering by unit. All units is default.
     * @type {UnitFilter}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly unit?: UnitFilter

    /**
     * Search by name or vendor code.
     * @type {string}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPutRequest
 */
export interface OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut
     */
    readonly orderId: number

    /**
     * 
     * @type {ClientOrderCancellationSchema}
     * @memberof OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut
     */
    readonly clientOrderCancellationSchema: ClientOrderCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for clientOrdersUpdateOneOrdersClientsOrderIdPut operation in OrdersClientApi.
 * @export
 * @interface OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPutRequest
 */
export interface OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPut
     */
    readonly orderId: number

    /**
     * 
     * @type {ClientOrderUpdateSchema}
     * @memberof OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPut
     */
    readonly clientOrderUpdateSchema: ClientOrderUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * OrdersClientApi - object-oriented interface
 * @export
 * @class OrdersClientApi
 * @extends {BaseAPI}
 */
export class OrdersClientApi extends BaseAPI {
    /**
     * Create new client order.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
     * @summary Create new client order
     * @param {OrdersClientApiClientOrdersCreateOneOrdersClientsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersCreateOneOrdersClientsPost(requestParameters: OrdersClientApiClientOrdersCreateOneOrdersClientsPostRequest, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersCreateOneOrdersClientsPost(requestParameters.clientOrderCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client order detail.  Role needed: \'is_staff\'.  Permissions needed: \'crm_view_client_order\'.
     * @summary Get client order detail
     * @param {OrdersClientApiClientOrdersGetOneOrdersClientsOrderIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersGetOneOrdersClientsOrderIdGet(requestParameters: OrdersClientApiClientOrdersGetOneOrdersClientsOrderIdGetRequest, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersGetOneOrdersClientsOrderIdGet(requestParameters.orderId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client order list.  Role check: is_staff.  Permission: crm_view_client_order.
     * @summary Get client order list.
     * @param {OrdersClientApiClientOrdersListOrdersClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersListOrdersClientsGet(requestParameters: OrdersClientApiClientOrdersListOrdersClientsGetRequest = {}, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersListOrdersClientsGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.searchFilter, requestParameters.clientCategoryId, requestParameters.clientType, requestParameters.agentId, requestParameters.labels, requestParameters.isCashPayment, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all orders with a reserve for the nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
     * @summary Get all orders with a reserve for the nomenclature
     * @param {OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet(requestParameters: OrdersClientApiClientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGetRequest, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersNomenclatureReserveGetAllOrdersClientsReserveNomenclaturesNomenclatureIdGet(requestParameters.nomenclatureId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: crm_view_client_order.
     * @summary Get all order nomenclatures with an unused nomenclature quantity
     * @param {OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet(requestParameters: OrdersClientApiClientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGetRequest, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersOrderNomenclaturesGetAllOrdersClientsOrderIdOrderNomenclaturesGet(requestParameters.orderId, requestParameters.documentType, requestParameters.type, requestParameters.unit, requestParameters.searchFilter, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel the created client order. Only for statuses created by client/manager.  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
     * @summary Cancel the created(by client/manager) client order
     * @param {OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut(requestParameters: OrdersClientApiClientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPutRequest, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersUpdateOneCancelOrdersClientsOrderIdCancelPut(requestParameters.orderId, requestParameters.clientOrderCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client order.  Only for status \"created\", \"is_progress\".  Perms needed: \'crm_change_client_order\'.  Role needed: \'is_staff\'.
     * @summary Update client order
     * @param {OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersClientApi
     */
    public clientOrdersUpdateOneOrdersClientsOrderIdPut(requestParameters: OrdersClientApiClientOrdersUpdateOneOrdersClientsOrderIdPutRequest, options?: AxiosRequestConfig) {
        return OrdersClientApiFp(this.configuration).clientOrdersUpdateOneOrdersClientsOrderIdPut(requestParameters.orderId, requestParameters.clientOrderUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersSupplierApi - axios parameter creator
 * @export
 */
export const OrdersSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Supplier order.  New supplier order can be linked to a client order(only in status \"created\" or \"is_progress\").  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier order
         * @param {SupplierOrderCreateSchema} supplierOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersCreateOneOrdersSuppliersPost: async (supplierOrderCreateSchema: SupplierOrderCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierOrderCreateSchema' is not null or undefined
            assertParamExists('supplierOrdersCreateOneOrdersSuppliersPost', 'supplierOrderCreateSchema', supplierOrderCreateSchema)
            const localVarPath = `/orders/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierOrderCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all orders that contain the expected nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
         * @summary Get all orders that contain the expected nomenclature
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet: async (nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureId' is not null or undefined
            assertParamExists('supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet', 'nomenclatureId', nomenclatureId)
            const localVarPath = `/orders/suppliers/expected/nomenclatures/{nomenclature_id}/`
                .replace(`{${"nomenclature_id"}}`, encodeURIComponent(String(nomenclatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier order detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_order\'.
         * @summary Get supplier order detail
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersGetOneOrdersSuppliersOrderIdGet: async (orderId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('supplierOrdersGetOneOrdersSuppliersOrderIdGet', 'orderId', orderId)
            const localVarPath = `/orders/suppliers/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier order list.  Role check: is_staff.  Permission: warehouse_view_supplier_order.
         * @summary Get supplier order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseOrderQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {OrderStatusesQuery} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix) and supplier(name, phone, email, vatNumber, registrationNumber)
         * @param {number} [supplierCategoryId] 
         * @param {SupplierOrderLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersListOrdersSuppliersGet: async (page?: number, pageSize?: number, order?: BaseOrderQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: OrderStatusesQuery, userId?: string, staffId?: string, searchFilter?: string, supplierCategoryId?: number, labels?: SupplierOrderLabels, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
         * @summary Get all order nomenclatures with an unused nomenclature quantity
         * @param {number} orderId 
         * @param {OrderNomenclatureTypes} documentType The type of document for which you want to get unused order nomenclatures.
         * @param {TypeFilter} [type] Filtering by type. All types is default.
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet: async (orderId: number, documentType: OrderNomenclatureTypes, type?: TypeFilter, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet', 'orderId', orderId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet', 'documentType', documentType)
            const localVarPath = `/orders/suppliers/{order_id}/order-nomenclatures/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the created supplier order. Only for created status.  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Cancel the created supplier order
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut: async (orderId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut', 'orderId', orderId)
            const localVarPath = `/orders/suppliers/{order_id}/cancel/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update supplier order.  Only for status \"created\", \"is_progress\".  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Update supplier order
         * @param {number} orderId 
         * @param {SupplierOrderUpdateSchema} supplierOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersUpdateOneOrdersSuppliersOrderIdPut: async (orderId: number, supplierOrderUpdateSchema: SupplierOrderUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('supplierOrdersUpdateOneOrdersSuppliersOrderIdPut', 'orderId', orderId)
            // verify required parameter 'supplierOrderUpdateSchema' is not null or undefined
            assertParamExists('supplierOrdersUpdateOneOrdersSuppliersOrderIdPut', 'supplierOrderUpdateSchema', supplierOrderUpdateSchema)
            const localVarPath = `/orders/suppliers/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierOrderUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersSupplierApi - functional programming interface
 * @export
 */
export const OrdersSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Supplier order.  New supplier order can be linked to a client order(only in status \"created\" or \"is_progress\").  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier order
         * @param {SupplierOrderCreateSchema} supplierOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersCreateOneOrdersSuppliersPost(supplierOrderCreateSchema: SupplierOrderCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersCreateOneOrdersSuppliersPost(supplierOrderCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all orders that contain the expected nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
         * @summary Get all orders that contain the expected nomenclature
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderExpectedNomenclaturePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet(nomenclatureId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier order detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_order\'.
         * @summary Get supplier order detail
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersGetOneOrdersSuppliersOrderIdGet(orderId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersGetOneOrdersSuppliersOrderIdGet(orderId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier order list.  Role check: is_staff.  Permission: warehouse_view_supplier_order.
         * @summary Get supplier order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseOrderQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {OrderStatusesQuery} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix) and supplier(name, phone, email, vatNumber, registrationNumber)
         * @param {number} [supplierCategoryId] 
         * @param {SupplierOrderLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersListOrdersSuppliersGet(page?: number, pageSize?: number, order?: BaseOrderQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: OrderStatusesQuery, userId?: string, staffId?: string, searchFilter?: string, supplierCategoryId?: number, labels?: SupplierOrderLabels, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierOrderPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersListOrdersSuppliersGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, searchFilter, supplierCategoryId, labels, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
         * @summary Get all order nomenclatures with an unused nomenclature quantity
         * @param {number} orderId 
         * @param {OrderNomenclatureTypes} documentType The type of document for which you want to get unused order nomenclatures.
         * @param {TypeFilter} [type] Filtering by type. All types is default.
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet(orderId: number, documentType: OrderNomenclatureTypes, type?: TypeFilter, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierOrderNomenclaturePageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet(orderId, documentType, type, unit, searchFilter, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel the created supplier order. Only for created status.  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Cancel the created supplier order
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut(orderId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut(orderId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update supplier order.  Only for status \"created\", \"is_progress\".  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Update supplier order
         * @param {number} orderId 
         * @param {SupplierOrderUpdateSchema} supplierOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierOrdersUpdateOneOrdersSuppliersOrderIdPut(orderId: number, supplierOrderUpdateSchema: SupplierOrderUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierOrdersUpdateOneOrdersSuppliersOrderIdPut(orderId, supplierOrderUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersSupplierApi - factory interface
 * @export
 */
export const OrdersSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersSupplierApiFp(configuration)
    return {
        /**
         * Create new Supplier order.  New supplier order can be linked to a client order(only in status \"created\" or \"is_progress\").  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Create new supplier order
         * @param {SupplierOrderCreateSchema} supplierOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersCreateOneOrdersSuppliersPost(supplierOrderCreateSchema: SupplierOrderCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierOrderDetailSchema> {
            return localVarFp.supplierOrdersCreateOneOrdersSuppliersPost(supplierOrderCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all orders that contain the expected nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
         * @summary Get all orders that contain the expected nomenclature
         * @param {number} nomenclatureId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet(nomenclatureId: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<OrderExpectedNomenclaturePage> {
            return localVarFp.supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet(nomenclatureId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier order detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_order\'.
         * @summary Get supplier order detail
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersGetOneOrdersSuppliersOrderIdGet(orderId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierOrderDetailSchema> {
            return localVarFp.supplierOrdersGetOneOrdersSuppliersOrderIdGet(orderId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier order list.  Role check: is_staff.  Permission: warehouse_view_supplier_order.
         * @summary Get supplier order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {BaseOrderQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [countryId] 
         * @param {number} [currencyId] 
         * @param {string} [creatorId] 
         * @param {string} [responsibleId] 
         * @param {OrderStatusesQuery} [status] 
         * @param {string} [userId] Filter by client/supplier ID.
         * @param {string} [staffId] Filter by staff ID.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix) and supplier(name, phone, email, vatNumber, registrationNumber)
         * @param {number} [supplierCategoryId] 
         * @param {SupplierOrderLabels} [labels] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersListOrdersSuppliersGet(page?: number, pageSize?: number, order?: BaseOrderQueryOrder, sort?: BaseSort, dateCreatedFrom?: string, dateCreatedTo?: string, counterAgentKind?: CounterAgentKinds, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, status?: OrderStatusesQuery, userId?: string, staffId?: string, searchFilter?: string, supplierCategoryId?: number, labels?: SupplierOrderLabels, acceptLanguage?: string, options?: any): AxiosPromise<SupplierOrderPage> {
            return localVarFp.supplierOrdersListOrdersSuppliersGet(page, pageSize, order, sort, dateCreatedFrom, dateCreatedTo, counterAgentKind, countryId, currencyId, creatorId, responsibleId, status, userId, staffId, searchFilter, supplierCategoryId, labels, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
         * @summary Get all order nomenclatures with an unused nomenclature quantity
         * @param {number} orderId 
         * @param {OrderNomenclatureTypes} documentType The type of document for which you want to get unused order nomenclatures.
         * @param {TypeFilter} [type] Filtering by type. All types is default.
         * @param {UnitFilter} [unit] Filtering by unit. All units is default.
         * @param {string} [searchFilter] Search by name or vendor code.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet(orderId: number, documentType: OrderNomenclatureTypes, type?: TypeFilter, unit?: UnitFilter, searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierOrderNomenclaturePageSchema> {
            return localVarFp.supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet(orderId, documentType, type, unit, searchFilter, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel the created supplier order. Only for created status.  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Cancel the created supplier order
         * @param {number} orderId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut(orderId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierOrderDetailSchema> {
            return localVarFp.supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut(orderId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update supplier order.  Only for status \"created\", \"is_progress\".  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
         * @summary Update supplier order
         * @param {number} orderId 
         * @param {SupplierOrderUpdateSchema} supplierOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierOrdersUpdateOneOrdersSuppliersOrderIdPut(orderId: number, supplierOrderUpdateSchema: SupplierOrderUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierOrderDetailSchema> {
            return localVarFp.supplierOrdersUpdateOneOrdersSuppliersOrderIdPut(orderId, supplierOrderUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for supplierOrdersCreateOneOrdersSuppliersPost operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersCreateOneOrdersSuppliersPostRequest
 */
export interface OrdersSupplierApiSupplierOrdersCreateOneOrdersSuppliersPostRequest {
    /**
     * 
     * @type {SupplierOrderCreateSchema}
     * @memberof OrdersSupplierApiSupplierOrdersCreateOneOrdersSuppliersPost
     */
    readonly supplierOrderCreateSchema: SupplierOrderCreateSchema

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersCreateOneOrdersSuppliersPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGetRequest
 */
export interface OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet
     */
    readonly nomenclatureId: number

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierOrdersGetOneOrdersSuppliersOrderIdGet operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersGetOneOrdersSuppliersOrderIdGetRequest
 */
export interface OrdersSupplierApiSupplierOrdersGetOneOrdersSuppliersOrderIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersGetOneOrdersSuppliersOrderIdGet
     */
    readonly orderId: number

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersGetOneOrdersSuppliersOrderIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierOrdersListOrdersSuppliersGet operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersListOrdersSuppliersGetRequest
 */
export interface OrdersSupplierApiSupplierOrdersListOrdersSuppliersGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {BaseOrderQueryOrder}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly order?: BaseOrderQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly sort?: BaseSort

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly dateCreatedTo?: string

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly responsibleId?: string

    /**
     * 
     * @type {OrderStatusesQuery}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly status?: OrderStatusesQuery

    /**
     * Filter by client/supplier ID.
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly userId?: string

    /**
     * Filter by staff ID.
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly staffId?: string

    /**
     * Search by id, documentNumber(year, number, suffix) and supplier(name, phone, email, vatNumber, registrationNumber)
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierOrderLabels}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly labels?: SupplierOrderLabels

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersListOrdersSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGetRequest
 */
export interface OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly orderId: number

    /**
     * The type of document for which you want to get unused order nomenclatures.
     * @type {OrderNomenclatureTypes}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly documentType: OrderNomenclatureTypes

    /**
     * Filtering by type. All types is default.
     * @type {TypeFilter}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly type?: TypeFilter

    /**
     * Filtering by unit. All units is default.
     * @type {UnitFilter}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly unit?: UnitFilter

    /**
     * Search by name or vendor code.
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPutRequest
 */
export interface OrdersSupplierApiSupplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut
     */
    readonly orderId: number

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierOrdersUpdateOneOrdersSuppliersOrderIdPut operation in OrdersSupplierApi.
 * @export
 * @interface OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPutRequest
 */
export interface OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPut
     */
    readonly orderId: number

    /**
     * 
     * @type {SupplierOrderUpdateSchema}
     * @memberof OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPut
     */
    readonly supplierOrderUpdateSchema: SupplierOrderUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * OrdersSupplierApi - object-oriented interface
 * @export
 * @class OrdersSupplierApi
 * @extends {BaseAPI}
 */
export class OrdersSupplierApi extends BaseAPI {
    /**
     * Create new Supplier order.  New supplier order can be linked to a client order(only in status \"created\" or \"is_progress\").  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
     * @summary Create new supplier order
     * @param {OrdersSupplierApiSupplierOrdersCreateOneOrdersSuppliersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersCreateOneOrdersSuppliersPost(requestParameters: OrdersSupplierApiSupplierOrdersCreateOneOrdersSuppliersPostRequest, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersCreateOneOrdersSuppliersPost(requestParameters.supplierOrderCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all orders that contain the expected nomenclature.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
     * @summary Get all orders that contain the expected nomenclature
     * @param {OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet(requestParameters: OrdersSupplierApiSupplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGetRequest, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersExpectedNomenclatureGetAllOrdersSuppliersExpectedNomenclaturesNomenclatureIdGet(requestParameters.nomenclatureId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier order detail.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_supplier_order\'.
     * @summary Get supplier order detail
     * @param {OrdersSupplierApiSupplierOrdersGetOneOrdersSuppliersOrderIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersGetOneOrdersSuppliersOrderIdGet(requestParameters: OrdersSupplierApiSupplierOrdersGetOneOrdersSuppliersOrderIdGetRequest, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersGetOneOrdersSuppliersOrderIdGet(requestParameters.orderId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier order list.  Role check: is_staff.  Permission: warehouse_view_supplier_order.
     * @summary Get supplier order list.
     * @param {OrdersSupplierApiSupplierOrdersListOrdersSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersListOrdersSuppliersGet(requestParameters: OrdersSupplierApiSupplierOrdersListOrdersSuppliersGetRequest = {}, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersListOrdersSuppliersGet(requestParameters.page, requestParameters.pageSize, requestParameters.order, requestParameters.sort, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.counterAgentKind, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.searchFilter, requestParameters.supplierCategoryId, requestParameters.labels, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all order nomenclatures with an unused nomenclature quantity.  Select the type of document to receive needed unused order nomenclatures.  Pagination is used.  Role needed: \'is_staff\'.  Permission: warehouse_view_supplier_order.
     * @summary Get all order nomenclatures with an unused nomenclature quantity
     * @param {OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet(requestParameters: OrdersSupplierApiSupplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGetRequest, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersOrderNomenclaturesGetAllOrdersSuppliersOrderIdOrderNomenclaturesGet(requestParameters.orderId, requestParameters.documentType, requestParameters.type, requestParameters.unit, requestParameters.searchFilter, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel the created supplier order. Only for created status.  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
     * @summary Cancel the created supplier order
     * @param {OrdersSupplierApiSupplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut(requestParameters: OrdersSupplierApiSupplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPutRequest, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersUpdateOneCancelOrdersSuppliersOrderIdCancelPut(requestParameters.orderId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update supplier order.  Only for status \"created\", \"is_progress\".  Perms needed: \'warehouse_change_supplier_order\'.  Role needed: \'is_staff\'.
     * @summary Update supplier order
     * @param {OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersSupplierApi
     */
    public supplierOrdersUpdateOneOrdersSuppliersOrderIdPut(requestParameters: OrdersSupplierApiSupplierOrdersUpdateOneOrdersSuppliersOrderIdPutRequest, options?: AxiosRequestConfig) {
        return OrdersSupplierApiFp(this.configuration).supplierOrdersUpdateOneOrdersSuppliersOrderIdPut(requestParameters.orderId, requestParameters.supplierOrderUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentOrdersApi - axios parameter creator
 * @export
 */
export const PaymentOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new payment.  Choose document type for create payment order or cash order.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Create new payment
         * @param {PaymentOrderCreateSchema} paymentOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersCreateOnePaymentOrdersPost: async (paymentOrderCreateSchema: PaymentOrderCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentOrderCreateSchema' is not null or undefined
            assertParamExists('paymentOrdersCreateOnePaymentOrdersPost', 'paymentOrderCreateSchema', paymentOrderCreateSchema)
            const localVarPath = `/payment-orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentOrderCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete payment order.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Delete payment order
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete: async (paymentOrderId: number, documentType: PaymentOrderDocumentTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentOrderId' is not null or undefined
            assertParamExists('paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete', 'paymentOrderId', paymentOrderId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete', 'documentType', documentType)
            const localVarPath = `/payment-orders/{payment_order_id}/`
                .replace(`{${"payment_order_id"}}`, encodeURIComponent(String(paymentOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment order or cash order detail.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
         * @summary Get payment order detail
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet: async (paymentOrderId: number, documentType: PaymentOrderDocumentTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentOrderId' is not null or undefined
            assertParamExists('paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet', 'paymentOrderId', paymentOrderId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet', 'documentType', documentType)
            const localVarPath = `/payment-orders/{payment_order_id}/`
                .replace(`{${"payment_order_id"}}`, encodeURIComponent(String(paymentOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment order list(All payment orders).  Use filter params for filter payment order list by bank account or cashbox.  Get info about bank accounts or cashboxes for page - /settings/bank-accounts-and-cashboxes/payment-orders/.  Role check: is_staff.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
         * @summary Get all payment order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateOperationFrom] Date range. Filtering by date operation. Date operation from.
         * @param {string} [dateOperationTo] Date range. Filtering by date operation. Date operation to.
         * @param {Array<PaymentOrderDocumentTypes>} [documentTypes] Filtering by document type.
         * @param {Array<number>} [currencyIds] Filtering by currencies.
         * @param {Array<number>} [finItemIds] Filtering by financial analysis item.
         * @param {Array<string>} [creatorIds] Filtering by creator.
         * @param {PaymentOrderStatuses} [status] Filtering by status.
         * @param {string} [searchFilter] Search by documentNumber, contragent(name, vatNumber, registrationNumber), accountCashbox(name, placeName) and base documents
         * @param {Array<PaymentOrderTypes>} [paymentTypes] Filtering by payment types.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersListPaymentOrdersGet: async (page?: number, pageSize?: number, dateOperationFrom?: string, dateOperationTo?: string, documentTypes?: Array<PaymentOrderDocumentTypes>, currencyIds?: Array<number>, finItemIds?: Array<number>, creatorIds?: Array<string>, status?: PaymentOrderStatuses, searchFilter?: string, paymentTypes?: Array<PaymentOrderTypes>, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateOperationFrom !== undefined) {
                localVarQueryParameter['dateOperationFrom'] = (dateOperationFrom as any instanceof Date) ?
                    (dateOperationFrom as any).toISOString().substr(0,10) :
                    dateOperationFrom;
            }

            if (dateOperationTo !== undefined) {
                localVarQueryParameter['dateOperationTo'] = (dateOperationTo as any instanceof Date) ?
                    (dateOperationTo as any).toISOString().substr(0,10) :
                    dateOperationTo;
            }

            if (documentTypes) {
                localVarQueryParameter['documentTypes'] = documentTypes;
            }

            if (currencyIds) {
                localVarQueryParameter['currencyIds'] = currencyIds;
            }

            if (finItemIds) {
                localVarQueryParameter['finItemIds'] = finItemIds;
            }

            if (creatorIds) {
                localVarQueryParameter['creatorIds'] = creatorIds;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (paymentTypes) {
                localVarQueryParameter['paymentTypes'] = paymentTypes;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\") | Client (\"crm_view_clients\") | Supplier (\"warehouse_view_suppliers\").
         * @summary Get all payment orders for selected object.
         * @param {ObjectId} objectId 
         * @param {PaymentOrderObjectTypes} objectType Filtering by object type.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateOperationFrom] Date range. Filtering by date operation. Date operation from.
         * @param {string} [dateOperationTo] Date range. Filtering by date operation. Date operation to.
         * @param {Array<PaymentOrderDocumentTypes>} [documentTypes] Filtering by document type.
         * @param {Array<number>} [currencyIds] Filtering by currencies.
         * @param {Array<number>} [finItemIds] Filtering by financial analysis item.
         * @param {Array<string>} [creatorIds] Filtering by creator.
         * @param {PaymentOrderStatuses} [status] Filtering by status.
         * @param {string} [searchFilter] Search by documentNumber, accountCashbox(name, placeName) and base documents
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersSublistPaymentOrdersSublistObjectIdGet: async (objectId: ObjectId, objectType: PaymentOrderObjectTypes, page?: number, pageSize?: number, dateOperationFrom?: string, dateOperationTo?: string, documentTypes?: Array<PaymentOrderDocumentTypes>, currencyIds?: Array<number>, finItemIds?: Array<number>, creatorIds?: Array<string>, status?: PaymentOrderStatuses, searchFilter?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('paymentOrdersSublistPaymentOrdersSublistObjectIdGet', 'objectId', objectId)
            // verify required parameter 'objectType' is not null or undefined
            assertParamExists('paymentOrdersSublistPaymentOrdersSublistObjectIdGet', 'objectType', objectType)
            const localVarPath = `/payment-orders/sublist/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateOperationFrom !== undefined) {
                localVarQueryParameter['dateOperationFrom'] = (dateOperationFrom as any instanceof Date) ?
                    (dateOperationFrom as any).toISOString().substr(0,10) :
                    dateOperationFrom;
            }

            if (dateOperationTo !== undefined) {
                localVarQueryParameter['dateOperationTo'] = (dateOperationTo as any instanceof Date) ?
                    (dateOperationTo as any).toISOString().substr(0,10) :
                    dateOperationTo;
            }

            if (documentTypes) {
                localVarQueryParameter['documentTypes'] = documentTypes;
            }

            if (currencyIds) {
                localVarQueryParameter['currencyIds'] = currencyIds;
            }

            if (finItemIds) {
                localVarQueryParameter['finItemIds'] = finItemIds;
            }

            if (creatorIds) {
                localVarQueryParameter['creatorIds'] = creatorIds;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change payment status to \"created\". Only for payments with \"conducted\" status.  Use query params to choose needed document.   Role needed: \'is_staff\'.  Permissions needed: \'finance_cancel_incoming_payment_order\' | \'finance_cancel_outgoing_payment_order\' | \'finance_cancel_incoming_cash_order\' | \'finance_cancel_outgoing_cash_order\'.
         * @summary Change payment order status to created
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {PaymentOrderCancellationSchema} paymentOrderCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut: async (paymentOrderId: number, documentType: PaymentOrderDocumentTypes, paymentOrderCancellationSchema: PaymentOrderCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentOrderId' is not null or undefined
            assertParamExists('paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut', 'paymentOrderId', paymentOrderId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut', 'documentType', documentType)
            // verify required parameter 'paymentOrderCancellationSchema' is not null or undefined
            assertParamExists('paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut', 'paymentOrderCancellationSchema', paymentOrderCancellationSchema)
            const localVarPath = `/payment-orders/{payment_order_id}/cancel/`
                .replace(`{${"payment_order_id"}}`, encodeURIComponent(String(paymentOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentOrderCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update payment order.  Use query params to choose needed document. Only for status \"created\".  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Update payment order
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {PaymentOrderUpdateSchema} paymentOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut: async (paymentOrderId: number, documentType: PaymentOrderDocumentTypes, paymentOrderUpdateSchema: PaymentOrderUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentOrderId' is not null or undefined
            assertParamExists('paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut', 'paymentOrderId', paymentOrderId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut', 'documentType', documentType)
            // verify required parameter 'paymentOrderUpdateSchema' is not null or undefined
            assertParamExists('paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut', 'paymentOrderUpdateSchema', paymentOrderUpdateSchema)
            const localVarPath = `/payment-orders/{payment_order_id}/`
                .replace(`{${"payment_order_id"}}`, encodeURIComponent(String(paymentOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentOrderUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentOrdersApi - functional programming interface
 * @export
 */
export const PaymentOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new payment.  Choose document type for create payment order or cash order.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Create new payment
         * @param {PaymentOrderCreateSchema} paymentOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersCreateOnePaymentOrdersPost(paymentOrderCreateSchema: PaymentOrderCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersCreateOnePaymentOrdersPost(paymentOrderCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete payment order.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Delete payment order
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete(paymentOrderId, documentType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get payment order or cash order detail.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
         * @summary Get payment order detail
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet(paymentOrderId, documentType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get payment order list(All payment orders).  Use filter params for filter payment order list by bank account or cashbox.  Get info about bank accounts or cashboxes for page - /settings/bank-accounts-and-cashboxes/payment-orders/.  Role check: is_staff.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
         * @summary Get all payment order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateOperationFrom] Date range. Filtering by date operation. Date operation from.
         * @param {string} [dateOperationTo] Date range. Filtering by date operation. Date operation to.
         * @param {Array<PaymentOrderDocumentTypes>} [documentTypes] Filtering by document type.
         * @param {Array<number>} [currencyIds] Filtering by currencies.
         * @param {Array<number>} [finItemIds] Filtering by financial analysis item.
         * @param {Array<string>} [creatorIds] Filtering by creator.
         * @param {PaymentOrderStatuses} [status] Filtering by status.
         * @param {string} [searchFilter] Search by documentNumber, contragent(name, vatNumber, registrationNumber), accountCashbox(name, placeName) and base documents
         * @param {Array<PaymentOrderTypes>} [paymentTypes] Filtering by payment types.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersListPaymentOrdersGet(page?: number, pageSize?: number, dateOperationFrom?: string, dateOperationTo?: string, documentTypes?: Array<PaymentOrderDocumentTypes>, currencyIds?: Array<number>, finItemIds?: Array<number>, creatorIds?: Array<string>, status?: PaymentOrderStatuses, searchFilter?: string, paymentTypes?: Array<PaymentOrderTypes>, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentOrderPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersListPaymentOrdersGet(page, pageSize, dateOperationFrom, dateOperationTo, documentTypes, currencyIds, finItemIds, creatorIds, status, searchFilter, paymentTypes, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\") | Client (\"crm_view_clients\") | Supplier (\"warehouse_view_suppliers\").
         * @summary Get all payment orders for selected object.
         * @param {ObjectId} objectId 
         * @param {PaymentOrderObjectTypes} objectType Filtering by object type.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateOperationFrom] Date range. Filtering by date operation. Date operation from.
         * @param {string} [dateOperationTo] Date range. Filtering by date operation. Date operation to.
         * @param {Array<PaymentOrderDocumentTypes>} [documentTypes] Filtering by document type.
         * @param {Array<number>} [currencyIds] Filtering by currencies.
         * @param {Array<number>} [finItemIds] Filtering by financial analysis item.
         * @param {Array<string>} [creatorIds] Filtering by creator.
         * @param {PaymentOrderStatuses} [status] Filtering by status.
         * @param {string} [searchFilter] Search by documentNumber, accountCashbox(name, placeName) and base documents
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersSublistPaymentOrdersSublistObjectIdGet(objectId: ObjectId, objectType: PaymentOrderObjectTypes, page?: number, pageSize?: number, dateOperationFrom?: string, dateOperationTo?: string, documentTypes?: Array<PaymentOrderDocumentTypes>, currencyIds?: Array<number>, finItemIds?: Array<number>, creatorIds?: Array<string>, status?: PaymentOrderStatuses, searchFilter?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentOrderSublistPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersSublistPaymentOrdersSublistObjectIdGet(objectId, objectType, page, pageSize, dateOperationFrom, dateOperationTo, documentTypes, currencyIds, finItemIds, creatorIds, status, searchFilter, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change payment status to \"created\". Only for payments with \"conducted\" status.  Use query params to choose needed document.   Role needed: \'is_staff\'.  Permissions needed: \'finance_cancel_incoming_payment_order\' | \'finance_cancel_outgoing_payment_order\' | \'finance_cancel_incoming_cash_order\' | \'finance_cancel_outgoing_cash_order\'.
         * @summary Change payment order status to created
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {PaymentOrderCancellationSchema} paymentOrderCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, paymentOrderCancellationSchema: PaymentOrderCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut(paymentOrderId, documentType, paymentOrderCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update payment order.  Use query params to choose needed document. Only for status \"created\".  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Update payment order
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {PaymentOrderUpdateSchema} paymentOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, paymentOrderUpdateSchema: PaymentOrderUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentOrderDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut(paymentOrderId, documentType, paymentOrderUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentOrdersApi - factory interface
 * @export
 */
export const PaymentOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentOrdersApiFp(configuration)
    return {
        /**
         * Create new payment.  Choose document type for create payment order or cash order.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Create new payment
         * @param {PaymentOrderCreateSchema} paymentOrderCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersCreateOnePaymentOrdersPost(paymentOrderCreateSchema: PaymentOrderCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<PaymentOrderDetailSchema> {
            return localVarFp.paymentOrdersCreateOnePaymentOrdersPost(paymentOrderCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete payment order.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Delete payment order
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete(paymentOrderId, documentType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment order or cash order detail.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
         * @summary Get payment order detail
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, acceptLanguage?: string, options?: any): AxiosPromise<PaymentOrderDetailSchema> {
            return localVarFp.paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet(paymentOrderId, documentType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment order list(All payment orders).  Use filter params for filter payment order list by bank account or cashbox.  Get info about bank accounts or cashboxes for page - /settings/bank-accounts-and-cashboxes/payment-orders/.  Role check: is_staff.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
         * @summary Get all payment order list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateOperationFrom] Date range. Filtering by date operation. Date operation from.
         * @param {string} [dateOperationTo] Date range. Filtering by date operation. Date operation to.
         * @param {Array<PaymentOrderDocumentTypes>} [documentTypes] Filtering by document type.
         * @param {Array<number>} [currencyIds] Filtering by currencies.
         * @param {Array<number>} [finItemIds] Filtering by financial analysis item.
         * @param {Array<string>} [creatorIds] Filtering by creator.
         * @param {PaymentOrderStatuses} [status] Filtering by status.
         * @param {string} [searchFilter] Search by documentNumber, contragent(name, vatNumber, registrationNumber), accountCashbox(name, placeName) and base documents
         * @param {Array<PaymentOrderTypes>} [paymentTypes] Filtering by payment types.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersListPaymentOrdersGet(page?: number, pageSize?: number, dateOperationFrom?: string, dateOperationTo?: string, documentTypes?: Array<PaymentOrderDocumentTypes>, currencyIds?: Array<number>, finItemIds?: Array<number>, creatorIds?: Array<string>, status?: PaymentOrderStatuses, searchFilter?: string, paymentTypes?: Array<PaymentOrderTypes>, acceptLanguage?: string, options?: any): AxiosPromise<PaymentOrderPage> {
            return localVarFp.paymentOrdersListPaymentOrdersGet(page, pageSize, dateOperationFrom, dateOperationTo, documentTypes, currencyIds, finItemIds, creatorIds, status, searchFilter, paymentTypes, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\") | Client (\"crm_view_clients\") | Supplier (\"warehouse_view_suppliers\").
         * @summary Get all payment orders for selected object.
         * @param {ObjectId} objectId 
         * @param {PaymentOrderObjectTypes} objectType Filtering by object type.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateOperationFrom] Date range. Filtering by date operation. Date operation from.
         * @param {string} [dateOperationTo] Date range. Filtering by date operation. Date operation to.
         * @param {Array<PaymentOrderDocumentTypes>} [documentTypes] Filtering by document type.
         * @param {Array<number>} [currencyIds] Filtering by currencies.
         * @param {Array<number>} [finItemIds] Filtering by financial analysis item.
         * @param {Array<string>} [creatorIds] Filtering by creator.
         * @param {PaymentOrderStatuses} [status] Filtering by status.
         * @param {string} [searchFilter] Search by documentNumber, accountCashbox(name, placeName) and base documents
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersSublistPaymentOrdersSublistObjectIdGet(objectId: ObjectId, objectType: PaymentOrderObjectTypes, page?: number, pageSize?: number, dateOperationFrom?: string, dateOperationTo?: string, documentTypes?: Array<PaymentOrderDocumentTypes>, currencyIds?: Array<number>, finItemIds?: Array<number>, creatorIds?: Array<string>, status?: PaymentOrderStatuses, searchFilter?: string, acceptLanguage?: string, options?: any): AxiosPromise<PaymentOrderSublistPage> {
            return localVarFp.paymentOrdersSublistPaymentOrdersSublistObjectIdGet(objectId, objectType, page, pageSize, dateOperationFrom, dateOperationTo, documentTypes, currencyIds, finItemIds, creatorIds, status, searchFilter, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change payment status to \"created\". Only for payments with \"conducted\" status.  Use query params to choose needed document.   Role needed: \'is_staff\'.  Permissions needed: \'finance_cancel_incoming_payment_order\' | \'finance_cancel_outgoing_payment_order\' | \'finance_cancel_incoming_cash_order\' | \'finance_cancel_outgoing_cash_order\'.
         * @summary Change payment order status to created
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {PaymentOrderCancellationSchema} paymentOrderCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, paymentOrderCancellationSchema: PaymentOrderCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<PaymentOrderDetailSchema> {
            return localVarFp.paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut(paymentOrderId, documentType, paymentOrderCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update payment order.  Use query params to choose needed document. Only for status \"created\".  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
         * @summary Update payment order
         * @param {number} paymentOrderId 
         * @param {PaymentOrderDocumentTypes} documentType Filtering by document.
         * @param {PaymentOrderUpdateSchema} paymentOrderUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut(paymentOrderId: number, documentType: PaymentOrderDocumentTypes, paymentOrderUpdateSchema: PaymentOrderUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<PaymentOrderDetailSchema> {
            return localVarFp.paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut(paymentOrderId, documentType, paymentOrderUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentOrdersCreateOnePaymentOrdersPost operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersCreateOnePaymentOrdersPostRequest
 */
export interface PaymentOrdersApiPaymentOrdersCreateOnePaymentOrdersPostRequest {
    /**
     * 
     * @type {PaymentOrderCreateSchema}
     * @memberof PaymentOrdersApiPaymentOrdersCreateOnePaymentOrdersPost
     */
    readonly paymentOrderCreateSchema: PaymentOrderCreateSchema

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersCreateOnePaymentOrdersPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDeleteRequest
 */
export interface PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete
     */
    readonly paymentOrderId: number

    /**
     * Filtering by document.
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete
     */
    readonly documentType: PaymentOrderDocumentTypes

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGetRequest
 */
export interface PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGet
     */
    readonly paymentOrderId: number

    /**
     * Filtering by document.
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGet
     */
    readonly documentType: PaymentOrderDocumentTypes

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for paymentOrdersListPaymentOrdersGet operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersListPaymentOrdersGetRequest
 */
export interface PaymentOrdersApiPaymentOrdersListPaymentOrdersGetRequest {
    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly pageSize?: number

    /**
     * Date range. Filtering by date operation. Date operation from.
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly dateOperationFrom?: string

    /**
     * Date range. Filtering by date operation. Date operation to.
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly dateOperationTo?: string

    /**
     * Filtering by document type.
     * @type {Array<PaymentOrderDocumentTypes>}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly documentTypes?: Array<PaymentOrderDocumentTypes>

    /**
     * Filtering by currencies.
     * @type {Array<number>}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly currencyIds?: Array<number>

    /**
     * Filtering by financial analysis item.
     * @type {Array<number>}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly finItemIds?: Array<number>

    /**
     * Filtering by creator.
     * @type {Array<string>}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly creatorIds?: Array<string>

    /**
     * Filtering by status.
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly status?: PaymentOrderStatuses

    /**
     * Search by documentNumber, contragent(name, vatNumber, registrationNumber), accountCashbox(name, placeName) and base documents
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by payment types.
     * @type {Array<PaymentOrderTypes>}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly paymentTypes?: Array<PaymentOrderTypes>

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersListPaymentOrdersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for paymentOrdersSublistPaymentOrdersSublistObjectIdGet operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGetRequest
 */
export interface PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGetRequest {
    /**
     * 
     * @type {ObjectId}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly objectId: ObjectId

    /**
     * Filtering by object type.
     * @type {PaymentOrderObjectTypes}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly objectType: PaymentOrderObjectTypes

    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly pageSize?: number

    /**
     * Date range. Filtering by date operation. Date operation from.
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly dateOperationFrom?: string

    /**
     * Date range. Filtering by date operation. Date operation to.
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly dateOperationTo?: string

    /**
     * Filtering by document type.
     * @type {Array<PaymentOrderDocumentTypes>}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly documentTypes?: Array<PaymentOrderDocumentTypes>

    /**
     * Filtering by currencies.
     * @type {Array<number>}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly currencyIds?: Array<number>

    /**
     * Filtering by financial analysis item.
     * @type {Array<number>}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly finItemIds?: Array<number>

    /**
     * Filtering by creator.
     * @type {Array<string>}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly creatorIds?: Array<string>

    /**
     * Filtering by status.
     * @type {PaymentOrderStatuses}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly status?: PaymentOrderStatuses

    /**
     * Search by documentNumber, accountCashbox(name, placeName) and base documents
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPutRequest
 */
export interface PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut
     */
    readonly paymentOrderId: number

    /**
     * Filtering by document.
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut
     */
    readonly documentType: PaymentOrderDocumentTypes

    /**
     * 
     * @type {PaymentOrderCancellationSchema}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut
     */
    readonly paymentOrderCancellationSchema: PaymentOrderCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut operation in PaymentOrdersApi.
 * @export
 * @interface PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPutRequest
 */
export interface PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut
     */
    readonly paymentOrderId: number

    /**
     * Filtering by document.
     * @type {PaymentOrderDocumentTypes}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut
     */
    readonly documentType: PaymentOrderDocumentTypes

    /**
     * 
     * @type {PaymentOrderUpdateSchema}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut
     */
    readonly paymentOrderUpdateSchema: PaymentOrderUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * PaymentOrdersApi - object-oriented interface
 * @export
 * @class PaymentOrdersApi
 * @extends {BaseAPI}
 */
export class PaymentOrdersApi extends BaseAPI {
    /**
     * Create new payment.  Choose document type for create payment order or cash order.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
     * @summary Create new payment
     * @param {PaymentOrdersApiPaymentOrdersCreateOnePaymentOrdersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersCreateOnePaymentOrdersPost(requestParameters: PaymentOrdersApiPaymentOrdersCreateOnePaymentOrdersPostRequest, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersCreateOnePaymentOrdersPost(requestParameters.paymentOrderCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete payment order.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
     * @summary Delete payment order
     * @param {PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete(requestParameters: PaymentOrdersApiPaymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDeleteRequest, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersDeleteOnePaymentOrdersPaymentOrderIdDelete(requestParameters.paymentOrderId, requestParameters.documentType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payment order or cash order detail.  Use query params to choose needed document.  Role needed: \'is_staff\'.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
     * @summary Get payment order detail
     * @param {PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet(requestParameters: PaymentOrdersApiPaymentOrdersGetOnePaymentOrdersPaymentOrderIdGetRequest, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersGetOnePaymentOrdersPaymentOrderIdGet(requestParameters.paymentOrderId, requestParameters.documentType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payment order list(All payment orders).  Use filter params for filter payment order list by bank account or cashbox.  Get info about bank accounts or cashboxes for page - /settings/bank-accounts-and-cashboxes/payment-orders/.  Role check: is_staff.  Permissions needed: \'finance_view_incoming_payment_order\' | \'finance_view_outgoing_payment_order\' | \'finance_view_incoming_cash_order\' | \'finance_view_outgoing_cash_order\'.
     * @summary Get all payment order list.
     * @param {PaymentOrdersApiPaymentOrdersListPaymentOrdersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersListPaymentOrdersGet(requestParameters: PaymentOrdersApiPaymentOrdersListPaymentOrdersGetRequest = {}, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersListPaymentOrdersGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateOperationFrom, requestParameters.dateOperationTo, requestParameters.documentTypes, requestParameters.currencyIds, requestParameters.finItemIds, requestParameters.creatorIds, requestParameters.status, requestParameters.searchFilter, requestParameters.paymentTypes, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\") | Client (\"crm_view_clients\") | Supplier (\"warehouse_view_suppliers\").
     * @summary Get all payment orders for selected object.
     * @param {PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersSublistPaymentOrdersSublistObjectIdGet(requestParameters: PaymentOrdersApiPaymentOrdersSublistPaymentOrdersSublistObjectIdGetRequest, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersSublistPaymentOrdersSublistObjectIdGet(requestParameters.objectId, requestParameters.objectType, requestParameters.page, requestParameters.pageSize, requestParameters.dateOperationFrom, requestParameters.dateOperationTo, requestParameters.documentTypes, requestParameters.currencyIds, requestParameters.finItemIds, requestParameters.creatorIds, requestParameters.status, requestParameters.searchFilter, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change payment status to \"created\". Only for payments with \"conducted\" status.  Use query params to choose needed document.   Role needed: \'is_staff\'.  Permissions needed: \'finance_cancel_incoming_payment_order\' | \'finance_cancel_outgoing_payment_order\' | \'finance_cancel_incoming_cash_order\' | \'finance_cancel_outgoing_cash_order\'.
     * @summary Change payment order status to created
     * @param {PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut(requestParameters: PaymentOrdersApiPaymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPutRequest, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersUpdateOneCancelPaymentOrdersPaymentOrderIdCancelPut(requestParameters.paymentOrderId, requestParameters.documentType, requestParameters.paymentOrderCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update payment order.  Use query params to choose needed document. Only for status \"created\".  Role needed: \'is_staff\'.  Permissions needed: \'finance_change_incoming_payment_order\' | \'finance_change_outgoing_payment_order\' | \'finance_change_incoming_cash_order\' | \'finance_change_outgoing_cash_order\'.
     * @summary Update payment order
     * @param {PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentOrdersApi
     */
    public paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut(requestParameters: PaymentOrdersApiPaymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPutRequest, options?: AxiosRequestConfig) {
        return PaymentOrdersApiFp(this.configuration).paymentOrdersUpdateOnePaymentOrdersPaymentOrderIdPut(requestParameters.paymentOrderId, requestParameters.documentType, requestParameters.paymentOrderUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductMovementsApi - axios parameter creator
 * @export
 */
export const ProductMovementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new product movement.  Perms needed: \'warehouse_change_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Create new product movement
         * @param {ProductMovementCreateSchema} productMovementCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsCreateOneProductMovementsPost: async (productMovementCreateSchema: ProductMovementCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productMovementCreateSchema' is not null or undefined
            assertParamExists('productMovementsCreateOneProductMovementsPost', 'productMovementCreateSchema', productMovementCreateSchema)
            const localVarPath = `/product-movements/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productMovementCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all product movements.  Pagination, ordering and filtering is used.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
         * @summary Get all product movements
         * @param {BaseSort} [sort] 
         * @param {ProductMovementQueryOrder} [order] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {string} [searchFilter] Search by Id and documentNumberNumber.
         * @param {number} [sendingWarehouse] Filtering by sendingWarehouse. If None - all product movements will be shown.
         * @param {number} [receivingWarehouse] Filtering by receivingWarehouse. If None - all product movements will be shown.
         * @param {string} [creator] Filtering by creator. If None - all product movements will be shown.
         * @param {ProductMovementStatuses} [status] Filtering by status. If None - all product movements will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsGetAllProductMovementsGet: async (sort?: BaseSort, order?: ProductMovementQueryOrder, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, sendingWarehouse?: number, receivingWarehouse?: number, creator?: string, status?: ProductMovementStatuses, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-movements/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (sendingWarehouse !== undefined) {
                localVarQueryParameter['sendingWarehouse'] = sendingWarehouse;
            }

            if (receivingWarehouse !== undefined) {
                localVarQueryParameter['receivingWarehouse'] = receivingWarehouse;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product movement detail.  Get current stock balances for selected nomenclatures in the sending warehouse: \"/settings/warehouses/{warehouse_id}/stock-balances/\"  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
         * @summary Get product movement detail
         * @param {number} productMovementId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsGetOneProductMovementsProductMovementIdGet: async (productMovementId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productMovementId' is not null or undefined
            assertParamExists('productMovementsGetOneProductMovementsProductMovementIdGet', 'productMovementId', productMovementId)
            const localVarPath = `/product-movements/{product_movement_id}/`
                .replace(`{${"product_movement_id"}}`, encodeURIComponent(String(productMovementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the conduction of a product movement document(only for status \"conducted\").  Perms needed: \'warehouse_cancel_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Cancel the conduction of a product movement document
         * @param {number} productMovementId 
         * @param {ProductMovementCancellationSchema} productMovementCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut: async (productMovementId: number, productMovementCancellationSchema: ProductMovementCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productMovementId' is not null or undefined
            assertParamExists('productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut', 'productMovementId', productMovementId)
            // verify required parameter 'productMovementCancellationSchema' is not null or undefined
            assertParamExists('productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut', 'productMovementCancellationSchema', productMovementCancellationSchema)
            const localVarPath = `/product-movements/{product_movement_id}/cancel/`
                .replace(`{${"product_movement_id"}}`, encodeURIComponent(String(productMovementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productMovementCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product movement(only for status \"created\").  Actually endpoint doesn\'t delete the document from the database, it just changes its status to \"deleted\". After that the document cannot be edited.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Delete product movement
         * @param {number} productMovementId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut: async (productMovementId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productMovementId' is not null or undefined
            assertParamExists('productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut', 'productMovementId', productMovementId)
            const localVarPath = `/product-movements/{product_movement_id}/delete/`
                .replace(`{${"product_movement_id"}}`, encodeURIComponent(String(productMovementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update/conduct the product movement(only for status \"created\").  Perms needed: \'warehouse_change_nomenclature_access\'. Perms needed for conduction: \'warehouse_post_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Update/conduct the product movement
         * @param {number} productMovementId 
         * @param {ProductMovementUpdateSchema} productMovementUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsUpdateOneProductMovementsProductMovementIdPut: async (productMovementId: number, productMovementUpdateSchema: ProductMovementUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productMovementId' is not null or undefined
            assertParamExists('productMovementsUpdateOneProductMovementsProductMovementIdPut', 'productMovementId', productMovementId)
            // verify required parameter 'productMovementUpdateSchema' is not null or undefined
            assertParamExists('productMovementsUpdateOneProductMovementsProductMovementIdPut', 'productMovementUpdateSchema', productMovementUpdateSchema)
            const localVarPath = `/product-movements/{product_movement_id}/`
                .replace(`{${"product_movement_id"}}`, encodeURIComponent(String(productMovementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productMovementUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductMovementsApi - functional programming interface
 * @export
 */
export const ProductMovementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductMovementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new product movement.  Perms needed: \'warehouse_change_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Create new product movement
         * @param {ProductMovementCreateSchema} productMovementCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productMovementsCreateOneProductMovementsPost(productMovementCreateSchema: ProductMovementCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productMovementsCreateOneProductMovementsPost(productMovementCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all product movements.  Pagination, ordering and filtering is used.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
         * @summary Get all product movements
         * @param {BaseSort} [sort] 
         * @param {ProductMovementQueryOrder} [order] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {string} [searchFilter] Search by Id and documentNumberNumber.
         * @param {number} [sendingWarehouse] Filtering by sendingWarehouse. If None - all product movements will be shown.
         * @param {number} [receivingWarehouse] Filtering by receivingWarehouse. If None - all product movements will be shown.
         * @param {string} [creator] Filtering by creator. If None - all product movements will be shown.
         * @param {ProductMovementStatuses} [status] Filtering by status. If None - all product movements will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productMovementsGetAllProductMovementsGet(sort?: BaseSort, order?: ProductMovementQueryOrder, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, sendingWarehouse?: number, receivingWarehouse?: number, creator?: string, status?: ProductMovementStatuses, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productMovementsGetAllProductMovementsGet(sort, order, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, searchFilter, sendingWarehouse, receivingWarehouse, creator, status, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product movement detail.  Get current stock balances for selected nomenclatures in the sending warehouse: \"/settings/warehouses/{warehouse_id}/stock-balances/\"  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
         * @summary Get product movement detail
         * @param {number} productMovementId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productMovementsGetOneProductMovementsProductMovementIdGet(productMovementId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productMovementsGetOneProductMovementsProductMovementIdGet(productMovementId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel the conduction of a product movement document(only for status \"conducted\").  Perms needed: \'warehouse_cancel_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Cancel the conduction of a product movement document
         * @param {number} productMovementId 
         * @param {ProductMovementCancellationSchema} productMovementCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut(productMovementId: number, productMovementCancellationSchema: ProductMovementCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut(productMovementId, productMovementCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product movement(only for status \"created\").  Actually endpoint doesn\'t delete the document from the database, it just changes its status to \"deleted\". After that the document cannot be edited.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Delete product movement
         * @param {number} productMovementId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut(productMovementId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut(productMovementId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update/conduct the product movement(only for status \"created\").  Perms needed: \'warehouse_change_nomenclature_access\'. Perms needed for conduction: \'warehouse_post_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Update/conduct the product movement
         * @param {number} productMovementId 
         * @param {ProductMovementUpdateSchema} productMovementUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productMovementsUpdateOneProductMovementsProductMovementIdPut(productMovementId: number, productMovementUpdateSchema: ProductMovementUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMovementDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productMovementsUpdateOneProductMovementsProductMovementIdPut(productMovementId, productMovementUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductMovementsApi - factory interface
 * @export
 */
export const ProductMovementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductMovementsApiFp(configuration)
    return {
        /**
         * Create new product movement.  Perms needed: \'warehouse_change_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Create new product movement
         * @param {ProductMovementCreateSchema} productMovementCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsCreateOneProductMovementsPost(productMovementCreateSchema: ProductMovementCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementDetailSchema> {
            return localVarFp.productMovementsCreateOneProductMovementsPost(productMovementCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all product movements.  Pagination, ordering and filtering is used.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
         * @summary Get all product movements
         * @param {BaseSort} [sort] 
         * @param {ProductMovementQueryOrder} [order] 
         * @param {string} [dateCreatedFrom] Date range. Filtering by date created. Date created from.
         * @param {string} [dateCreatedTo] Date range. Filtering by date created. Date created to.
         * @param {string} [dateConductionFrom] Date range. Filtering by date conduction. Date conduction from.
         * @param {string} [dateConductionTo] Date range. Filtering by date conduction. Date conduction to.
         * @param {string} [searchFilter] Search by Id and documentNumberNumber.
         * @param {number} [sendingWarehouse] Filtering by sendingWarehouse. If None - all product movements will be shown.
         * @param {number} [receivingWarehouse] Filtering by receivingWarehouse. If None - all product movements will be shown.
         * @param {string} [creator] Filtering by creator. If None - all product movements will be shown.
         * @param {ProductMovementStatuses} [status] Filtering by status. If None - all product movements will be shown.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsGetAllProductMovementsGet(sort?: BaseSort, order?: ProductMovementQueryOrder, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, searchFilter?: string, sendingWarehouse?: number, receivingWarehouse?: number, creator?: string, status?: ProductMovementStatuses, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementsPage> {
            return localVarFp.productMovementsGetAllProductMovementsGet(sort, order, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, searchFilter, sendingWarehouse, receivingWarehouse, creator, status, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product movement detail.  Get current stock balances for selected nomenclatures in the sending warehouse: \"/settings/warehouses/{warehouse_id}/stock-balances/\"  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
         * @summary Get product movement detail
         * @param {number} productMovementId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsGetOneProductMovementsProductMovementIdGet(productMovementId: number, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementDetailSchema> {
            return localVarFp.productMovementsGetOneProductMovementsProductMovementIdGet(productMovementId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel the conduction of a product movement document(only for status \"conducted\").  Perms needed: \'warehouse_cancel_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Cancel the conduction of a product movement document
         * @param {number} productMovementId 
         * @param {ProductMovementCancellationSchema} productMovementCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut(productMovementId: number, productMovementCancellationSchema: ProductMovementCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementDetailSchema> {
            return localVarFp.productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut(productMovementId, productMovementCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product movement(only for status \"created\").  Actually endpoint doesn\'t delete the document from the database, it just changes its status to \"deleted\". After that the document cannot be edited.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
         * @summary Delete product movement
         * @param {number} productMovementId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut(productMovementId: number, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementDetailSchema> {
            return localVarFp.productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut(productMovementId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update/conduct the product movement(only for status \"created\").  Perms needed: \'warehouse_change_nomenclature_access\'. Perms needed for conduction: \'warehouse_post_warehouse_movements\'.  Role needed: \'is_staff\'.
         * @summary Update/conduct the product movement
         * @param {number} productMovementId 
         * @param {ProductMovementUpdateSchema} productMovementUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productMovementsUpdateOneProductMovementsProductMovementIdPut(productMovementId: number, productMovementUpdateSchema: ProductMovementUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ProductMovementDetailSchema> {
            return localVarFp.productMovementsUpdateOneProductMovementsProductMovementIdPut(productMovementId, productMovementUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productMovementsCreateOneProductMovementsPost operation in ProductMovementsApi.
 * @export
 * @interface ProductMovementsApiProductMovementsCreateOneProductMovementsPostRequest
 */
export interface ProductMovementsApiProductMovementsCreateOneProductMovementsPostRequest {
    /**
     * 
     * @type {ProductMovementCreateSchema}
     * @memberof ProductMovementsApiProductMovementsCreateOneProductMovementsPost
     */
    readonly productMovementCreateSchema: ProductMovementCreateSchema

    /**
     * 
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsCreateOneProductMovementsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productMovementsGetAllProductMovementsGet operation in ProductMovementsApi.
 * @export
 * @interface ProductMovementsApiProductMovementsGetAllProductMovementsGetRequest
 */
export interface ProductMovementsApiProductMovementsGetAllProductMovementsGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {ProductMovementQueryOrder}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly order?: ProductMovementQueryOrder

    /**
     * Date range. Filtering by date created. Date created from.
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date range. Filtering by date created. Date created to.
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date range. Filtering by date conduction. Date conduction from.
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date range. Filtering by date conduction. Date conduction to.
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly dateConductionTo?: string

    /**
     * Search by Id and documentNumberNumber.
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by sendingWarehouse. If None - all product movements will be shown.
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly sendingWarehouse?: number

    /**
     * Filtering by receivingWarehouse. If None - all product movements will be shown.
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly receivingWarehouse?: number

    /**
     * Filtering by creator. If None - all product movements will be shown.
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly creator?: string

    /**
     * Filtering by status. If None - all product movements will be shown.
     * @type {ProductMovementStatuses}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly status?: ProductMovementStatuses

    /**
     * 
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetAllProductMovementsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productMovementsGetOneProductMovementsProductMovementIdGet operation in ProductMovementsApi.
 * @export
 * @interface ProductMovementsApiProductMovementsGetOneProductMovementsProductMovementIdGetRequest
 */
export interface ProductMovementsApiProductMovementsGetOneProductMovementsProductMovementIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsGetOneProductMovementsProductMovementIdGet
     */
    readonly productMovementId: number

    /**
     * 
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsGetOneProductMovementsProductMovementIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut operation in ProductMovementsApi.
 * @export
 * @interface ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPutRequest
 */
export interface ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut
     */
    readonly productMovementId: number

    /**
     * 
     * @type {ProductMovementCancellationSchema}
     * @memberof ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut
     */
    readonly productMovementCancellationSchema: ProductMovementCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut operation in ProductMovementsApi.
 * @export
 * @interface ProductMovementsApiProductMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePutRequest
 */
export interface ProductMovementsApiProductMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut
     */
    readonly productMovementId: number

    /**
     * 
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productMovementsUpdateOneProductMovementsProductMovementIdPut operation in ProductMovementsApi.
 * @export
 * @interface ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPutRequest
 */
export interface ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPut
     */
    readonly productMovementId: number

    /**
     * 
     * @type {ProductMovementUpdateSchema}
     * @memberof ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPut
     */
    readonly productMovementUpdateSchema: ProductMovementUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ProductMovementsApi - object-oriented interface
 * @export
 * @class ProductMovementsApi
 * @extends {BaseAPI}
 */
export class ProductMovementsApi extends BaseAPI {
    /**
     * Create new product movement.  Perms needed: \'warehouse_change_warehouse_movements\'.  Role needed: \'is_staff\'.
     * @summary Create new product movement
     * @param {ProductMovementsApiProductMovementsCreateOneProductMovementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductMovementsApi
     */
    public productMovementsCreateOneProductMovementsPost(requestParameters: ProductMovementsApiProductMovementsCreateOneProductMovementsPostRequest, options?: AxiosRequestConfig) {
        return ProductMovementsApiFp(this.configuration).productMovementsCreateOneProductMovementsPost(requestParameters.productMovementCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all product movements.  Pagination, ordering and filtering is used.  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
     * @summary Get all product movements
     * @param {ProductMovementsApiProductMovementsGetAllProductMovementsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductMovementsApi
     */
    public productMovementsGetAllProductMovementsGet(requestParameters: ProductMovementsApiProductMovementsGetAllProductMovementsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductMovementsApiFp(this.configuration).productMovementsGetAllProductMovementsGet(requestParameters.sort, requestParameters.order, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.searchFilter, requestParameters.sendingWarehouse, requestParameters.receivingWarehouse, requestParameters.creator, requestParameters.status, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product movement detail.  Get current stock balances for selected nomenclatures in the sending warehouse: \"/settings/warehouses/{warehouse_id}/stock-balances/\"  Role needed: \'is_staff\'.  Permissions needed: \'warehouse_view_warehouse_movements\'.
     * @summary Get product movement detail
     * @param {ProductMovementsApiProductMovementsGetOneProductMovementsProductMovementIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductMovementsApi
     */
    public productMovementsGetOneProductMovementsProductMovementIdGet(requestParameters: ProductMovementsApiProductMovementsGetOneProductMovementsProductMovementIdGetRequest, options?: AxiosRequestConfig) {
        return ProductMovementsApiFp(this.configuration).productMovementsGetOneProductMovementsProductMovementIdGet(requestParameters.productMovementId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel the conduction of a product movement document(only for status \"conducted\").  Perms needed: \'warehouse_cancel_warehouse_movements\'.  Role needed: \'is_staff\'.
     * @summary Cancel the conduction of a product movement document
     * @param {ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductMovementsApi
     */
    public productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut(requestParameters: ProductMovementsApiProductMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPutRequest, options?: AxiosRequestConfig) {
        return ProductMovementsApiFp(this.configuration).productMovementsUpdateOneCancelProductMovementsProductMovementIdCancelPut(requestParameters.productMovementId, requestParameters.productMovementCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product movement(only for status \"created\").  Actually endpoint doesn\'t delete the document from the database, it just changes its status to \"deleted\". After that the document cannot be edited.  Perms needed: \'warehouse_change_nomenclature_access\'.  Role needed: \'is_staff\'.
     * @summary Delete product movement
     * @param {ProductMovementsApiProductMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductMovementsApi
     */
    public productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut(requestParameters: ProductMovementsApiProductMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePutRequest, options?: AxiosRequestConfig) {
        return ProductMovementsApiFp(this.configuration).productMovementsUpdateOneDeleteProductMovementsProductMovementIdDeletePut(requestParameters.productMovementId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update/conduct the product movement(only for status \"created\").  Perms needed: \'warehouse_change_nomenclature_access\'. Perms needed for conduction: \'warehouse_post_warehouse_movements\'.  Role needed: \'is_staff\'.
     * @summary Update/conduct the product movement
     * @param {ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductMovementsApi
     */
    public productMovementsUpdateOneProductMovementsProductMovementIdPut(requestParameters: ProductMovementsApiProductMovementsUpdateOneProductMovementsProductMovementIdPutRequest, options?: AxiosRequestConfig) {
        return ProductMovementsApiFp(this.configuration).productMovementsUpdateOneProductMovementsProductMovementIdPut(requestParameters.productMovementId, requestParameters.productMovementUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductReturnsClientApi - axios parameter creator
 * @export
 */
export const ProductReturnsClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export invoice data.  Role check: is_staff  Permission: crm_view_client_returns  accept-language header does not affect the document language. client_product_return.invoice.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} productReturnId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet: async (productReturnId: number, exportType: DataExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet', 'productReturnId', productReturnId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet', 'exportType', exportType)
            const localVarPath = `/product-returns/clients/{product_return_id}/product-return/{export_type}/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Cancel client product return.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut: async (productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut', 'productReturnId', productReturnId)
            // verify required parameter 'baseCancellationSchema' is not null or undefined
            assertParamExists('productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut', 'baseCancellationSchema', baseCancellationSchema)
            const localVarPath = `/product-returns/clients/{product_return_id}/cancel/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Conduct client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Conduct client client_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut: async (productReturnId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut', 'productReturnId', productReturnId)
            const localVarPath = `/product-returns/clients/{product_return_id}/conduct/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Create client client_product_return.
         * @param {number} invoiceId 
         * @param {CreateClientProductReturnSchema} createClientProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsCreateProductReturnsClientsInvoiceIdPost: async (invoiceId: number, createClientProductReturnSchema: CreateClientProductReturnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('productReturnsClientsCreateProductReturnsClientsInvoiceIdPost', 'invoiceId', invoiceId)
            // verify required parameter 'createClientProductReturnSchema' is not null or undefined
            assertParamExists('productReturnsClientsCreateProductReturnsClientsInvoiceIdPost', 'createClientProductReturnSchema', createClientProductReturnSchema)
            const localVarPath = `/product-returns/clients/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientProductReturnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change client_product_return status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Change client client_product_return status to \'deleted\'.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut: async (productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut', 'productReturnId', productReturnId)
            // verify required parameter 'baseCancellationSchema' is not null or undefined
            assertParamExists('productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut', 'baseCancellationSchema', baseCancellationSchema)
            const localVarPath = `/product-returns/clients/{product_return_id}/delete/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client_product_return for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary Get client client_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsGetProductReturnsClientsProductReturnIdGet: async (productReturnId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsClientsGetProductReturnsClientsProductReturnIdGet', 'productReturnId', productReturnId)
            const localVarPath = `/product-returns/clients/{product_return_id}/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary List client client_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsListProductReturnsClientsGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-returns/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (withDebt !== undefined) {
                localVarQueryParameter['withDebt'] = withDebt;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary List client client_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsListSelectProductReturnsClientsSelectGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-returns/clients/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (withDebt !== undefined) {
                localVarQueryParameter['withDebt'] = withDebt;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Update client client_product_return.
         * @param {number} productReturnId 
         * @param {UpdateClientProductReturnSchema} updateClientProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut: async (productReturnId: number, updateClientProductReturnSchema: UpdateClientProductReturnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut', 'productReturnId', productReturnId)
            // verify required parameter 'updateClientProductReturnSchema' is not null or undefined
            assertParamExists('productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut', 'updateClientProductReturnSchema', updateClientProductReturnSchema)
            const localVarPath = `/product-returns/clients/{product_return_id}/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClientProductReturnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductReturnsClientApi - functional programming interface
 * @export
 */
export const ProductReturnsClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductReturnsClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Export invoice data.  Role check: is_staff  Permission: crm_view_client_returns  accept-language header does not affect the document language. client_product_return.invoice.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} productReturnId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet(productReturnId: number, exportType: DataExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet(productReturnId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Cancel client product return.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut(productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut(productReturnId, baseCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Conduct client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Conduct client client_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut(productReturnId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut(productReturnId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Create client client_product_return.
         * @param {number} invoiceId 
         * @param {CreateClientProductReturnSchema} createClientProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsCreateProductReturnsClientsInvoiceIdPost(invoiceId: number, createClientProductReturnSchema: CreateClientProductReturnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsCreateProductReturnsClientsInvoiceIdPost(invoiceId, createClientProductReturnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change client_product_return status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Change client client_product_return status to \'deleted\'.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut(productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut(productReturnId, baseCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client_product_return for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary Get client client_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsGetProductReturnsClientsProductReturnIdGet(productReturnId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsGetProductReturnsClientsProductReturnIdGet(productReturnId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary List client client_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsListProductReturnsClientsGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsListProductReturnsClientsGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, clientType, clientCategoryId, agentId, label, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary List client client_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsListSelectProductReturnsClientsSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductReturnSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsListSelectProductReturnsClientsSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, clientType, clientCategoryId, agentId, label, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Update client client_product_return.
         * @param {number} productReturnId 
         * @param {UpdateClientProductReturnSchema} updateClientProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut(productReturnId: number, updateClientProductReturnSchema: UpdateClientProductReturnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut(productReturnId, updateClientProductReturnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductReturnsClientApi - factory interface
 * @export
 */
export const ProductReturnsClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductReturnsClientApiFp(configuration)
    return {
        /**
         * Export invoice data.  Role check: is_staff  Permission: crm_view_client_returns  accept-language header does not affect the document language. client_product_return.invoice.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} productReturnId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet(productReturnId: number, exportType: DataExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet(productReturnId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Cancel client product return.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut(productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnSchema> {
            return localVarFp.productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut(productReturnId, baseCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Conduct client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Conduct client client_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut(productReturnId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnSchema> {
            return localVarFp.productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut(productReturnId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Create client client_product_return.
         * @param {number} invoiceId 
         * @param {CreateClientProductReturnSchema} createClientProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsCreateProductReturnsClientsInvoiceIdPost(invoiceId: number, createClientProductReturnSchema: CreateClientProductReturnSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnSchema> {
            return localVarFp.productReturnsClientsCreateProductReturnsClientsInvoiceIdPost(invoiceId, createClientProductReturnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change client_product_return status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Change client client_product_return status to \'deleted\'.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut(productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnSchema> {
            return localVarFp.productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut(productReturnId, baseCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client_product_return for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary Get client client_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsGetProductReturnsClientsProductReturnIdGet(productReturnId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnSchema> {
            return localVarFp.productReturnsClientsGetProductReturnsClientsProductReturnIdGet(productReturnId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary List client client_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsListProductReturnsClientsGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnPage> {
            return localVarFp.productReturnsClientsListProductReturnsClientsGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, clientType, clientCategoryId, agentId, label, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
         * @summary List client client_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsListSelectProductReturnsClientsSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ProductReturnSimplePage> {
            return localVarFp.productReturnsClientsListSelectProductReturnsClientsSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, clientType, clientCategoryId, agentId, label, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
         * @summary Update client client_product_return.
         * @param {number} productReturnId 
         * @param {UpdateClientProductReturnSchema} updateClientProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut(productReturnId: number, updateClientProductReturnSchema: UpdateClientProductReturnSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProductReturnSchema> {
            return localVarFp.productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut(productReturnId, updateClientProductReturnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGetRequest
 */
export interface ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet
     */
    readonly productReturnId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPutRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {BaseCancellationSchema}
     * @memberof ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut
     */
    readonly baseCancellationSchema: BaseCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsConductProductReturnsClientsProductReturnIdConductPutRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsConductProductReturnsClientsProductReturnIdConductPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsConductProductReturnsClientsProductReturnIdConductPut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsConductProductReturnsClientsProductReturnIdConductPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsCreateProductReturnsClientsInvoiceIdPost operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPostRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPost
     */
    readonly invoiceId: number

    /**
     * 
     * @type {CreateClientProductReturnSchema}
     * @memberof ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPost
     */
    readonly createClientProductReturnSchema: CreateClientProductReturnSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePutRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {BaseCancellationSchema}
     * @memberof ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut
     */
    readonly baseCancellationSchema: BaseCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsGetProductReturnsClientsProductReturnIdGet operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsGetProductReturnsClientsProductReturnIdGetRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsGetProductReturnsClientsProductReturnIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsGetProductReturnsClientsProductReturnIdGet
     */
    readonly productReturnId: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsGetProductReturnsClientsProductReturnIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsListProductReturnsClientsGet operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGetRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date conduction from.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date conduction to.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly dateConductionTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProductReturnQueryOrder}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly order?: ProductReturnQueryOrder

    /**
     * Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly currencyId?: number

    /**
     * Is cash payment.
     * @type {boolean}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly isCashPayment?: boolean

    /**
     * Creator id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly responsibleId?: string

    /**
     * Status.
     * @type {ProductReturnStatuses}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly status?: ProductReturnStatuses

    /**
     * User id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly staffId?: string

    /**
     * Get product returns with sumToPay &gt; 0.
     * @type {boolean}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly withDebt?: boolean

    /**
     * 
     * @type {ClientTypes}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly clientCategoryId?: number

    /**
     * Agent id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientProductReturnLabels}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly label?: ClientProductReturnLabels

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsListSelectProductReturnsClientsSelectGet operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGetRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date conduction from.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date conduction to.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly dateConductionTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProductReturnQueryOrder}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly order?: ProductReturnQueryOrder

    /**
     * Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly currencyId?: number

    /**
     * Is cash payment.
     * @type {boolean}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly isCashPayment?: boolean

    /**
     * Creator id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly responsibleId?: string

    /**
     * Status.
     * @type {ProductReturnStatuses}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly status?: ProductReturnStatuses

    /**
     * User id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly staffId?: string

    /**
     * Get product returns with sumToPay &gt; 0.
     * @type {boolean}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly withDebt?: boolean

    /**
     * 
     * @type {ClientTypes}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly clientCategoryId?: number

    /**
     * Agent id.
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientProductReturnLabels}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly label?: ClientProductReturnLabels

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut operation in ProductReturnsClientApi.
 * @export
 * @interface ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPutRequest
 */
export interface ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {UpdateClientProductReturnSchema}
     * @memberof ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPut
     */
    readonly updateClientProductReturnSchema: UpdateClientProductReturnSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ProductReturnsClientApi - object-oriented interface
 * @export
 * @class ProductReturnsClientApi
 * @extends {BaseAPI}
 */
export class ProductReturnsClientApi extends BaseAPI {
    /**
     * Export invoice data.  Role check: is_staff  Permission: crm_view_client_returns  accept-language header does not affect the document language. client_product_return.invoice.order.user.document_language is used for the export instead.
     * @summary Export client proforma data.
     * @param {ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet(requestParameters: ProductReturnsClientApiCrmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).crmClientInvoiceExportProductReturnsClientsProductReturnIdProductReturnExportTypeGet(requestParameters.productReturnId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
     * @summary Cancel client product return.
     * @param {ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut(requestParameters: ProductReturnsClientApiProductReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsCancelProductReturnsClientsProductReturnIdCancelPut(requestParameters.productReturnId, requestParameters.baseCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Conduct client_product_return.  Role check: is_staff.  Permission: crm_change_client_returns
     * @summary Conduct client client_product_return.
     * @param {ProductReturnsClientApiProductReturnsClientsConductProductReturnsClientsProductReturnIdConductPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut(requestParameters: ProductReturnsClientApiProductReturnsClientsConductProductReturnsClientsProductReturnIdConductPutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsConductProductReturnsClientsProductReturnIdConductPut(requestParameters.productReturnId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
     * @summary Create client client_product_return.
     * @param {ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsCreateProductReturnsClientsInvoiceIdPost(requestParameters: ProductReturnsClientApiProductReturnsClientsCreateProductReturnsClientsInvoiceIdPostRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsCreateProductReturnsClientsInvoiceIdPost(requestParameters.invoiceId, requestParameters.createClientProductReturnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change client_product_return status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_returns
     * @summary Change client client_product_return status to \'deleted\'.
     * @param {ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut(requestParameters: ProductReturnsClientApiProductReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsDeleteProductReturnsClientsProductReturnIdDeletePut(requestParameters.productReturnId, requestParameters.baseCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client_product_return for a client.  Role check: is_staff.  Permission: crm_view_client_returns
     * @summary Get client client_product_return.
     * @param {ProductReturnsClientApiProductReturnsClientsGetProductReturnsClientsProductReturnIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsGetProductReturnsClientsProductReturnIdGet(requestParameters: ProductReturnsClientApiProductReturnsClientsGetProductReturnsClientsProductReturnIdGetRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsGetProductReturnsClientsProductReturnIdGet(requestParameters.productReturnId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
     * @summary List client client_product_returns.
     * @param {ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsListProductReturnsClientsGet(requestParameters: ProductReturnsClientApiProductReturnsClientsListProductReturnsClientsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsListProductReturnsClientsGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.isCashPayment, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.withDebt, requestParameters.clientType, requestParameters.clientCategoryId, requestParameters.agentId, requestParameters.label, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List client_product_returns for a client.  Role check: is_staff.  Permission: crm_view_client_returns
     * @summary List client client_product_returns.
     * @param {ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsListSelectProductReturnsClientsSelectGet(requestParameters: ProductReturnsClientApiProductReturnsClientsListSelectProductReturnsClientsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsListSelectProductReturnsClientsSelectGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.isCashPayment, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.withDebt, requestParameters.clientType, requestParameters.clientCategoryId, requestParameters.agentId, requestParameters.label, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client_product_return for a client.  Role check: is_staff.  Permission: crm_change_client_returns
     * @summary Update client client_product_return.
     * @param {ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsClientApi
     */
    public productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut(requestParameters: ProductReturnsClientApiProductReturnsClientsUpdateProductReturnsClientsProductReturnIdPutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsClientApiFp(this.configuration).productReturnsClientsUpdateProductReturnsClientsProductReturnIdPut(requestParameters.productReturnId, requestParameters.updateClientProductReturnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductReturnsSupplierApi - axios parameter creator
 * @export
 */
export const ProductReturnsSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel supplier_product_return.  Role check: is_staff.  Permission: warehouse_cancel_supplier_returns
         * @summary Cancel supplier product return.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut: async (productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut', 'productReturnId', productReturnId)
            // verify required parameter 'baseCancellationSchema' is not null or undefined
            assertParamExists('productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut', 'baseCancellationSchema', baseCancellationSchema)
            const localVarPath = `/product-returns/suppliers/{product_return_id}/cancel/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Conduct supplier_product_return.  Role check: is_staff.  Permission: warehouse_post_supplier_returns
         * @summary Conduct supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut: async (productReturnId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut', 'productReturnId', productReturnId)
            const localVarPath = `/product-returns/suppliers/{product_return_id}/conduct/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Create supplier supplier_product_return.
         * @param {number} invoiceId 
         * @param {CreateSupplierProductReturnSchema} createSupplierProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost: async (invoiceId: number, createSupplierProductReturnSchema: CreateSupplierProductReturnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost', 'invoiceId', invoiceId)
            // verify required parameter 'createSupplierProductReturnSchema' is not null or undefined
            assertParamExists('productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost', 'createSupplierProductReturnSchema', createSupplierProductReturnSchema)
            const localVarPath = `/product-returns/suppliers/{invoice_id}/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSupplierProductReturnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier_product_return status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Change supplier supplier_product_return status to \'deleted\'.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut: async (productReturnId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut', 'productReturnId', productReturnId)
            const localVarPath = `/product-returns/suppliers/{product_return_id}/delete/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary Get supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet: async (productReturnId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet', 'productReturnId', productReturnId)
            const localVarPath = `/product-returns/suppliers/{product_return_id}/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary List supplier supplier_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersListProductReturnsSuppliersGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, supplierCategoryId?: number, label?: SupplierProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-returns/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (withDebt !== undefined) {
                localVarQueryParameter['withDebt'] = withDebt;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary List supplier supplier_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, supplierCategoryId?: number, label?: SupplierProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-returns/suppliers/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (dateConductionFrom !== undefined) {
                localVarQueryParameter['dateConductionFrom'] = (dateConductionFrom as any instanceof Date) ?
                    (dateConductionFrom as any).toISOString().substr(0,10) :
                    dateConductionFrom;
            }

            if (dateConductionTo !== undefined) {
                localVarQueryParameter['dateConductionTo'] = (dateConductionTo as any instanceof Date) ?
                    (dateConductionTo as any).toISOString().substr(0,10) :
                    dateConductionTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (withDebt !== undefined) {
                localVarQueryParameter['withDebt'] = withDebt;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Update supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {UpdateSupplierProductReturnSchema} updateSupplierProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut: async (productReturnId: number, updateSupplierProductReturnSchema: UpdateSupplierProductReturnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productReturnId' is not null or undefined
            assertParamExists('productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut', 'productReturnId', productReturnId)
            // verify required parameter 'updateSupplierProductReturnSchema' is not null or undefined
            assertParamExists('productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut', 'updateSupplierProductReturnSchema', updateSupplierProductReturnSchema)
            const localVarPath = `/product-returns/suppliers/{product_return_id}/`
                .replace(`{${"product_return_id"}}`, encodeURIComponent(String(productReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSupplierProductReturnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductReturnsSupplierApi - functional programming interface
 * @export
 */
export const ProductReturnsSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductReturnsSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel supplier_product_return.  Role check: is_staff.  Permission: warehouse_cancel_supplier_returns
         * @summary Cancel supplier product return.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut(productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut(productReturnId, baseCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Conduct supplier_product_return.  Role check: is_staff.  Permission: warehouse_post_supplier_returns
         * @summary Conduct supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut(productReturnId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut(productReturnId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Create supplier supplier_product_return.
         * @param {number} invoiceId 
         * @param {CreateSupplierProductReturnSchema} createSupplierProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost(invoiceId: number, createSupplierProductReturnSchema: CreateSupplierProductReturnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost(invoiceId, createSupplierProductReturnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier_product_return status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Change supplier supplier_product_return status to \'deleted\'.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut(productReturnId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut(productReturnId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary Get supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet(productReturnId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet(productReturnId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary List supplier supplier_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersListProductReturnsSuppliersGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, supplierCategoryId?: number, label?: SupplierProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersListProductReturnsSuppliersGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, supplierCategoryId, label, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary List supplier supplier_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, supplierCategoryId?: number, label?: SupplierProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductReturnSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, supplierCategoryId, label, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Update supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {UpdateSupplierProductReturnSchema} updateSupplierProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut(productReturnId: number, updateSupplierProductReturnSchema: UpdateSupplierProductReturnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProductReturnSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut(productReturnId, updateSupplierProductReturnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductReturnsSupplierApi - factory interface
 * @export
 */
export const ProductReturnsSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductReturnsSupplierApiFp(configuration)
    return {
        /**
         * Cancel supplier_product_return.  Role check: is_staff.  Permission: warehouse_cancel_supplier_returns
         * @summary Cancel supplier product return.
         * @param {number} productReturnId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut(productReturnId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnSchema> {
            return localVarFp.productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut(productReturnId, baseCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Conduct supplier_product_return.  Role check: is_staff.  Permission: warehouse_post_supplier_returns
         * @summary Conduct supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut(productReturnId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnSchema> {
            return localVarFp.productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut(productReturnId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Create supplier supplier_product_return.
         * @param {number} invoiceId 
         * @param {CreateSupplierProductReturnSchema} createSupplierProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost(invoiceId: number, createSupplierProductReturnSchema: CreateSupplierProductReturnSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnSchema> {
            return localVarFp.productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost(invoiceId, createSupplierProductReturnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier_product_return status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Change supplier supplier_product_return status to \'deleted\'.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut(productReturnId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnSchema> {
            return localVarFp.productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut(productReturnId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary Get supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet(productReturnId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnSchema> {
            return localVarFp.productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet(productReturnId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary List supplier supplier_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersListProductReturnsSuppliersGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, supplierCategoryId?: number, label?: SupplierProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnPage> {
            return localVarFp.productReturnsSuppliersListProductReturnsSuppliersGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, supplierCategoryId, label, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
         * @summary List supplier supplier_product_returns.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [dateConductionFrom] Date conduction from.
         * @param {string} [dateConductionTo] Date conduction to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProductReturnQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {ProductReturnStatuses} [status] Status.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {boolean} [withDebt] Get product returns with sumToPay &gt; 0.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProductReturnLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, dateConductionFrom?: string, dateConductionTo?: string, sort?: BaseSort, order?: ProductReturnQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, isCashPayment?: boolean, creatorId?: string, responsibleId?: string, status?: ProductReturnStatuses, userId?: string, staffId?: string, withDebt?: boolean, supplierCategoryId?: number, label?: SupplierProductReturnLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ProductReturnSimplePage> {
            return localVarFp.productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, dateConductionFrom, dateConductionTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, isCashPayment, creatorId, responsibleId, status, userId, staffId, withDebt, supplierCategoryId, label, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
         * @summary Update supplier supplier_product_return.
         * @param {number} productReturnId 
         * @param {UpdateSupplierProductReturnSchema} updateSupplierProductReturnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut(productReturnId: number, updateSupplierProductReturnSchema: UpdateSupplierProductReturnSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProductReturnSchema> {
            return localVarFp.productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut(productReturnId, updateSupplierProductReturnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPutRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {BaseCancellationSchema}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut
     */
    readonly baseCancellationSchema: BaseCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPutRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPostRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost
     */
    readonly invoiceId: number

    /**
     * 
     * @type {CreateSupplierProductReturnSchema}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost
     */
    readonly createSupplierProductReturnSchema: CreateSupplierProductReturnSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePutRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGetRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet
     */
    readonly productReturnId: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersListProductReturnsSuppliersGet operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGetRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date conduction from.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date conduction to.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly dateConductionTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProductReturnQueryOrder}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly order?: ProductReturnQueryOrder

    /**
     * Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly currencyId?: number

    /**
     * Is cash payment.
     * @type {boolean}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly isCashPayment?: boolean

    /**
     * Creator id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly responsibleId?: string

    /**
     * Status.
     * @type {ProductReturnStatuses}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly status?: ProductReturnStatuses

    /**
     * User id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly staffId?: string

    /**
     * Get product returns with sumToPay &gt; 0.
     * @type {boolean}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly withDebt?: boolean

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierProductReturnLabels}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly label?: SupplierProductReturnLabels

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGetRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Date conduction from.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly dateConductionFrom?: string

    /**
     * Date conduction to.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly dateConductionTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProductReturnQueryOrder}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly order?: ProductReturnQueryOrder

    /**
     * Search by № з/п, № документа, Клиент (по Телефону,Названию, VAT номеру, регистрационный номер) Основание
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly currencyId?: number

    /**
     * Is cash payment.
     * @type {boolean}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly isCashPayment?: boolean

    /**
     * Creator id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly responsibleId?: string

    /**
     * Status.
     * @type {ProductReturnStatuses}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly status?: ProductReturnStatuses

    /**
     * User id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly staffId?: string

    /**
     * Get product returns with sumToPay &gt; 0.
     * @type {boolean}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly withDebt?: boolean

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierProductReturnLabels}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly label?: SupplierProductReturnLabels

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut operation in ProductReturnsSupplierApi.
 * @export
 * @interface ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPutRequest
 */
export interface ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut
     */
    readonly productReturnId: number

    /**
     * 
     * @type {UpdateSupplierProductReturnSchema}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut
     */
    readonly updateSupplierProductReturnSchema: UpdateSupplierProductReturnSchema

    /**
     * 
     * @type {string}
     * @memberof ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ProductReturnsSupplierApi - object-oriented interface
 * @export
 * @class ProductReturnsSupplierApi
 * @extends {BaseAPI}
 */
export class ProductReturnsSupplierApi extends BaseAPI {
    /**
     * Cancel supplier_product_return.  Role check: is_staff.  Permission: warehouse_cancel_supplier_returns
     * @summary Cancel supplier product return.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersCancelProductReturnsSuppliersProductReturnIdCancelPut(requestParameters.productReturnId, requestParameters.baseCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Conduct supplier_product_return.  Role check: is_staff.  Permission: warehouse_post_supplier_returns
     * @summary Conduct supplier supplier_product_return.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersConductProductReturnsSuppliersProductReturnIdConductPut(requestParameters.productReturnId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
     * @summary Create supplier supplier_product_return.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPostRequest, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersCreateProductReturnsSuppliersInvoiceIdPost(requestParameters.invoiceId, requestParameters.createSupplierProductReturnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier_product_return status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
     * @summary Change supplier supplier_product_return status to \'deleted\'.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersDeleteProductReturnsSuppliersProductReturnIdDeletePut(requestParameters.productReturnId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
     * @summary Get supplier supplier_product_return.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGetRequest, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersGetProductReturnsSuppliersProductReturnIdGet(requestParameters.productReturnId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
     * @summary List supplier supplier_product_returns.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersListProductReturnsSuppliersGet(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersListProductReturnsSuppliersGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersListProductReturnsSuppliersGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.isCashPayment, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.withDebt, requestParameters.supplierCategoryId, requestParameters.label, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supplier_product_returns for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_returns
     * @summary List supplier supplier_product_returns.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersListSelectProductReturnsSuppliersSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersListSelectProductReturnsSuppliersSelectGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.dateConductionFrom, requestParameters.dateConductionTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.isCashPayment, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.status, requestParameters.userId, requestParameters.staffId, requestParameters.withDebt, requestParameters.supplierCategoryId, requestParameters.label, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update supplier_product_return for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_returns
     * @summary Update supplier supplier_product_return.
     * @param {ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductReturnsSupplierApi
     */
    public productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut(requestParameters: ProductReturnsSupplierApiProductReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPutRequest, options?: AxiosRequestConfig) {
        return ProductReturnsSupplierApiFp(this.configuration).productReturnsSuppliersUpdateProductReturnsSuppliersProductReturnIdPut(requestParameters.productReturnId, requestParameters.updateSupplierProductReturnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change the current user password.  Role check: is_staff.  New password cannot be the same as old password New password and confirm password must match
         * @summary Change current staff user password
         * @param {ChangeProfilePasswordSchema} changeProfilePasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileStaffChangePasswordProfileStaffChangePasswordPost: async (changeProfilePasswordSchema: ChangeProfilePasswordSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeProfilePasswordSchema' is not null or undefined
            assertParamExists('profileStaffChangePasswordProfileStaffChangePasswordPost', 'changeProfilePasswordSchema', changeProfilePasswordSchema)
            const localVarPath = `/profile/staff/change-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeProfilePasswordSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current staff profile. Role check: is_staff. Auth required.
         * @summary Get current staff user profile
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileStaffProfileStaffGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/staff/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Change the current user password.  Role check: is_staff.  New password cannot be the same as old password New password and confirm password must match
         * @summary Change current staff user password
         * @param {ChangeProfilePasswordSchema} changeProfilePasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileStaffChangePasswordProfileStaffChangePasswordPost(changeProfilePasswordSchema: ChangeProfilePasswordSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileStaffChangePasswordProfileStaffChangePasswordPost(changeProfilePasswordSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current staff profile. Role check: is_staff. Auth required.
         * @summary Get current staff user profile
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileStaffProfileStaffGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileStaffProfileStaffGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Change the current user password.  Role check: is_staff.  New password cannot be the same as old password New password and confirm password must match
         * @summary Change current staff user password
         * @param {ChangeProfilePasswordSchema} changeProfilePasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileStaffChangePasswordProfileStaffChangePasswordPost(changeProfilePasswordSchema: ChangeProfilePasswordSchema, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.profileStaffChangePasswordProfileStaffChangePasswordPost(changeProfilePasswordSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current staff profile. Role check: is_staff. Auth required.
         * @summary Get current staff user profile
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileStaffProfileStaffGet(acceptLanguage?: string, options?: any): AxiosPromise<StaffProfileSchema> {
            return localVarFp.profileStaffProfileStaffGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profileStaffChangePasswordProfileStaffChangePasswordPost operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileStaffChangePasswordProfileStaffChangePasswordPostRequest
 */
export interface ProfileApiProfileStaffChangePasswordProfileStaffChangePasswordPostRequest {
    /**
     * 
     * @type {ChangeProfilePasswordSchema}
     * @memberof ProfileApiProfileStaffChangePasswordProfileStaffChangePasswordPost
     */
    readonly changeProfilePasswordSchema: ChangeProfilePasswordSchema

    /**
     * 
     * @type {string}
     * @memberof ProfileApiProfileStaffChangePasswordProfileStaffChangePasswordPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for profileStaffProfileStaffGet operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileStaffProfileStaffGetRequest
 */
export interface ProfileApiProfileStaffProfileStaffGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileApiProfileStaffProfileStaffGet
     */
    readonly acceptLanguage?: string
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Change the current user password.  Role check: is_staff.  New password cannot be the same as old password New password and confirm password must match
     * @summary Change current staff user password
     * @param {ProfileApiProfileStaffChangePasswordProfileStaffChangePasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileStaffChangePasswordProfileStaffChangePasswordPost(requestParameters: ProfileApiProfileStaffChangePasswordProfileStaffChangePasswordPostRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileStaffChangePasswordProfileStaffChangePasswordPost(requestParameters.changeProfilePasswordSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current staff profile. Role check: is_staff. Auth required.
     * @summary Get current staff user profile
     * @param {ProfileApiProfileStaffProfileStaffGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileStaffProfileStaffGet(requestParameters: ProfileApiProfileStaffProfileStaffGetRequest = {}, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileStaffProfileStaffGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfitReportsApi - axios parameter creator
 * @export
 */
export const ProfitReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export brands profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitBrandsExportReportsProfitBrandsExportTypeGet: async (exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsProfitBrandsExportReportsProfitBrandsExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/profit/brands/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profit reports by brand.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit brands by users
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitBrandsReportsProfitBrandsGet: async (page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/profit/brands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export countries profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitCountriesExportReportsProfitCountriesExportTypeGet: async (exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsProfitCountriesExportReportsProfitCountriesExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/profit/countries/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profit reports by country.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit countries by users
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitCountriesReportsProfitCountriesGet: async (page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/profit/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export nomenclature profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export nomenclature profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [countryId] 
         * @param {ProfitReportInvoicesType} [invoicesType] 
         * @param {ProfitReportPaymentType} [paymentType] 
         * @param {NomenclatureProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet: async (exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, countryId?: number, invoicesType?: ProfitReportInvoicesType, paymentType?: ProfitReportPaymentType, order?: NomenclatureProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/profit/nomenclature/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (invoicesType !== undefined) {
                localVarQueryParameter['invoicesType'] = invoicesType;
            }

            if (paymentType !== undefined) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [countryId] 
         * @param {ProfitReportInvoicesType} [invoicesType] 
         * @param {ProfitReportPaymentType} [paymentType] 
         * @param {NomenclatureProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitNomenclatureReportsProfitNomenclatureGet: async (page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, countryId?: number, invoicesType?: ProfitReportInvoicesType, paymentType?: ProfitReportPaymentType, order?: NomenclatureProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/profit/nomenclature/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (invoicesType !== undefined) {
                localVarQueryParameter['invoicesType'] = invoicesType;
            }

            if (paymentType !== undefined) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export user profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export user profit data.
         * @param {DataExportType} exportType 
         * @param {ClientStaffAgentTypes} userType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitUsersExportReportsProfitUsersExportTypeGet: async (exportType: DataExportType, userType: ClientStaffAgentTypes, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsProfitUsersExportReportsProfitUsersExportTypeGet', 'exportType', exportType)
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('reportsProfitUsersExportReportsProfitUsersExportTypeGet', 'userType', userType)
            const localVarPath = `/reports/profit/users/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userType !== undefined) {
                localVarQueryParameter['userType'] = userType;
            }

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit reports by users
         * @param {ClientStaffAgentTypes} userType 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitUsersReportsProfitUsersGet: async (userType: ClientStaffAgentTypes, page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('reportsProfitUsersReportsProfitUsersGet', 'userType', userType)
            const localVarPath = `/reports/profit/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userType !== undefined) {
                localVarQueryParameter['userType'] = userType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateConductedFrom !== undefined) {
                localVarQueryParameter['dateConductedFrom'] = (dateConductedFrom as any instanceof Date) ?
                    (dateConductedFrom as any).toISOString().substr(0,10) :
                    dateConductedFrom;
            }

            if (dateConductedTo !== undefined) {
                localVarQueryParameter['dateConductedTo'] = (dateConductedTo as any instanceof Date) ?
                    (dateConductedTo as any).toISOString().substr(0,10) :
                    dateConductedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfitReportsApi - functional programming interface
 * @export
 */
export const ProfitReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfitReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export brands profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitBrandsExportReportsProfitBrandsExportTypeGet(exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitBrandsExportReportsProfitBrandsExportTypeGet(exportType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get profit reports by brand.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit brands by users
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitBrandsReportsProfitBrandsGet(page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfitDefaultReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitBrandsReportsProfitBrandsGet(page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export countries profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitCountriesExportReportsProfitCountriesExportTypeGet(exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitCountriesExportReportsProfitCountriesExportTypeGet(exportType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get profit reports by country.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit countries by users
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitCountriesReportsProfitCountriesGet(page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfitDefaultReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitCountriesReportsProfitCountriesGet(page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export nomenclature profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export nomenclature profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [countryId] 
         * @param {ProfitReportInvoicesType} [invoicesType] 
         * @param {ProfitReportPaymentType} [paymentType] 
         * @param {NomenclatureProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet(exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, countryId?: number, invoicesType?: ProfitReportInvoicesType, paymentType?: ProfitReportPaymentType, order?: NomenclatureProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet(exportType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, countryId, invoicesType, paymentType, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [countryId] 
         * @param {ProfitReportInvoicesType} [invoicesType] 
         * @param {ProfitReportPaymentType} [paymentType] 
         * @param {NomenclatureProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitNomenclatureReportsProfitNomenclatureGet(page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, countryId?: number, invoicesType?: ProfitReportInvoicesType, paymentType?: ProfitReportPaymentType, order?: NomenclatureProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfitNomenclatureReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitNomenclatureReportsProfitNomenclatureGet(page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, countryId, invoicesType, paymentType, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export user profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export user profit data.
         * @param {DataExportType} exportType 
         * @param {ClientStaffAgentTypes} userType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitUsersExportReportsProfitUsersExportTypeGet(exportType: DataExportType, userType: ClientStaffAgentTypes, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitUsersExportReportsProfitUsersExportTypeGet(exportType, userType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit reports by users
         * @param {ClientStaffAgentTypes} userType 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsProfitUsersReportsProfitUsersGet(userType: ClientStaffAgentTypes, page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfitUserReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsProfitUsersReportsProfitUsersGet(userType, page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfitReportsApi - factory interface
 * @export
 */
export const ProfitReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfitReportsApiFp(configuration)
    return {
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export brands profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitBrandsExportReportsProfitBrandsExportTypeGet(exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsProfitBrandsExportReportsProfitBrandsExportTypeGet(exportType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profit reports by brand.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit brands by users
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitBrandsReportsProfitBrandsGet(page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<ProfitDefaultReportPageSchema> {
            return localVarFp.reportsProfitBrandsReportsProfitBrandsGet(page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export countries profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitCountriesExportReportsProfitCountriesExportTypeGet(exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsProfitCountriesExportReportsProfitCountriesExportTypeGet(exportType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profit reports by country.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit countries by users
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitCountriesReportsProfitCountriesGet(page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<ProfitDefaultReportPageSchema> {
            return localVarFp.reportsProfitCountriesReportsProfitCountriesGet(page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export nomenclature profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export nomenclature profit data.
         * @param {DataExportType} exportType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [countryId] 
         * @param {ProfitReportInvoicesType} [invoicesType] 
         * @param {ProfitReportPaymentType} [paymentType] 
         * @param {NomenclatureProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet(exportType: DataExportType, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, countryId?: number, invoicesType?: ProfitReportInvoicesType, paymentType?: ProfitReportPaymentType, order?: NomenclatureProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet(exportType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, countryId, invoicesType, paymentType, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [countryId] 
         * @param {ProfitReportInvoicesType} [invoicesType] 
         * @param {ProfitReportPaymentType} [paymentType] 
         * @param {NomenclatureProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitNomenclatureReportsProfitNomenclatureGet(page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, countryId?: number, invoicesType?: ProfitReportInvoicesType, paymentType?: ProfitReportPaymentType, order?: NomenclatureProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<ProfitNomenclatureReportPageSchema> {
            return localVarFp.reportsProfitNomenclatureReportsProfitNomenclatureGet(page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, countryId, invoicesType, paymentType, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export user profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export user profit data.
         * @param {DataExportType} exportType 
         * @param {ClientStaffAgentTypes} userType 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitUsersExportReportsProfitUsersExportTypeGet(exportType: DataExportType, userType: ClientStaffAgentTypes, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsProfitUsersExportReportsProfitUsersExportTypeGet(exportType, userType, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
         * @summary Get profit reports by users
         * @param {ClientStaffAgentTypes} userType 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateConductedFrom] 
         * @param {string} [dateConductedTo] 
         * @param {BaseSort} [sort] 
         * @param {string} [searchFilter] 
         * @param {number} [brandId] 
         * @param {number} [categoryId] 
         * @param {number} [subcategoryId] 
         * @param {number} [warehouseId] 
         * @param {DefaultProfitReportQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsProfitUsersReportsProfitUsersGet(userType: ClientStaffAgentTypes, page?: number, pageSize?: number, dateConductedFrom?: string, dateConductedTo?: string, sort?: BaseSort, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, order?: DefaultProfitReportQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<ProfitUserReportPageSchema> {
            return localVarFp.reportsProfitUsersReportsProfitUsersGet(userType, page, pageSize, dateConductedFrom, dateConductedTo, sort, searchFilter, brandId, categoryId, subcategoryId, warehouseId, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportsProfitBrandsExportReportsProfitBrandsExportTypeGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGetRequest
 */
export interface ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * 
     * @type {DefaultProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly order?: DefaultProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitBrandsReportsProfitBrandsGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGetRequest
 */
export interface ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly warehouseId?: number

    /**
     * 
     * @type {DefaultProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly order?: DefaultProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitCountriesExportReportsProfitCountriesExportTypeGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGetRequest
 */
export interface ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * 
     * @type {DefaultProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly order?: DefaultProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitCountriesReportsProfitCountriesGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGetRequest
 */
export interface ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly warehouseId?: number

    /**
     * 
     * @type {DefaultProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly order?: DefaultProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGetRequest
 */
export interface ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {ProfitReportInvoicesType}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly invoicesType?: ProfitReportInvoicesType

    /**
     * 
     * @type {ProfitReportPaymentType}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly paymentType?: ProfitReportPaymentType

    /**
     * 
     * @type {NomenclatureProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly order?: NomenclatureProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitNomenclatureReportsProfitNomenclatureGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGetRequest
 */
export interface ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {ProfitReportInvoicesType}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly invoicesType?: ProfitReportInvoicesType

    /**
     * 
     * @type {ProfitReportPaymentType}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly paymentType?: ProfitReportPaymentType

    /**
     * 
     * @type {NomenclatureProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly order?: NomenclatureProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitUsersExportReportsProfitUsersExportTypeGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGetRequest
 */
export interface ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {ClientStaffAgentTypes}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly userType: ClientStaffAgentTypes

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * 
     * @type {DefaultProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly order?: DefaultProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsProfitUsersReportsProfitUsersGet operation in ProfitReportsApi.
 * @export
 * @interface ProfitReportsApiReportsProfitUsersReportsProfitUsersGetRequest
 */
export interface ProfitReportsApiReportsProfitUsersReportsProfitUsersGetRequest {
    /**
     * 
     * @type {ClientStaffAgentTypes}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly userType: ClientStaffAgentTypes

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly dateConductedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly dateConductedTo?: string

    /**
     * 
     * @type {BaseSort}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly brandId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly categoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly subcategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly warehouseId?: number

    /**
     * 
     * @type {DefaultProfitReportQueryOrder}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly order?: DefaultProfitReportQueryOrder

    /**
     * 
     * @type {string}
     * @memberof ProfitReportsApiReportsProfitUsersReportsProfitUsersGet
     */
    readonly acceptLanguage?: string
}

/**
 * ProfitReportsApi - object-oriented interface
 * @export
 * @class ProfitReportsApi
 * @extends {BaseAPI}
 */
export class ProfitReportsApi extends BaseAPI {
    /**
     * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export brands profit data.
     * @param {ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitBrandsExportReportsProfitBrandsExportTypeGet(requestParameters: ProfitReportsApiReportsProfitBrandsExportReportsProfitBrandsExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitBrandsExportReportsProfitBrandsExportTypeGet(requestParameters.exportType, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profit reports by brand.  Role check: is_staff Permission: reports_can_view
     * @summary Get profit brands by users
     * @param {ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitBrandsReportsProfitBrandsGet(requestParameters: ProfitReportsApiReportsProfitBrandsReportsProfitBrandsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitBrandsReportsProfitBrandsGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export countries profit data.
     * @param {ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitCountriesExportReportsProfitCountriesExportTypeGet(requestParameters: ProfitReportsApiReportsProfitCountriesExportReportsProfitCountriesExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitCountriesExportReportsProfitCountriesExportTypeGet(requestParameters.exportType, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profit reports by country.  Role check: is_staff Permission: reports_can_view
     * @summary Get profit countries by users
     * @param {ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitCountriesReportsProfitCountriesGet(requestParameters: ProfitReportsApiReportsProfitCountriesReportsProfitCountriesGetRequest = {}, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitCountriesReportsProfitCountriesGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export nomenclature profit data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export nomenclature profit data.
     * @param {ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet(requestParameters: ProfitReportsApiReportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitNomenclatureExportReportsProfitNomenclatureExportTypeGet(requestParameters.exportType, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.countryId, requestParameters.invoicesType, requestParameters.paymentType, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
     * @summary Get profit reports
     * @param {ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitNomenclatureReportsProfitNomenclatureGet(requestParameters: ProfitReportsApiReportsProfitNomenclatureReportsProfitNomenclatureGetRequest = {}, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitNomenclatureReportsProfitNomenclatureGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.countryId, requestParameters.invoicesType, requestParameters.paymentType, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export user profit data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export user profit data.
     * @param {ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitUsersExportReportsProfitUsersExportTypeGet(requestParameters: ProfitReportsApiReportsProfitUsersExportReportsProfitUsersExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitUsersExportReportsProfitUsersExportTypeGet(requestParameters.exportType, requestParameters.userType, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profit reports by nomenclature.  Role check: is_staff Permission: reports_can_view
     * @summary Get profit reports by users
     * @param {ProfitReportsApiReportsProfitUsersReportsProfitUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfitReportsApi
     */
    public reportsProfitUsersReportsProfitUsersGet(requestParameters: ProfitReportsApiReportsProfitUsersReportsProfitUsersGetRequest, options?: AxiosRequestConfig) {
        return ProfitReportsApiFp(this.configuration).reportsProfitUsersReportsProfitUsersGet(requestParameters.userType, requestParameters.page, requestParameters.pageSize, requestParameters.dateConductedFrom, requestParameters.dateConductedTo, requestParameters.sort, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProformasClientApi - axios parameter creator
 * @export
 */
export const ProformasClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change date payment for client proforma.
         * @param {number} proformaId 
         * @param {ProformaDatePaymentSchema} proformaDatePaymentSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut: async (proformaId: number, proformaDatePaymentSchema: ProformaDatePaymentSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut', 'proformaId', proformaId)
            // verify required parameter 'proformaDatePaymentSchema' is not null or undefined
            assertParamExists('proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut', 'proformaDatePaymentSchema', proformaDatePaymentSchema)
            const localVarPath = `/proformas/clients/{proforma_id}/change-date-payment/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proformaDatePaymentSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change client proforma status to \'created\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut: async (proformaId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut', 'proformaId', proformaId)
            const localVarPath = `/proformas/clients/{proforma_id}/change-to-created/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Create client proforma.
         * @param {number} orderId 
         * @param {CreateClientProformaSchema} createClientProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsCreateProformasClientsOrderIdPost: async (orderId: number, createClientProformaSchema: CreateClientProformaSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('proformasClientsCreateProformasClientsOrderIdPost', 'orderId', orderId)
            // verify required parameter 'createClientProformaSchema' is not null or undefined
            assertParamExists('proformasClientsCreateProformasClientsOrderIdPost', 'createClientProformaSchema', createClientProformaSchema)
            const localVarPath = `/proformas/clients/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientProformaSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change client proforma status to \'deleted\'.
         * @param {number} proformaId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsDeleteProformasClientsProformaIdDeletePut: async (proformaId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsDeleteProformasClientsProformaIdDeletePut', 'proformaId', proformaId)
            // verify required parameter 'baseCancellationSchema' is not null or undefined
            assertParamExists('proformasClientsDeleteProformasClientsProformaIdDeletePut', 'baseCancellationSchema', baseCancellationSchema)
            const localVarPath = `/proformas/clients/{proforma_id}/delete/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseCancellationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export proforma data.  Role check: is_staff  Permission: crm_view_client_proforma  accept-language header does not affect the document language. proforma.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} proformaId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsExportProformasClientsProformaIdExportTypeGet: async (proformaId: number, exportType: DataExportType, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsExportProformasClientsProformaIdExportTypeGet', 'proformaId', proformaId)
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('proformasClientsExportProformasClientsProformaIdExportTypeGet', 'exportType', exportType)
            const localVarPath = `/proformas/clients/{proforma_id}/{export_type}/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)))
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get proforma for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary Get client proforma.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsGetProformasClientsProformaIdGet: async (proformaId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsGetProformasClientsProformaIdGet', 'proformaId', proformaId)
            const localVarPath = `/proformas/clients/{proforma_id}/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary List client proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProformaLabels} [label] 
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsListProformasClientsGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProformaLabels, isCashPayment?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proformas/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary List client proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProformaLabels} [label] 
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsListSelectProformasClientsSelectGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProformaLabels, isCashPayment?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proformas/clients/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (clientType !== undefined) {
                localVarQueryParameter['clientType'] = clientType;
            }

            if (clientCategoryId !== undefined) {
                localVarQueryParameter['clientCategoryId'] = clientCategoryId;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (isCashPayment !== undefined) {
                localVarQueryParameter['isCashPayment'] = isCashPayment;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Submit client proforma for payment.
         * @param {number} proformaId 
         * @param {ProformaDatePaymentSchema} proformaDatePaymentSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut: async (proformaId: number, proformaDatePaymentSchema: ProformaDatePaymentSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut', 'proformaId', proformaId)
            // verify required parameter 'proformaDatePaymentSchema' is not null or undefined
            assertParamExists('proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut', 'proformaDatePaymentSchema', proformaDatePaymentSchema)
            const localVarPath = `/proformas/clients/{proforma_id}/submit-for-payment/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proformaDatePaymentSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Update client proforma.
         * @param {number} proformaId 
         * @param {UpdateClientProformaSchema} updateClientProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsUpdateProformasClientsProformaIdPut: async (proformaId: number, updateClientProformaSchema: UpdateClientProformaSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasClientsUpdateProformasClientsProformaIdPut', 'proformaId', proformaId)
            // verify required parameter 'updateClientProformaSchema' is not null or undefined
            assertParamExists('proformasClientsUpdateProformasClientsProformaIdPut', 'updateClientProformaSchema', updateClientProformaSchema)
            const localVarPath = `/proformas/clients/{proforma_id}/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClientProformaSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProformasClientApi - functional programming interface
 * @export
 */
export const ProformasClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProformasClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change date payment for client proforma.
         * @param {number} proformaId 
         * @param {ProformaDatePaymentSchema} proformaDatePaymentSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut(proformaId: number, proformaDatePaymentSchema: ProformaDatePaymentSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut(proformaId, proformaDatePaymentSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change client proforma status to \'created\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut(proformaId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut(proformaId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Create client proforma.
         * @param {number} orderId 
         * @param {CreateClientProformaSchema} createClientProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsCreateProformasClientsOrderIdPost(orderId: number, createClientProformaSchema: CreateClientProformaSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsCreateProformasClientsOrderIdPost(orderId, createClientProformaSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change client proforma status to \'deleted\'.
         * @param {number} proformaId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsDeleteProformasClientsProformaIdDeletePut(proformaId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsDeleteProformasClientsProformaIdDeletePut(proformaId, baseCancellationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export proforma data.  Role check: is_staff  Permission: crm_view_client_proforma  accept-language header does not affect the document language. proforma.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} proformaId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsExportProformasClientsProformaIdExportTypeGet(proformaId: number, exportType: DataExportType, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsExportProformasClientsProformaIdExportTypeGet(proformaId, exportType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get proforma for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary Get client proforma.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsGetProformasClientsProformaIdGet(proformaId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsGetProformasClientsProformaIdGet(proformaId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary List client proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProformaLabels} [label] 
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsListProformasClientsGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProformaLabels, isCashPayment?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsListProformasClientsGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, clientType, clientCategoryId, agentId, label, isCashPayment, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary List client proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProformaLabels} [label] 
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsListSelectProformasClientsSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProformaLabels, isCashPayment?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProformaSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsListSelectProformasClientsSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, clientType, clientCategoryId, agentId, label, isCashPayment, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Submit client proforma for payment.
         * @param {number} proformaId 
         * @param {ProformaDatePaymentSchema} proformaDatePaymentSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut(proformaId: number, proformaDatePaymentSchema: ProformaDatePaymentSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut(proformaId, proformaDatePaymentSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Update client proforma.
         * @param {number} proformaId 
         * @param {UpdateClientProformaSchema} updateClientProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasClientsUpdateProformasClientsProformaIdPut(proformaId: number, updateClientProformaSchema: UpdateClientProformaSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasClientsUpdateProformasClientsProformaIdPut(proformaId, updateClientProformaSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProformasClientApi - factory interface
 * @export
 */
export const ProformasClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProformasClientApiFp(configuration)
    return {
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change date payment for client proforma.
         * @param {number} proformaId 
         * @param {ProformaDatePaymentSchema} proformaDatePaymentSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut(proformaId: number, proformaDatePaymentSchema: ProformaDatePaymentSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut(proformaId, proformaDatePaymentSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change client proforma status to \'created\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut(proformaId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut(proformaId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Create client proforma.
         * @param {number} orderId 
         * @param {CreateClientProformaSchema} createClientProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsCreateProformasClientsOrderIdPost(orderId: number, createClientProformaSchema: CreateClientProformaSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsCreateProformasClientsOrderIdPost(orderId, createClientProformaSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Change client proforma status to \'deleted\'.
         * @param {number} proformaId 
         * @param {BaseCancellationSchema} baseCancellationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsDeleteProformasClientsProformaIdDeletePut(proformaId: number, baseCancellationSchema: BaseCancellationSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsDeleteProformasClientsProformaIdDeletePut(proformaId, baseCancellationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export proforma data.  Role check: is_staff  Permission: crm_view_client_proforma  accept-language header does not affect the document language. proforma.order.user.document_language is used for the export instead.
         * @summary Export client proforma data.
         * @param {number} proformaId 
         * @param {DataExportType} exportType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsExportProformasClientsProformaIdExportTypeGet(proformaId: number, exportType: DataExportType, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.proformasClientsExportProformasClientsProformaIdExportTypeGet(proformaId, exportType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get proforma for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary Get client proforma.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsGetProformasClientsProformaIdGet(proformaId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsGetProformasClientsProformaIdGet(proformaId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary List client proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProformaLabels} [label] 
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsListProformasClientsGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProformaLabels, isCashPayment?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaPage> {
            return localVarFp.proformasClientsListProformasClientsGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, clientType, clientCategoryId, agentId, label, isCashPayment, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
         * @summary List client proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {ClientTypes} [clientType] 
         * @param {number} [clientCategoryId] 
         * @param {string} [agentId] Agent id.
         * @param {ClientProformaLabels} [label] 
         * @param {boolean} [isCashPayment] Is cash payment.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsListSelectProformasClientsSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, clientType?: ClientTypes, clientCategoryId?: number, agentId?: string, label?: ClientProformaLabels, isCashPayment?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ProformaSimplePage> {
            return localVarFp.proformasClientsListSelectProformasClientsSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, clientType, clientCategoryId, agentId, label, isCashPayment, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Submit client proforma for payment.
         * @param {number} proformaId 
         * @param {ProformaDatePaymentSchema} proformaDatePaymentSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut(proformaId: number, proformaDatePaymentSchema: ProformaDatePaymentSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut(proformaId, proformaDatePaymentSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
         * @summary Update client proforma.
         * @param {number} proformaId 
         * @param {UpdateClientProformaSchema} updateClientProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasClientsUpdateProformasClientsProformaIdPut(proformaId: number, updateClientProformaSchema: UpdateClientProformaSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientProformaSchema> {
            return localVarFp.proformasClientsUpdateProformasClientsProformaIdPut(proformaId, updateClientProformaSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPutRequest
 */
export interface ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {ProformaDatePaymentSchema}
     * @memberof ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut
     */
    readonly proformaDatePaymentSchema: ProformaDatePaymentSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPutRequest
 */
export interface ProformasClientApiProformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsCreateProformasClientsOrderIdPost operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsCreateProformasClientsOrderIdPostRequest
 */
export interface ProformasClientApiProformasClientsCreateProformasClientsOrderIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsCreateProformasClientsOrderIdPost
     */
    readonly orderId: number

    /**
     * 
     * @type {CreateClientProformaSchema}
     * @memberof ProformasClientApiProformasClientsCreateProformasClientsOrderIdPost
     */
    readonly createClientProformaSchema: CreateClientProformaSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsCreateProformasClientsOrderIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsDeleteProformasClientsProformaIdDeletePut operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePutRequest
 */
export interface ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePut
     */
    readonly proformaId: number

    /**
     * 
     * @type {BaseCancellationSchema}
     * @memberof ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePut
     */
    readonly baseCancellationSchema: BaseCancellationSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsExportProformasClientsProformaIdExportTypeGet operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGetRequest
 */
export interface ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGet
     */
    readonly proformaId: number

    /**
     * 
     * @type {DataExportType}
     * @memberof ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsGetProformasClientsProformaIdGet operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsGetProformasClientsProformaIdGetRequest
 */
export interface ProformasClientApiProformasClientsGetProformasClientsProformaIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsGetProformasClientsProformaIdGet
     */
    readonly proformaId: number

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsGetProformasClientsProformaIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsListProformasClientsGet operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsListProformasClientsGetRequest
 */
export interface ProformasClientApiProformasClientsListProformasClientsGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly dateCreatedTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProformaQueryOrder}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly order?: ProformaQueryOrder

    /**
     * Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly currencyId?: number

    /**
     * Creator id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly responsibleId?: string

    /**
     * Statuses.
     * @type {Array<ProformaQueryStatuses>}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly statuses?: Array<ProformaQueryStatuses>

    /**
     * User id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly staffId?: string

    /**
     * 
     * @type {ClientTypes}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly clientCategoryId?: number

    /**
     * Agent id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientProformaLabels}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly label?: ClientProformaLabels

    /**
     * Is cash payment.
     * @type {boolean}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly isCashPayment?: boolean

    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListProformasClientsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsListSelectProformasClientsSelectGet operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsListSelectProformasClientsSelectGetRequest
 */
export interface ProformasClientApiProformasClientsListSelectProformasClientsSelectGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProformaQueryOrder}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly order?: ProformaQueryOrder

    /**
     * Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly currencyId?: number

    /**
     * Creator id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly responsibleId?: string

    /**
     * Statuses.
     * @type {Array<ProformaQueryStatuses>}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly statuses?: Array<ProformaQueryStatuses>

    /**
     * User id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly staffId?: string

    /**
     * 
     * @type {ClientTypes}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly clientType?: ClientTypes

    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly clientCategoryId?: number

    /**
     * Agent id.
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly agentId?: string

    /**
     * 
     * @type {ClientProformaLabels}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly label?: ClientProformaLabels

    /**
     * Is cash payment.
     * @type {boolean}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly isCashPayment?: boolean

    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsListSelectProformasClientsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPutRequest
 */
export interface ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {ProformaDatePaymentSchema}
     * @memberof ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut
     */
    readonly proformaDatePaymentSchema: ProformaDatePaymentSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasClientsUpdateProformasClientsProformaIdPut operation in ProformasClientApi.
 * @export
 * @interface ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPutRequest
 */
export interface ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {UpdateClientProformaSchema}
     * @memberof ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPut
     */
    readonly updateClientProformaSchema: UpdateClientProformaSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ProformasClientApi - object-oriented interface
 * @export
 * @class ProformasClientApi
 * @extends {BaseAPI}
 */
export class ProformasClientApi extends BaseAPI {
    /**
     * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
     * @summary Change date payment for client proforma.
     * @param {ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut(requestParameters: ProformasClientApiProformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPutRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsChangeDatePaymentProformasClientsProformaIdChangeDatePaymentPut(requestParameters.proformaId, requestParameters.proformaDatePaymentSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
     * @summary Change client proforma status to \'created\'.
     * @param {ProformasClientApiProformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut(requestParameters: ProformasClientApiProformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPutRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsChangeToCreatedProformasClientsProformaIdChangeToCreatedPut(requestParameters.proformaId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
     * @summary Create client proforma.
     * @param {ProformasClientApiProformasClientsCreateProformasClientsOrderIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsCreateProformasClientsOrderIdPost(requestParameters: ProformasClientApiProformasClientsCreateProformasClientsOrderIdPostRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsCreateProformasClientsOrderIdPost(requestParameters.orderId, requestParameters.createClientProformaSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: crm_change_client_proforma
     * @summary Change client proforma status to \'deleted\'.
     * @param {ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsDeleteProformasClientsProformaIdDeletePut(requestParameters: ProformasClientApiProformasClientsDeleteProformasClientsProformaIdDeletePutRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsDeleteProformasClientsProformaIdDeletePut(requestParameters.proformaId, requestParameters.baseCancellationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export proforma data.  Role check: is_staff  Permission: crm_view_client_proforma  accept-language header does not affect the document language. proforma.order.user.document_language is used for the export instead.
     * @summary Export client proforma data.
     * @param {ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsExportProformasClientsProformaIdExportTypeGet(requestParameters: ProformasClientApiProformasClientsExportProformasClientsProformaIdExportTypeGetRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsExportProformasClientsProformaIdExportTypeGet(requestParameters.proformaId, requestParameters.exportType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get proforma for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
     * @summary Get client proforma.
     * @param {ProformasClientApiProformasClientsGetProformasClientsProformaIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsGetProformasClientsProformaIdGet(requestParameters: ProformasClientApiProformasClientsGetProformasClientsProformaIdGetRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsGetProformasClientsProformaIdGet(requestParameters.proformaId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
     * @summary List client proformas.
     * @param {ProformasClientApiProformasClientsListProformasClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsListProformasClientsGet(requestParameters: ProformasClientApiProformasClientsListProformasClientsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsListProformasClientsGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.statuses, requestParameters.userId, requestParameters.staffId, requestParameters.clientType, requestParameters.clientCategoryId, requestParameters.agentId, requestParameters.label, requestParameters.isCashPayment, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List proformas for a client.  Role check: is_staff.  Permission: crm_view_client_proforma
     * @summary List client proformas.
     * @param {ProformasClientApiProformasClientsListSelectProformasClientsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsListSelectProformasClientsSelectGet(requestParameters: ProformasClientApiProformasClientsListSelectProformasClientsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsListSelectProformasClientsSelectGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.statuses, requestParameters.userId, requestParameters.staffId, requestParameters.clientType, requestParameters.clientCategoryId, requestParameters.agentId, requestParameters.label, requestParameters.isCashPayment, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit proforma for a client for payment.  Role check: is_staff.  Permission: crm_change_client_proforma
     * @summary Submit client proforma for payment.
     * @param {ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut(requestParameters: ProformasClientApiProformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPutRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsSubmitForPaymentProformasClientsProformaIdSubmitForPaymentPut(requestParameters.proformaId, requestParameters.proformaDatePaymentSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update proforma for a client.  Role check: is_staff.  Permission: crm_change_client_proforma
     * @summary Update client proforma.
     * @param {ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasClientApi
     */
    public proformasClientsUpdateProformasClientsProformaIdPut(requestParameters: ProformasClientApiProformasClientsUpdateProformasClientsProformaIdPutRequest, options?: AxiosRequestConfig) {
        return ProformasClientApiFp(this.configuration).proformasClientsUpdateProformasClientsProformaIdPut(requestParameters.proformaId, requestParameters.updateClientProformaSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProformasSupplierApi - axios parameter creator
 * @export
 */
export const ProformasSupplierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Change supplier proforma status to \'created\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut: async (proformaId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut', 'proformaId', proformaId)
            const localVarPath = `/proformas/suppliers/{proforma_id}/change-to-created/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Create supplier proforma.
         * @param {number} orderId 
         * @param {CreateSupplierProformaSchema} createSupplierProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersCreateProformasSuppliersOrderIdPost: async (orderId: number, createSupplierProformaSchema: CreateSupplierProformaSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('proformasSuppliersCreateProformasSuppliersOrderIdPost', 'orderId', orderId)
            // verify required parameter 'createSupplierProformaSchema' is not null or undefined
            assertParamExists('proformasSuppliersCreateProformasSuppliersOrderIdPost', 'createSupplierProformaSchema', createSupplierProformaSchema)
            const localVarPath = `/proformas/suppliers/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSupplierProformaSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Change supplier proforma status to \'deleted\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut: async (proformaId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut', 'proformaId', proformaId)
            const localVarPath = `/proformas/suppliers/{proforma_id}/delete/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get proforma for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary Get supplier proforma.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersGetProformasSuppliersProformaIdGet: async (proformaId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasSuppliersGetProformasSuppliersProformaIdGet', 'proformaId', proformaId)
            const localVarPath = `/proformas/suppliers/{proforma_id}/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary List supplier proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProformaLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersListProformasSuppliersGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, supplierCategoryId?: number, label?: SupplierProformaLabels, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proformas/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary List supplier proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProformaLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersListSelectProformasSuppliersSelectGet: async (counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, supplierCategoryId?: number, label?: SupplierProformaLabels, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proformas/suppliers/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (responsibleId !== undefined) {
                localVarQueryParameter['responsibleId'] = responsibleId;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (staffId !== undefined) {
                localVarQueryParameter['staffId'] = staffId;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Submit supplier proforma for payment.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut: async (proformaId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut', 'proformaId', proformaId)
            const localVarPath = `/proformas/suppliers/{proforma_id}/submit-for-payment/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Update supplier proforma.
         * @param {number} proformaId 
         * @param {UpdateSupplierProformaSchema} updateSupplierProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersUpdateProformasSuppliersProformaIdPut: async (proformaId: number, updateSupplierProformaSchema: UpdateSupplierProformaSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('proformasSuppliersUpdateProformasSuppliersProformaIdPut', 'proformaId', proformaId)
            // verify required parameter 'updateSupplierProformaSchema' is not null or undefined
            assertParamExists('proformasSuppliersUpdateProformasSuppliersProformaIdPut', 'updateSupplierProformaSchema', updateSupplierProformaSchema)
            const localVarPath = `/proformas/suppliers/{proforma_id}/`
                .replace(`{${"proforma_id"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSupplierProformaSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProformasSupplierApi - functional programming interface
 * @export
 */
export const ProformasSupplierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProformasSupplierApiAxiosParamCreator(configuration)
    return {
        /**
         * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Change supplier proforma status to \'created\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut(proformaId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut(proformaId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Create supplier proforma.
         * @param {number} orderId 
         * @param {CreateSupplierProformaSchema} createSupplierProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersCreateProformasSuppliersOrderIdPost(orderId: number, createSupplierProformaSchema: CreateSupplierProformaSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersCreateProformasSuppliersOrderIdPost(orderId, createSupplierProformaSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Change supplier proforma status to \'deleted\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut(proformaId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut(proformaId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get proforma for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary Get supplier proforma.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersGetProformasSuppliersProformaIdGet(proformaId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersGetProformasSuppliersProformaIdGet(proformaId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary List supplier proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProformaLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersListProformasSuppliersGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, supplierCategoryId?: number, label?: SupplierProformaLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersListProformasSuppliersGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, supplierCategoryId, label, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary List supplier proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProformaLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersListSelectProformasSuppliersSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, supplierCategoryId?: number, label?: SupplierProformaLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProformaSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersListSelectProformasSuppliersSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, supplierCategoryId, label, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Submit supplier proforma for payment.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut(proformaId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut(proformaId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Update supplier proforma.
         * @param {number} proformaId 
         * @param {UpdateSupplierProformaSchema} updateSupplierProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proformasSuppliersUpdateProformasSuppliersProformaIdPut(proformaId: number, updateSupplierProformaSchema: UpdateSupplierProformaSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierProformaSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proformasSuppliersUpdateProformasSuppliersProformaIdPut(proformaId, updateSupplierProformaSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProformasSupplierApi - factory interface
 * @export
 */
export const ProformasSupplierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProformasSupplierApiFp(configuration)
    return {
        /**
         * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Change supplier proforma status to \'created\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut(proformaId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaSchema> {
            return localVarFp.proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut(proformaId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Create supplier proforma.
         * @param {number} orderId 
         * @param {CreateSupplierProformaSchema} createSupplierProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersCreateProformasSuppliersOrderIdPost(orderId: number, createSupplierProformaSchema: CreateSupplierProformaSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaSchema> {
            return localVarFp.proformasSuppliersCreateProformasSuppliersOrderIdPost(orderId, createSupplierProformaSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Change supplier proforma status to \'deleted\'.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut(proformaId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaSchema> {
            return localVarFp.proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut(proformaId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get proforma for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary Get supplier proforma.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersGetProformasSuppliersProformaIdGet(proformaId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaSchema> {
            return localVarFp.proformasSuppliersGetProformasSuppliersProformaIdGet(proformaId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary List supplier proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProformaLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersListProformasSuppliersGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, supplierCategoryId?: number, label?: SupplierProformaLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaPage> {
            return localVarFp.proformasSuppliersListProformasSuppliersGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, supplierCategoryId, label, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
         * @summary List supplier proformas.
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {ProformaQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [searchFilter] Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
         * @param {string} [searchFilterSelect] Search filter by documentNumber
         * @param {number} [countryId] Country id.
         * @param {number} [currencyId] Currency id.
         * @param {string} [creatorId] Creator id.
         * @param {string} [responsibleId] Responsible id.
         * @param {Array<ProformaQueryStatuses>} [statuses] Statuses.
         * @param {string} [userId] User id.
         * @param {string} [staffId] Staff id.
         * @param {number} [supplierCategoryId] 
         * @param {SupplierProformaLabels} [label] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersListSelectProformasSuppliersSelectGet(counterAgentKind?: CounterAgentKinds, dateCreatedFrom?: string, dateCreatedTo?: string, sort?: BaseSort, order?: ProformaQueryOrder, searchFilter?: string, searchFilterSelect?: string, countryId?: number, currencyId?: number, creatorId?: string, responsibleId?: string, statuses?: Array<ProformaQueryStatuses>, userId?: string, staffId?: string, supplierCategoryId?: number, label?: SupplierProformaLabels, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ProformaSimplePage> {
            return localVarFp.proformasSuppliersListSelectProformasSuppliersSelectGet(counterAgentKind, dateCreatedFrom, dateCreatedTo, sort, order, searchFilter, searchFilterSelect, countryId, currencyId, creatorId, responsibleId, statuses, userId, staffId, supplierCategoryId, label, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Submit supplier proforma for payment.
         * @param {number} proformaId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut(proformaId: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaSchema> {
            return localVarFp.proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut(proformaId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
         * @summary Update supplier proforma.
         * @param {number} proformaId 
         * @param {UpdateSupplierProformaSchema} updateSupplierProformaSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proformasSuppliersUpdateProformasSuppliersProformaIdPut(proformaId: number, updateSupplierProformaSchema: UpdateSupplierProformaSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierProformaSchema> {
            return localVarFp.proformasSuppliersUpdateProformasSuppliersProformaIdPut(proformaId, updateSupplierProformaSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPutRequest
 */
export interface ProformasSupplierApiProformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersCreateProformasSuppliersOrderIdPost operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPostRequest
 */
export interface ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPost
     */
    readonly orderId: number

    /**
     * 
     * @type {CreateSupplierProformaSchema}
     * @memberof ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPost
     */
    readonly createSupplierProformaSchema: CreateSupplierProformaSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersDeleteProformasSuppliersProformaIdDeletePutRequest
 */
export interface ProformasSupplierApiProformasSuppliersDeleteProformasSuppliersProformaIdDeletePutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersDeleteProformasSuppliersProformaIdDeletePut
     */
    readonly proformaId: number

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersDeleteProformasSuppliersProformaIdDeletePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersGetProformasSuppliersProformaIdGet operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersGetProformasSuppliersProformaIdGetRequest
 */
export interface ProformasSupplierApiProformasSuppliersGetProformasSuppliersProformaIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersGetProformasSuppliersProformaIdGet
     */
    readonly proformaId: number

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersGetProformasSuppliersProformaIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersListProformasSuppliersGet operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersListProformasSuppliersGetRequest
 */
export interface ProformasSupplierApiProformasSuppliersListProformasSuppliersGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly dateCreatedTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProformaQueryOrder}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly order?: ProformaQueryOrder

    /**
     * Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly currencyId?: number

    /**
     * Creator id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly responsibleId?: string

    /**
     * Statuses.
     * @type {Array<ProformaQueryStatuses>}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly statuses?: Array<ProformaQueryStatuses>

    /**
     * User id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly staffId?: string

    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierProformaLabels}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly label?: SupplierProformaLabels

    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListProformasSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersListSelectProformasSuppliersSelectGet operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGetRequest
 */
export interface ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGetRequest {
    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * Date from.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {ProformaQueryOrder}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly order?: ProformaQueryOrder

    /**
     * Search by id, documentNumber(year, number, suffix), user(name, phone, vatNumber, registrationNumber) and by order name
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by documentNumber
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly countryId?: number

    /**
     * Currency id.
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly currencyId?: number

    /**
     * Creator id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly creatorId?: string

    /**
     * Responsible id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly responsibleId?: string

    /**
     * Statuses.
     * @type {Array<ProformaQueryStatuses>}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly statuses?: Array<ProformaQueryStatuses>

    /**
     * User id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly userId?: string

    /**
     * Staff id.
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly staffId?: string

    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierProformaLabels}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly label?: SupplierProformaLabels

    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPutRequest
 */
export interface ProformasSupplierApiProformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for proformasSuppliersUpdateProformasSuppliersProformaIdPut operation in ProformasSupplierApi.
 * @export
 * @interface ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPutRequest
 */
export interface ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPut
     */
    readonly proformaId: number

    /**
     * 
     * @type {UpdateSupplierProformaSchema}
     * @memberof ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPut
     */
    readonly updateSupplierProformaSchema: UpdateSupplierProformaSchema

    /**
     * 
     * @type {string}
     * @memberof ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * ProformasSupplierApi - object-oriented interface
 * @export
 * @class ProformasSupplierApi
 * @extends {BaseAPI}
 */
export class ProformasSupplierApi extends BaseAPI {
    /**
     * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
     * @summary Change supplier proforma status to \'created\'.
     * @param {ProformasSupplierApiProformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut(requestParameters: ProformasSupplierApiProformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPutRequest, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersChangeToCreatedProformasSuppliersProformaIdChangeToCreatedPut(requestParameters.proformaId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
     * @summary Create supplier proforma.
     * @param {ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersCreateProformasSuppliersOrderIdPost(requestParameters: ProformasSupplierApiProformasSuppliersCreateProformasSuppliersOrderIdPostRequest, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersCreateProformasSuppliersOrderIdPost(requestParameters.orderId, requestParameters.createSupplierProformaSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change proforma status to \'deleted\'.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
     * @summary Change supplier proforma status to \'deleted\'.
     * @param {ProformasSupplierApiProformasSuppliersDeleteProformasSuppliersProformaIdDeletePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut(requestParameters: ProformasSupplierApiProformasSuppliersDeleteProformasSuppliersProformaIdDeletePutRequest, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersDeleteProformasSuppliersProformaIdDeletePut(requestParameters.proformaId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get proforma for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
     * @summary Get supplier proforma.
     * @param {ProformasSupplierApiProformasSuppliersGetProformasSuppliersProformaIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersGetProformasSuppliersProformaIdGet(requestParameters: ProformasSupplierApiProformasSuppliersGetProformasSuppliersProformaIdGetRequest, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersGetProformasSuppliersProformaIdGet(requestParameters.proformaId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
     * @summary List supplier proformas.
     * @param {ProformasSupplierApiProformasSuppliersListProformasSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersListProformasSuppliersGet(requestParameters: ProformasSupplierApiProformasSuppliersListProformasSuppliersGetRequest = {}, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersListProformasSuppliersGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.statuses, requestParameters.userId, requestParameters.staffId, requestParameters.supplierCategoryId, requestParameters.label, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List proformas for a supplier.  Role check: is_staff.  Permission: warehouse_view_supplier_proforma
     * @summary List supplier proformas.
     * @param {ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersListSelectProformasSuppliersSelectGet(requestParameters: ProformasSupplierApiProformasSuppliersListSelectProformasSuppliersSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersListSelectProformasSuppliersSelectGet(requestParameters.counterAgentKind, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.currencyId, requestParameters.creatorId, requestParameters.responsibleId, requestParameters.statuses, requestParameters.userId, requestParameters.staffId, requestParameters.supplierCategoryId, requestParameters.label, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit proforma for a supplier for payment.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
     * @summary Submit supplier proforma for payment.
     * @param {ProformasSupplierApiProformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut(requestParameters: ProformasSupplierApiProformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPutRequest, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersSubmitForPaymentProformasSuppliersProformaIdSubmitForPaymentPut(requestParameters.proformaId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update proforma for a supplier.  Role check: is_staff.  Permission: warehouse_change_supplier_proforma
     * @summary Update supplier proforma.
     * @param {ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProformasSupplierApi
     */
    public proformasSuppliersUpdateProformasSuppliersProformaIdPut(requestParameters: ProformasSupplierApiProformasSuppliersUpdateProformasSuppliersProformaIdPutRequest, options?: AxiosRequestConfig) {
        return ProformasSupplierApiFp(this.configuration).proformasSuppliersUpdateProformasSuppliersProformaIdPut(requestParameters.proformaId, requestParameters.updateSupplierProformaSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelatedDocumentsApi - axios parameter creator
 * @export
 */
export const RelatedDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\")
         * @summary Get all related documents for selected document.
         * @param {number} documentId 
         * @param {RelatedDocumentTypes} documentType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedDocumentsListRelatedDocumentsDocumentIdGet: async (documentId: number, documentType: RelatedDocumentTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('relatedDocumentsListRelatedDocumentsDocumentIdGet', 'documentId', documentId)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('relatedDocumentsListRelatedDocumentsDocumentIdGet', 'documentType', documentType)
            const localVarPath = `/related-documents/{document_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentType !== undefined) {
                localVarQueryParameter['document_type'] = documentType;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelatedDocumentsApi - functional programming interface
 * @export
 */
export const RelatedDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelatedDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\")
         * @summary Get all related documents for selected document.
         * @param {number} documentId 
         * @param {RelatedDocumentTypes} documentType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async relatedDocumentsListRelatedDocumentsDocumentIdGet(documentId: number, documentType: RelatedDocumentTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RelatedDocumentListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.relatedDocumentsListRelatedDocumentsDocumentIdGet(documentId, documentType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelatedDocumentsApi - factory interface
 * @export
 */
export const RelatedDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelatedDocumentsApiFp(configuration)
    return {
        /**
         * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\")
         * @summary Get all related documents for selected document.
         * @param {number} documentId 
         * @param {RelatedDocumentTypes} documentType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedDocumentsListRelatedDocumentsDocumentIdGet(documentId: number, documentType: RelatedDocumentTypes, acceptLanguage?: string, options?: any): AxiosPromise<Array<RelatedDocumentListSchema>> {
            return localVarFp.relatedDocumentsListRelatedDocumentsDocumentIdGet(documentId, documentType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for relatedDocumentsListRelatedDocumentsDocumentIdGet operation in RelatedDocumentsApi.
 * @export
 * @interface RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGetRequest
 */
export interface RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGet
     */
    readonly documentId: number

    /**
     * 
     * @type {RelatedDocumentTypes}
     * @memberof RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGet
     */
    readonly documentType: RelatedDocumentTypes

    /**
     * 
     * @type {string}
     * @memberof RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * RelatedDocumentsApi - object-oriented interface
 * @export
 * @class RelatedDocumentsApi
 * @extends {BaseAPI}
 */
export class RelatedDocumentsApi extends BaseAPI {
    /**
     * Get payment order list for selected object.  For example, get payment order list for client order: use object_id=client_order_id, object_type=\"client_order\".  Role check: is_staff.  Permissions needed: Client Order(\"crm_view_client_order\") | Supplier Order(\"warehouse_view_supplier_order\") | Client Invoice(\"crm_view_client_invoice\") | Supplier Invoice(\"warehouse_view_supplier_invoice\") | Client Proforma(\"crm_view_client_proforma\") | Supplier Proforma(\"warehouse_view_supplier_proforma\") | Client Product Return(\"crm_view_client_returns\") | Supplier Product Return(\"warehouse_view_supplier_returns\")
     * @summary Get all related documents for selected document.
     * @param {RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatedDocumentsApi
     */
    public relatedDocumentsListRelatedDocumentsDocumentIdGet(requestParameters: RelatedDocumentsApiRelatedDocumentsListRelatedDocumentsDocumentIdGetRequest, options?: AxiosRequestConfig) {
        return RelatedDocumentsApiFp(this.configuration).relatedDocumentsListRelatedDocumentsDocumentIdGet(requestParameters.documentId, requestParameters.documentType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequisitesApi - axios parameter creator
 * @export
 */
export const RequisitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get auto modern requisites.  Returns list of auto modern requisites for EN, RU, SL languages.  Role check: is_staff.  Permission: auto_modern_requisite_view.
         * @summary List of auto modern requisite.
         * @param {RequisiteQueryType} [type] 
         * @param {string} [userId] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitesListRequisitesGet: async (type?: RequisiteQueryType, userId?: string, searchFilterSelect?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requisites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update auto_modern_requisite_change.  Role check: is_staff.  Permission: auto_modern_requisite_change.
         * @summary Update auto modern requisite.
         * @param {AutoModernRequisiteMultipleUpdateSchema} autoModernRequisiteMultipleUpdateSchema 
         * @param {RequisiteQueryType} [type] 
         * @param {string} [userId] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitesUpdateRequisitesPut: async (autoModernRequisiteMultipleUpdateSchema: AutoModernRequisiteMultipleUpdateSchema, type?: RequisiteQueryType, userId?: string, searchFilterSelect?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoModernRequisiteMultipleUpdateSchema' is not null or undefined
            assertParamExists('requisitesUpdateRequisitesPut', 'autoModernRequisiteMultipleUpdateSchema', autoModernRequisiteMultipleUpdateSchema)
            const localVarPath = `/requisites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoModernRequisiteMultipleUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequisitesApi - functional programming interface
 * @export
 */
export const RequisitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequisitesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get auto modern requisites.  Returns list of auto modern requisites for EN, RU, SL languages.  Role check: is_staff.  Permission: auto_modern_requisite_view.
         * @summary List of auto modern requisite.
         * @param {RequisiteQueryType} [type] 
         * @param {string} [userId] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requisitesListRequisitesGet(type?: RequisiteQueryType, userId?: string, searchFilterSelect?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoModernRequisiteListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requisitesListRequisitesGet(type, userId, searchFilterSelect, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update auto_modern_requisite_change.  Role check: is_staff.  Permission: auto_modern_requisite_change.
         * @summary Update auto modern requisite.
         * @param {AutoModernRequisiteMultipleUpdateSchema} autoModernRequisiteMultipleUpdateSchema 
         * @param {RequisiteQueryType} [type] 
         * @param {string} [userId] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requisitesUpdateRequisitesPut(autoModernRequisiteMultipleUpdateSchema: AutoModernRequisiteMultipleUpdateSchema, type?: RequisiteQueryType, userId?: string, searchFilterSelect?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoModernRequisiteListSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requisitesUpdateRequisitesPut(autoModernRequisiteMultipleUpdateSchema, type, userId, searchFilterSelect, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequisitesApi - factory interface
 * @export
 */
export const RequisitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequisitesApiFp(configuration)
    return {
        /**
         * Get auto modern requisites.  Returns list of auto modern requisites for EN, RU, SL languages.  Role check: is_staff.  Permission: auto_modern_requisite_view.
         * @summary List of auto modern requisite.
         * @param {RequisiteQueryType} [type] 
         * @param {string} [userId] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitesListRequisitesGet(type?: RequisiteQueryType, userId?: string, searchFilterSelect?: string, acceptLanguage?: string, options?: any): AxiosPromise<Array<AutoModernRequisiteListSchema>> {
            return localVarFp.requisitesListRequisitesGet(type, userId, searchFilterSelect, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update auto_modern_requisite_change.  Role check: is_staff.  Permission: auto_modern_requisite_change.
         * @summary Update auto modern requisite.
         * @param {AutoModernRequisiteMultipleUpdateSchema} autoModernRequisiteMultipleUpdateSchema 
         * @param {RequisiteQueryType} [type] 
         * @param {string} [userId] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitesUpdateRequisitesPut(autoModernRequisiteMultipleUpdateSchema: AutoModernRequisiteMultipleUpdateSchema, type?: RequisiteQueryType, userId?: string, searchFilterSelect?: string, acceptLanguage?: string, options?: any): AxiosPromise<Array<AutoModernRequisiteListSchema>> {
            return localVarFp.requisitesUpdateRequisitesPut(autoModernRequisiteMultipleUpdateSchema, type, userId, searchFilterSelect, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for requisitesListRequisitesGet operation in RequisitesApi.
 * @export
 * @interface RequisitesApiRequisitesListRequisitesGetRequest
 */
export interface RequisitesApiRequisitesListRequisitesGetRequest {
    /**
     * 
     * @type {RequisiteQueryType}
     * @memberof RequisitesApiRequisitesListRequisitesGet
     */
    readonly type?: RequisiteQueryType

    /**
     * 
     * @type {string}
     * @memberof RequisitesApiRequisitesListRequisitesGet
     */
    readonly userId?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof RequisitesApiRequisitesListRequisitesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {string}
     * @memberof RequisitesApiRequisitesListRequisitesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for requisitesUpdateRequisitesPut operation in RequisitesApi.
 * @export
 * @interface RequisitesApiRequisitesUpdateRequisitesPutRequest
 */
export interface RequisitesApiRequisitesUpdateRequisitesPutRequest {
    /**
     * 
     * @type {AutoModernRequisiteMultipleUpdateSchema}
     * @memberof RequisitesApiRequisitesUpdateRequisitesPut
     */
    readonly autoModernRequisiteMultipleUpdateSchema: AutoModernRequisiteMultipleUpdateSchema

    /**
     * 
     * @type {RequisiteQueryType}
     * @memberof RequisitesApiRequisitesUpdateRequisitesPut
     */
    readonly type?: RequisiteQueryType

    /**
     * 
     * @type {string}
     * @memberof RequisitesApiRequisitesUpdateRequisitesPut
     */
    readonly userId?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof RequisitesApiRequisitesUpdateRequisitesPut
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {string}
     * @memberof RequisitesApiRequisitesUpdateRequisitesPut
     */
    readonly acceptLanguage?: string
}

/**
 * RequisitesApi - object-oriented interface
 * @export
 * @class RequisitesApi
 * @extends {BaseAPI}
 */
export class RequisitesApi extends BaseAPI {
    /**
     * Get auto modern requisites.  Returns list of auto modern requisites for EN, RU, SL languages.  Role check: is_staff.  Permission: auto_modern_requisite_view.
     * @summary List of auto modern requisite.
     * @param {RequisitesApiRequisitesListRequisitesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequisitesApi
     */
    public requisitesListRequisitesGet(requestParameters: RequisitesApiRequisitesListRequisitesGetRequest = {}, options?: AxiosRequestConfig) {
        return RequisitesApiFp(this.configuration).requisitesListRequisitesGet(requestParameters.type, requestParameters.userId, requestParameters.searchFilterSelect, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update auto_modern_requisite_change.  Role check: is_staff.  Permission: auto_modern_requisite_change.
     * @summary Update auto modern requisite.
     * @param {RequisitesApiRequisitesUpdateRequisitesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequisitesApi
     */
    public requisitesUpdateRequisitesPut(requestParameters: RequisitesApiRequisitesUpdateRequisitesPutRequest, options?: AxiosRequestConfig) {
        return RequisitesApiFp(this.configuration).requisitesUpdateRequisitesPut(requestParameters.autoModernRequisiteMultipleUpdateSchema, requestParameters.type, requestParameters.userId, requestParameters.searchFilterSelect, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsBankAccountsAndCashboxesApi - axios parameter creator
 * @export
 */
export const SettingsBankAccountsAndCashboxesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new bank account or cashbox in Settings.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
         * @summary Create new bank account or cashbox
         * @param {AccountCashboxCreateSchema} accountCashboxCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost: async (accountCashboxCreateSchema: AccountCashboxCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountCashboxCreateSchema' is not null or undefined
            assertParamExists('accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost', 'accountCashboxCreateSchema', accountCashboxCreateSchema)
            const localVarPath = `/settings/bank-accounts-and-cashboxes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCashboxCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete bank account or cashbox from Settings.  Perms needed: \'account_cashbox_change\'.  Role needed: \'is_staff\'.
         * @summary Delete bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete: async (itemId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete', 'itemId', itemId)
            const localVarPath = `/settings/bank-accounts-and-cashboxes/{item_id}/`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {number} [currencyId] 
         * @param {boolean} [isCashbox] 
         * @param {number} [contractId] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet: async (sort?: BaseSort, order?: AccountCashboxQueryOrder, isActive?: boolean, currencyId?: number, isCashbox?: boolean, contractId?: number, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/bank-accounts-and-cashboxes/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (isCashbox !== undefined) {
                localVarQueryParameter['isCashbox'] = isCashbox;
            }

            if (contractId !== undefined) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {number} [currencyId] 
         * @param {boolean} [isCashbox] 
         * @param {number} [contractId] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet: async (sort?: BaseSort, order?: AccountCashboxQueryOrder, isActive?: boolean, currencyId?: number, isCashbox?: boolean, contractId?: number, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/bank-accounts-and-cashboxes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (isCashbox !== undefined) {
                localVarQueryParameter['isCashbox'] = isCashbox;
            }

            if (contractId !== undefined) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet: async (itemId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet', 'itemId', itemId)
            const localVarPath = `/settings/bank-accounts-and-cashboxes/{item_id}/select/`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet: async (itemId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet', 'itemId', itemId)
            const localVarPath = `/settings/bank-accounts-and-cashboxes/{item_id}/`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current bank accounts and cashboxes from Settings for payment orders page.  Use isCashbox param to filter by cashbox or bank account.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes for payment orders
         * @param {boolean} [isCashbox] 
         * @param {boolean} [isActive] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet: async (isCashbox?: boolean, isActive?: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/bank-accounts-and-cashboxes/payment-orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCashbox !== undefined) {
                localVarQueryParameter['isCashbox'] = isCashbox;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update bank account or cashbox.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
         * @summary Update bank account or cashbox
         * @param {number} itemId 
         * @param {AccountCashboxUpdateSchema} accountCashboxUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut: async (itemId: number, accountCashboxUpdateSchema: AccountCashboxUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut', 'itemId', itemId)
            // verify required parameter 'accountCashboxUpdateSchema' is not null or undefined
            assertParamExists('accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut', 'accountCashboxUpdateSchema', accountCashboxUpdateSchema)
            const localVarPath = `/settings/bank-accounts-and-cashboxes/{item_id}/`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCashboxUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsBankAccountsAndCashboxesApi - functional programming interface
 * @export
 */
export const SettingsBankAccountsAndCashboxesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsBankAccountsAndCashboxesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new bank account or cashbox in Settings.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
         * @summary Create new bank account or cashbox
         * @param {AccountCashboxCreateSchema} accountCashboxCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost(accountCashboxCreateSchema: AccountCashboxCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCashboxDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost(accountCashboxCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete bank account or cashbox from Settings.  Perms needed: \'account_cashbox_change\'.  Role needed: \'is_staff\'.
         * @summary Delete bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete(itemId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete(itemId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {number} [currencyId] 
         * @param {boolean} [isCashbox] 
         * @param {number} [contractId] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet(sort?: BaseSort, order?: AccountCashboxQueryOrder, isActive?: boolean, currencyId?: number, isCashbox?: boolean, contractId?: number, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectAccountsCashboxesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet(sort, order, isActive, currencyId, isCashbox, contractId, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {number} [currencyId] 
         * @param {boolean} [isCashbox] 
         * @param {number} [contractId] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet(sort?: BaseSort, order?: AccountCashboxQueryOrder, isActive?: boolean, currencyId?: number, isCashbox?: boolean, contractId?: number, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsCashboxesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet(sort, order, isActive, currencyId, isCashbox, contractId, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet(itemId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCashboxComplexSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet(itemId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet(itemId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCashboxDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet(itemId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current bank accounts and cashboxes from Settings for payment orders page.  Use isCashbox param to filter by cashbox or bank account.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes for payment orders
         * @param {boolean} [isCashbox] 
         * @param {boolean} [isActive] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet(isCashbox?: boolean, isActive?: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountCashboxComplexSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet(isCashbox, isActive, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update bank account or cashbox.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
         * @summary Update bank account or cashbox
         * @param {number} itemId 
         * @param {AccountCashboxUpdateSchema} accountCashboxUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut(itemId: number, accountCashboxUpdateSchema: AccountCashboxUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCashboxDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut(itemId, accountCashboxUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsBankAccountsAndCashboxesApi - factory interface
 * @export
 */
export const SettingsBankAccountsAndCashboxesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsBankAccountsAndCashboxesApiFp(configuration)
    return {
        /**
         * Create new bank account or cashbox in Settings.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
         * @summary Create new bank account or cashbox
         * @param {AccountCashboxCreateSchema} accountCashboxCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost(accountCashboxCreateSchema: AccountCashboxCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<AccountCashboxDetailSchema> {
            return localVarFp.accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost(accountCashboxCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete bank account or cashbox from Settings.  Perms needed: \'account_cashbox_change\'.  Role needed: \'is_staff\'.
         * @summary Delete bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete(itemId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete(itemId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {number} [currencyId] 
         * @param {boolean} [isCashbox] 
         * @param {number} [contractId] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet(sort?: BaseSort, order?: AccountCashboxQueryOrder, isActive?: boolean, currencyId?: number, isCashbox?: boolean, contractId?: number, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectAccountsCashboxesPage> {
            return localVarFp.accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet(sort, order, isActive, currencyId, isCashbox, contractId, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes
         * @param {BaseSort} [sort] 
         * @param {AccountCashboxQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {number} [currencyId] 
         * @param {boolean} [isCashbox] 
         * @param {number} [contractId] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet(sort?: BaseSort, order?: AccountCashboxQueryOrder, isActive?: boolean, currencyId?: number, isCashbox?: boolean, contractId?: number, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<AccountsCashboxesPage> {
            return localVarFp.accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet(sort, order, isActive, currencyId, isCashbox, contractId, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet(itemId: number, acceptLanguage?: string, options?: any): AxiosPromise<AccountCashboxComplexSchema> {
            return localVarFp.accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet(itemId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get bank account or cashbox
         * @param {number} itemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet(itemId: number, acceptLanguage?: string, options?: any): AxiosPromise<AccountCashboxDetailSchema> {
            return localVarFp.accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet(itemId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current bank accounts and cashboxes from Settings for payment orders page.  Use isCashbox param to filter by cashbox or bank account.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
         * @summary Get all bank accounts and cashboxes for payment orders
         * @param {boolean} [isCashbox] 
         * @param {boolean} [isActive] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet(isCashbox?: boolean, isActive?: boolean, acceptLanguage?: string, options?: any): AxiosPromise<Array<AccountCashboxComplexSchema>> {
            return localVarFp.accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet(isCashbox, isActive, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update bank account or cashbox.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
         * @summary Update bank account or cashbox
         * @param {number} itemId 
         * @param {AccountCashboxUpdateSchema} accountCashboxUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut(itemId: number, accountCashboxUpdateSchema: AccountCashboxUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<AccountCashboxDetailSchema> {
            return localVarFp.accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut(itemId, accountCashboxUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPostRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPostRequest {
    /**
     * 
     * @type {AccountCashboxCreateSchema}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost
     */
    readonly accountCashboxCreateSchema: AccountCashboxCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDeleteRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete
     */
    readonly itemId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGetRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {AccountCashboxQueryOrder}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly order?: AccountCashboxQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly isCashbox?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly contractId?: number

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGetRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {AccountCashboxQueryOrder}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly order?: AccountCashboxQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly isCashbox?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly contractId?: number

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGetRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet
     */
    readonly itemId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGetRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet
     */
    readonly itemId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGetRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGetRequest {
    /**
     * 
     * @type {boolean}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet
     */
    readonly isCashbox?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut operation in SettingsBankAccountsAndCashboxesApi.
 * @export
 * @interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPutRequest
 */
export interface SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut
     */
    readonly itemId: number

    /**
     * 
     * @type {AccountCashboxUpdateSchema}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut
     */
    readonly accountCashboxUpdateSchema: AccountCashboxUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsBankAccountsAndCashboxesApi - object-oriented interface
 * @export
 * @class SettingsBankAccountsAndCashboxesApi
 * @extends {BaseAPI}
 */
export class SettingsBankAccountsAndCashboxesApi extends BaseAPI {
    /**
     * Create new bank account or cashbox in Settings.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
     * @summary Create new bank account or cashbox
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPostRequest, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesCreateOneSettingsBankAccountsAndCashboxesPost(requestParameters.accountCashboxCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete bank account or cashbox from Settings.  Perms needed: \'account_cashbox_change\'.  Role needed: \'is_staff\'.
     * @summary Delete bank account or cashbox
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesDeleteOneSettingsBankAccountsAndCashboxesItemIdDelete(requestParameters.itemId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
     * @summary Get all bank accounts and cashboxes
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesGetAllSelectSettingsBankAccountsAndCashboxesSelectGet(requestParameters.sort, requestParameters.order, requestParameters.isActive, requestParameters.currencyId, requestParameters.isCashbox, requestParameters.contractId, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current bank accounts and cashboxes from Settings.  Pagination, ordering(desc date_created) by column is used.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
     * @summary Get all bank accounts and cashboxes
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetAllSettingsBankAccountsAndCashboxesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesGetAllSettingsBankAccountsAndCashboxesGet(requestParameters.sort, requestParameters.order, requestParameters.isActive, requestParameters.currencyId, requestParameters.isCashbox, requestParameters.contractId, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
     * @summary Get bank account or cashbox
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesGetOneSelectSettingsBankAccountsAndCashboxesItemIdSelectGet(requestParameters.itemId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bank account or cashbox detail.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
     * @summary Get bank account or cashbox
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesGetOneSettingsBankAccountsAndCashboxesItemIdGet(requestParameters.itemId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current bank accounts and cashboxes from Settings for payment orders page.  Use isCashbox param to filter by cashbox or bank account.  Perms needed: \'account_cashbox_view\'.  Role needed: \'is_staff\'.
     * @summary Get all bank accounts and cashboxes for payment orders
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesPaymentOrdersGetAllSettingsBankAccountsAndCashboxesPaymentOrdersGet(requestParameters.isCashbox, requestParameters.isActive, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update bank account or cashbox.  Perms needed: \'account_cashbox_change\'.  IBAN example: GB33BUKB20201555555555.  SWIFT example: AAAABBCC123.  Role needed: \'is_staff\'.
     * @summary Update bank account or cashbox
     * @param {SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBankAccountsAndCashboxesApi
     */
    public accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut(requestParameters: SettingsBankAccountsAndCashboxesApiAccountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsBankAccountsAndCashboxesApiFp(this.configuration).accountsCashboxesUpdateOneSettingsBankAccountsAndCashboxesItemIdPut(requestParameters.itemId, requestParameters.accountCashboxUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsBrandsApi - axios parameter creator
 * @export
 */
export const SettingsBrandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new brand. The brand name must be unique within the brands.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Create brand
         * @param {BrandCreateSchema} brandCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsCreateOneSettingsBrandsPost: async (brandCreateSchema: BrandCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandCreateSchema' is not null or undefined
            assertParamExists('brandsCreateOneSettingsBrandsPost', 'brandCreateSchema', brandCreateSchema)
            const localVarPath = `/settings/brands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(brandCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete brand.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Delete brand
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsDeleteOneSettingsBrandsBrandIdDelete: async (brandId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('brandsDeleteOneSettingsBrandsBrandIdDelete', 'brandId', brandId)
            const localVarPath = `/settings/brands/{brand_id}/`
                .replace(`{${"brand_id"}}`, encodeURIComponent(String(brandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get all brands
         * @param {BaseSort} [sort] 
         * @param {BrandQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {boolean} [hasReferences] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetAllSelectSettingsBrandsSelectGet: async (sort?: BaseSort, order?: BrandQueryOrder, isActive?: boolean, hasReferences?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/brands/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (hasReferences !== undefined) {
                localVarQueryParameter['hasReferences'] = hasReferences;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get all brands
         * @param {BaseSort} [sort] 
         * @param {BrandQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {boolean} [hasReferences] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetAllSettingsBrandsGet: async (sort?: BaseSort, order?: BrandQueryOrder, isActive?: boolean, hasReferences?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/brands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (hasReferences !== undefined) {
                localVarQueryParameter['hasReferences'] = hasReferences;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get brand detail
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetOneSelectSettingsBrandsBrandIdSelectGet: async (brandId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('brandsGetOneSelectSettingsBrandsBrandIdSelectGet', 'brandId', brandId)
            const localVarPath = `/settings/brands/{brand_id}/select/`
                .replace(`{${"brand_id"}}`, encodeURIComponent(String(brandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get brand detail
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetOneSettingsBrandsBrandIdGet: async (brandId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('brandsGetOneSettingsBrandsBrandIdGet', 'brandId', brandId)
            const localVarPath = `/settings/brands/{brand_id}/`
                .replace(`{${"brand_id"}}`, encodeURIComponent(String(brandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update brand: status, name.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Update brand
         * @param {number} brandId 
         * @param {BrandUpdateSchema} brandUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsUpdateOneSettingsBrandsBrandIdPut: async (brandId: number, brandUpdateSchema: BrandUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('brandsUpdateOneSettingsBrandsBrandIdPut', 'brandId', brandId)
            // verify required parameter 'brandUpdateSchema' is not null or undefined
            assertParamExists('brandsUpdateOneSettingsBrandsBrandIdPut', 'brandUpdateSchema', brandUpdateSchema)
            const localVarPath = `/settings/brands/{brand_id}/`
                .replace(`{${"brand_id"}}`, encodeURIComponent(String(brandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(brandUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsBrandsApi - functional programming interface
 * @export
 */
export const SettingsBrandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsBrandsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new brand. The brand name must be unique within the brands.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Create brand
         * @param {BrandCreateSchema} brandCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsCreateOneSettingsBrandsPost(brandCreateSchema: BrandCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsCreateOneSettingsBrandsPost(brandCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete brand.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Delete brand
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsDeleteOneSettingsBrandsBrandIdDelete(brandId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsDeleteOneSettingsBrandsBrandIdDelete(brandId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get all brands
         * @param {BaseSort} [sort] 
         * @param {BrandQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {boolean} [hasReferences] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsGetAllSelectSettingsBrandsSelectGet(sort?: BaseSort, order?: BrandQueryOrder, isActive?: boolean, hasReferences?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectBrandsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsGetAllSelectSettingsBrandsSelectGet(sort, order, isActive, hasReferences, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get all brands
         * @param {BaseSort} [sort] 
         * @param {BrandQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {boolean} [hasReferences] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsGetAllSettingsBrandsGet(sort?: BaseSort, order?: BrandQueryOrder, isActive?: boolean, hasReferences?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsGetAllSettingsBrandsGet(sort, order, isActive, hasReferences, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get brand detail
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsGetOneSelectSettingsBrandsBrandIdSelectGet(brandId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectBrandSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsGetOneSelectSettingsBrandsBrandIdSelectGet(brandId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get brand detail
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsGetOneSettingsBrandsBrandIdGet(brandId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsGetOneSettingsBrandsBrandIdGet(brandId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update brand: status, name.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Update brand
         * @param {number} brandId 
         * @param {BrandUpdateSchema} brandUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brandsUpdateOneSettingsBrandsBrandIdPut(brandId: number, brandUpdateSchema: BrandUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brandsUpdateOneSettingsBrandsBrandIdPut(brandId, brandUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsBrandsApi - factory interface
 * @export
 */
export const SettingsBrandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsBrandsApiFp(configuration)
    return {
        /**
         * Create new brand. The brand name must be unique within the brands.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Create brand
         * @param {BrandCreateSchema} brandCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsCreateOneSettingsBrandsPost(brandCreateSchema: BrandCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<BrandSchema> {
            return localVarFp.brandsCreateOneSettingsBrandsPost(brandCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete brand.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Delete brand
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsDeleteOneSettingsBrandsBrandIdDelete(brandId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.brandsDeleteOneSettingsBrandsBrandIdDelete(brandId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get all brands
         * @param {BaseSort} [sort] 
         * @param {BrandQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {boolean} [hasReferences] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetAllSelectSettingsBrandsSelectGet(sort?: BaseSort, order?: BrandQueryOrder, isActive?: boolean, hasReferences?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectBrandsPage> {
            return localVarFp.brandsGetAllSelectSettingsBrandsSelectGet(sort, order, isActive, hasReferences, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get all brands
         * @param {BaseSort} [sort] 
         * @param {BrandQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {boolean} [hasReferences] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetAllSettingsBrandsGet(sort?: BaseSort, order?: BrandQueryOrder, isActive?: boolean, hasReferences?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<BrandsPage> {
            return localVarFp.brandsGetAllSettingsBrandsGet(sort, order, isActive, hasReferences, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get brand detail
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetOneSelectSettingsBrandsBrandIdSelectGet(brandId: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectBrandSchema> {
            return localVarFp.brandsGetOneSelectSettingsBrandsBrandIdSelectGet(brandId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
         * @summary Get brand detail
         * @param {number} brandId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsGetOneSettingsBrandsBrandIdGet(brandId: number, acceptLanguage?: string, options?: any): AxiosPromise<BrandDetailSchema> {
            return localVarFp.brandsGetOneSettingsBrandsBrandIdGet(brandId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update brand: status, name.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
         * @summary Update brand
         * @param {number} brandId 
         * @param {BrandUpdateSchema} brandUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brandsUpdateOneSettingsBrandsBrandIdPut(brandId: number, brandUpdateSchema: BrandUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<BrandSchema> {
            return localVarFp.brandsUpdateOneSettingsBrandsBrandIdPut(brandId, brandUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for brandsCreateOneSettingsBrandsPost operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsCreateOneSettingsBrandsPostRequest
 */
export interface SettingsBrandsApiBrandsCreateOneSettingsBrandsPostRequest {
    /**
     * 
     * @type {BrandCreateSchema}
     * @memberof SettingsBrandsApiBrandsCreateOneSettingsBrandsPost
     */
    readonly brandCreateSchema: BrandCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsCreateOneSettingsBrandsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for brandsDeleteOneSettingsBrandsBrandIdDelete operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsDeleteOneSettingsBrandsBrandIdDeleteRequest
 */
export interface SettingsBrandsApiBrandsDeleteOneSettingsBrandsBrandIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsDeleteOneSettingsBrandsBrandIdDelete
     */
    readonly brandId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsDeleteOneSettingsBrandsBrandIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for brandsGetAllSelectSettingsBrandsSelectGet operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGetRequest
 */
export interface SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {BrandQueryOrder}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly order?: BrandQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly hasReferences?: boolean

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for brandsGetAllSettingsBrandsGet operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsGetAllSettingsBrandsGetRequest
 */
export interface SettingsBrandsApiBrandsGetAllSettingsBrandsGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {BrandQueryOrder}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly order?: BrandQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly hasReferences?: boolean

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsGetAllSettingsBrandsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for brandsGetOneSelectSettingsBrandsBrandIdSelectGet operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsGetOneSelectSettingsBrandsBrandIdSelectGetRequest
 */
export interface SettingsBrandsApiBrandsGetOneSelectSettingsBrandsBrandIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsGetOneSelectSettingsBrandsBrandIdSelectGet
     */
    readonly brandId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsGetOneSelectSettingsBrandsBrandIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for brandsGetOneSettingsBrandsBrandIdGet operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsGetOneSettingsBrandsBrandIdGetRequest
 */
export interface SettingsBrandsApiBrandsGetOneSettingsBrandsBrandIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsGetOneSettingsBrandsBrandIdGet
     */
    readonly brandId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsGetOneSettingsBrandsBrandIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for brandsUpdateOneSettingsBrandsBrandIdPut operation in SettingsBrandsApi.
 * @export
 * @interface SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPutRequest
 */
export interface SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPut
     */
    readonly brandId: number

    /**
     * 
     * @type {BrandUpdateSchema}
     * @memberof SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPut
     */
    readonly brandUpdateSchema: BrandUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsBrandsApi - object-oriented interface
 * @export
 * @class SettingsBrandsApi
 * @extends {BaseAPI}
 */
export class SettingsBrandsApi extends BaseAPI {
    /**
     * Create new brand. The brand name must be unique within the brands.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
     * @summary Create brand
     * @param {SettingsBrandsApiBrandsCreateOneSettingsBrandsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsCreateOneSettingsBrandsPost(requestParameters: SettingsBrandsApiBrandsCreateOneSettingsBrandsPostRequest, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsCreateOneSettingsBrandsPost(requestParameters.brandCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete brand.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
     * @summary Delete brand
     * @param {SettingsBrandsApiBrandsDeleteOneSettingsBrandsBrandIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsDeleteOneSettingsBrandsBrandIdDelete(requestParameters: SettingsBrandsApiBrandsDeleteOneSettingsBrandsBrandIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsDeleteOneSettingsBrandsBrandIdDelete(requestParameters.brandId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
     * @summary Get all brands
     * @param {SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsGetAllSelectSettingsBrandsSelectGet(requestParameters: SettingsBrandsApiBrandsGetAllSelectSettingsBrandsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsGetAllSelectSettingsBrandsSelectGet(requestParameters.sort, requestParameters.order, requestParameters.isActive, requestParameters.hasReferences, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current brands from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
     * @summary Get all brands
     * @param {SettingsBrandsApiBrandsGetAllSettingsBrandsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsGetAllSettingsBrandsGet(requestParameters: SettingsBrandsApiBrandsGetAllSettingsBrandsGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsGetAllSettingsBrandsGet(requestParameters.sort, requestParameters.order, requestParameters.isActive, requestParameters.hasReferences, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
     * @summary Get brand detail
     * @param {SettingsBrandsApiBrandsGetOneSelectSettingsBrandsBrandIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsGetOneSelectSettingsBrandsBrandIdSelectGet(requestParameters: SettingsBrandsApiBrandsGetOneSelectSettingsBrandsBrandIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsGetOneSelectSettingsBrandsBrandIdSelectGet(requestParameters.brandId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get brand detail.  Perms needed: \'brand_view\'.  Role needed: \'is_staff\'.
     * @summary Get brand detail
     * @param {SettingsBrandsApiBrandsGetOneSettingsBrandsBrandIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsGetOneSettingsBrandsBrandIdGet(requestParameters: SettingsBrandsApiBrandsGetOneSettingsBrandsBrandIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsGetOneSettingsBrandsBrandIdGet(requestParameters.brandId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update brand: status, name.  Perms needed: \'brand_view, brand_change\'.  Role needed: \'is_staff\'.
     * @summary Update brand
     * @param {SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsBrandsApi
     */
    public brandsUpdateOneSettingsBrandsBrandIdPut(requestParameters: SettingsBrandsApiBrandsUpdateOneSettingsBrandsBrandIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsBrandsApiFp(this.configuration).brandsUpdateOneSettingsBrandsBrandIdPut(requestParameters.brandId, requestParameters.brandUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsCancellationReasonGroupsApi - axios parameter creator
 * @export
 */
export const SettingsCancellationReasonGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get only ACTIVE cancellation reason group by cancellation_reason_group_type.  Role check: is_staff.  No permissions needed.  design: https://app.moqups.com/MJDIuwBEjnBdAwjTEWq41JshacWaNYew/edit/page/a6806189f
         * @summary Get ACTIVE cancellation reason group by type.
         * @param {CancellationReasonGroupTypes} cancellationReasonGroupType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet: async (cancellationReasonGroupType: CancellationReasonGroupTypes, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancellationReasonGroupType' is not null or undefined
            assertParamExists('settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet', 'cancellationReasonGroupType', cancellationReasonGroupType)
            const localVarPath = `/settings/cancellation-reason-group/{cancellation_reason_group_type}/select/`
                .replace(`{${"cancellation_reason_group_type"}}`, encodeURIComponent(String(cancellationReasonGroupType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cancellation reason group.  Role check: is_staff.  Permission: cancellation_reason_group_view.
         * @summary Get cancellation reason group.
         * @param {number} cancellationReasonGroupId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet: async (cancellationReasonGroupId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancellationReasonGroupId' is not null or undefined
            assertParamExists('settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet', 'cancellationReasonGroupId', cancellationReasonGroupId)
            const localVarPath = `/settings/cancellation-reason-group/{cancellation_reason_group_id}/`
                .replace(`{${"cancellation_reason_group_id"}}`, encodeURIComponent(String(cancellationReasonGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all cancellation reasons group from Settings.  Role needed: \'is_staff\'.  No perms needed.
         * @summary List all cancellation reasons for select
         * @param {CancellationReasonGroupQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet: async (order?: CancellationReasonGroupQueryOrder, sort?: BaseSort, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/cancellation-reason-group/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update cancellation reason group.  Cancellation reasons inside the group should have unique names.  Perms needed: \'cancellation_reason_group_change\'.  Role needed: \'is_staff\'.
         * @summary Get cancellation reason group.
         * @param {number} cancellationReasonGroupId 
         * @param {CancellationReasonGroupUpdateSchema} cancellationReasonGroupUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut: async (cancellationReasonGroupId: number, cancellationReasonGroupUpdateSchema: CancellationReasonGroupUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancellationReasonGroupId' is not null or undefined
            assertParamExists('settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut', 'cancellationReasonGroupId', cancellationReasonGroupId)
            // verify required parameter 'cancellationReasonGroupUpdateSchema' is not null or undefined
            assertParamExists('settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut', 'cancellationReasonGroupUpdateSchema', cancellationReasonGroupUpdateSchema)
            const localVarPath = `/settings/cancellation-reason-group/{cancellation_reason_group_id}/`
                .replace(`{${"cancellation_reason_group_id"}}`, encodeURIComponent(String(cancellationReasonGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancellationReasonGroupUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsCancellationReasonGroupsApi - functional programming interface
 * @export
 */
export const SettingsCancellationReasonGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsCancellationReasonGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get only ACTIVE cancellation reason group by cancellation_reason_group_type.  Role check: is_staff.  No permissions needed.  design: https://app.moqups.com/MJDIuwBEjnBdAwjTEWq41JshacWaNYew/edit/page/a6806189f
         * @summary Get ACTIVE cancellation reason group by type.
         * @param {CancellationReasonGroupTypes} cancellationReasonGroupType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet(cancellationReasonGroupType: CancellationReasonGroupTypes, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CancellationReasonSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet(cancellationReasonGroupType, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get cancellation reason group.  Role check: is_staff.  Permission: cancellation_reason_group_view.
         * @summary Get cancellation reason group.
         * @param {number} cancellationReasonGroupId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet(cancellationReasonGroupId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancellationReasonGroupDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet(cancellationReasonGroupId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all cancellation reasons group from Settings.  Role needed: \'is_staff\'.  No perms needed.
         * @summary List all cancellation reasons for select
         * @param {CancellationReasonGroupQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet(order?: CancellationReasonGroupQueryOrder, sort?: BaseSort, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancellationReasonGroupPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet(order, sort, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update cancellation reason group.  Cancellation reasons inside the group should have unique names.  Perms needed: \'cancellation_reason_group_change\'.  Role needed: \'is_staff\'.
         * @summary Get cancellation reason group.
         * @param {number} cancellationReasonGroupId 
         * @param {CancellationReasonGroupUpdateSchema} cancellationReasonGroupUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut(cancellationReasonGroupId: number, cancellationReasonGroupUpdateSchema: CancellationReasonGroupUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancellationReasonGroupDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut(cancellationReasonGroupId, cancellationReasonGroupUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsCancellationReasonGroupsApi - factory interface
 * @export
 */
export const SettingsCancellationReasonGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsCancellationReasonGroupsApiFp(configuration)
    return {
        /**
         * Get only ACTIVE cancellation reason group by cancellation_reason_group_type.  Role check: is_staff.  No permissions needed.  design: https://app.moqups.com/MJDIuwBEjnBdAwjTEWq41JshacWaNYew/edit/page/a6806189f
         * @summary Get ACTIVE cancellation reason group by type.
         * @param {CancellationReasonGroupTypes} cancellationReasonGroupType 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet(cancellationReasonGroupType: CancellationReasonGroupTypes, acceptLanguage?: string, options?: any): AxiosPromise<Array<CancellationReasonSchema>> {
            return localVarFp.settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet(cancellationReasonGroupType, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get cancellation reason group.  Role check: is_staff.  Permission: cancellation_reason_group_view.
         * @summary Get cancellation reason group.
         * @param {number} cancellationReasonGroupId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet(cancellationReasonGroupId: number, acceptLanguage?: string, options?: any): AxiosPromise<CancellationReasonGroupDetailSchema> {
            return localVarFp.settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet(cancellationReasonGroupId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all cancellation reasons group from Settings.  Role needed: \'is_staff\'.  No perms needed.
         * @summary List all cancellation reasons for select
         * @param {CancellationReasonGroupQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet(order?: CancellationReasonGroupQueryOrder, sort?: BaseSort, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<CancellationReasonGroupPage> {
            return localVarFp.settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet(order, sort, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update cancellation reason group.  Cancellation reasons inside the group should have unique names.  Perms needed: \'cancellation_reason_group_change\'.  Role needed: \'is_staff\'.
         * @summary Get cancellation reason group.
         * @param {number} cancellationReasonGroupId 
         * @param {CancellationReasonGroupUpdateSchema} cancellationReasonGroupUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut(cancellationReasonGroupId: number, cancellationReasonGroupUpdateSchema: CancellationReasonGroupUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<CancellationReasonGroupDetailSchema> {
            return localVarFp.settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut(cancellationReasonGroupId, cancellationReasonGroupUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet operation in SettingsCancellationReasonGroupsApi.
 * @export
 * @interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGetRequest
 */
export interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGetRequest {
    /**
     * 
     * @type {CancellationReasonGroupTypes}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet
     */
    readonly cancellationReasonGroupType: CancellationReasonGroupTypes

    /**
     * 
     * @type {string}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet operation in SettingsCancellationReasonGroupsApi.
 * @export
 * @interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGetRequest
 */
export interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet
     */
    readonly cancellationReasonGroupId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet operation in SettingsCancellationReasonGroupsApi.
 * @export
 * @interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGetRequest
 */
export interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGetRequest {
    /**
     * 
     * @type {CancellationReasonGroupQueryOrder}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet
     */
    readonly order?: CancellationReasonGroupQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {number}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut operation in SettingsCancellationReasonGroupsApi.
 * @export
 * @interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPutRequest
 */
export interface SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut
     */
    readonly cancellationReasonGroupId: number

    /**
     * 
     * @type {CancellationReasonGroupUpdateSchema}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut
     */
    readonly cancellationReasonGroupUpdateSchema: CancellationReasonGroupUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsCancellationReasonGroupsApi - object-oriented interface
 * @export
 * @class SettingsCancellationReasonGroupsApi
 * @extends {BaseAPI}
 */
export class SettingsCancellationReasonGroupsApi extends BaseAPI {
    /**
     * Get only ACTIVE cancellation reason group by cancellation_reason_group_type.  Role check: is_staff.  No permissions needed.  design: https://app.moqups.com/MJDIuwBEjnBdAwjTEWq41JshacWaNYew/edit/page/a6806189f
     * @summary Get ACTIVE cancellation reason group by type.
     * @param {SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCancellationReasonGroupsApi
     */
    public settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet(requestParameters: SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsCancellationReasonGroupsApiFp(this.configuration).settingsDormantsCancellationReasonGroupGetByTypeSettingsCancellationReasonGroupCancellationReasonGroupTypeSelectGet(requestParameters.cancellationReasonGroupType, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get cancellation reason group.  Role check: is_staff.  Permission: cancellation_reason_group_view.
     * @summary Get cancellation reason group.
     * @param {SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCancellationReasonGroupsApi
     */
    public settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet(requestParameters: SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsCancellationReasonGroupsApiFp(this.configuration).settingsDormantsCancellationReasonGroupGetSettingsCancellationReasonGroupCancellationReasonGroupIdGet(requestParameters.cancellationReasonGroupId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all cancellation reasons group from Settings.  Role needed: \'is_staff\'.  No perms needed.
     * @summary List all cancellation reasons for select
     * @param {SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCancellationReasonGroupsApi
     */
    public settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet(requestParameters: SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsCancellationReasonGroupsApiFp(this.configuration).settingsDormantsCancellationReasonGroupListSelectSettingsCancellationReasonGroupGet(requestParameters.order, requestParameters.sort, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update cancellation reason group.  Cancellation reasons inside the group should have unique names.  Perms needed: \'cancellation_reason_group_change\'.  Role needed: \'is_staff\'.
     * @summary Get cancellation reason group.
     * @param {SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCancellationReasonGroupsApi
     */
    public settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut(requestParameters: SettingsCancellationReasonGroupsApiSettingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsCancellationReasonGroupsApiFp(this.configuration).settingsDormantsCancellationReasonGroupUpdateSettingsCancellationReasonGroupCancellationReasonGroupIdPut(requestParameters.cancellationReasonGroupId, requestParameters.cancellationReasonGroupUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsClientCategoriesApi - axios parameter creator
 * @export
 */
export const SettingsClientCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create client category. Role check: is_staff. Permission: client_category_change.
         * @summary Create client category.
         * @param {UserCategoryCreateSchema} userCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost: async (userCategoryCreateSchema: UserCategoryCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryCreateSchema' is not null or undefined
            assertParamExists('settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost', 'userCategoryCreateSchema', userCategoryCreateSchema)
            const localVarPath = `/settings/user-categories/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCategoryCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete client category. Role check: is_staff. Permission: client_category_change.
         * @summary Delete client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete: async (userCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete', 'userCategoryId', userCategoryId)
            const localVarPath = `/settings/user-categories/client/{user_category_id}/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client category. Role check: is_staff. Permission: client_category_view.
         * @summary Get client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet: async (userCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet', 'userCategoryId', userCategoryId)
            const localVarPath = `/settings/user-categories/client/{user_category_id}/select/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client category. Role check: is_staff. Permission: client_category_view.
         * @summary Get client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet: async (userCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet', 'userCategoryId', userCategoryId)
            const localVarPath = `/settings/user-categories/client/{user_category_id}/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of client categories. Role check: is_staff. Permission: client_category_view.
         * @summary List of client categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet: async (searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/user-categories/client/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of client categories. Role check: is_staff. Permission: client_category_view.
         * @summary List of client categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet: async (searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/user-categories/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client category. Role check: is_staff. Permission: client_category_change.
         * @summary Update client category.
         * @param {number} userCategoryId 
         * @param {UserCategoryUpdateSchema} userCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut: async (userCategoryId: number, userCategoryUpdateSchema: UserCategoryUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut', 'userCategoryId', userCategoryId)
            // verify required parameter 'userCategoryUpdateSchema' is not null or undefined
            assertParamExists('settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut', 'userCategoryUpdateSchema', userCategoryUpdateSchema)
            const localVarPath = `/settings/user-categories/client/{user_category_id}/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCategoryUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsClientCategoriesApi - functional programming interface
 * @export
 */
export const SettingsClientCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsClientCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create client category. Role check: is_staff. Permission: client_category_change.
         * @summary Create client category.
         * @param {UserCategoryCreateSchema} userCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost(userCategoryCreateSchema: UserCategoryCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost(userCategoryCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete client category. Role check: is_staff. Permission: client_category_change.
         * @summary Delete client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete(userCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete(userCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client category. Role check: is_staff. Permission: client_category_view.
         * @summary Get client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet(userCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleUserCategoryReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet(userCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client category. Role check: is_staff. Permission: client_category_view.
         * @summary Get client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet(userCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet(userCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of client categories. Role check: is_staff. Permission: client_category_view.
         * @summary List of client categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of client categories. Role check: is_staff. Permission: client_category_view.
         * @summary List of client categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client category. Role check: is_staff. Permission: client_category_change.
         * @summary Update client category.
         * @param {number} userCategoryId 
         * @param {UserCategoryUpdateSchema} userCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut(userCategoryId: number, userCategoryUpdateSchema: UserCategoryUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut(userCategoryId, userCategoryUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsClientCategoriesApi - factory interface
 * @export
 */
export const SettingsClientCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsClientCategoriesApiFp(configuration)
    return {
        /**
         * Create client category. Role check: is_staff. Permission: client_category_change.
         * @summary Create client category.
         * @param {UserCategoryCreateSchema} userCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost(userCategoryCreateSchema: UserCategoryCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryDetailSchema> {
            return localVarFp.settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost(userCategoryCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete client category. Role check: is_staff. Permission: client_category_change.
         * @summary Delete client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete(userCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete(userCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client category. Role check: is_staff. Permission: client_category_view.
         * @summary Get client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet(userCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<SimpleUserCategoryReadSchema> {
            return localVarFp.settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet(userCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client category. Role check: is_staff. Permission: client_category_view.
         * @summary Get client category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet(userCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryDetailSchema> {
            return localVarFp.settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet(userCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List of client categories. Role check: is_staff. Permission: client_category_view.
         * @summary List of client categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryPage> {
            return localVarFp.settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List of client categories. Role check: is_staff. Permission: client_category_view.
         * @summary List of client categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryPage> {
            return localVarFp.settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client category. Role check: is_staff. Permission: client_category_change.
         * @summary Update client category.
         * @param {number} userCategoryId 
         * @param {UserCategoryUpdateSchema} userCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut(userCategoryId: number, userCategoryUpdateSchema: UserCategoryUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryDetailSchema> {
            return localVarFp.settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut(userCategoryId, userCategoryUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPostRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPostRequest {
    /**
     * 
     * @type {UserCategoryCreateSchema}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost
     */
    readonly userCategoryCreateSchema: UserCategoryCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDeleteRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGetRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGetRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGetRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGetRequest {
    /**
     * Search user categories by name.
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {CategoryQueryOrder}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly order?: CategoryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGetRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGetRequest {
    /**
     * Search user categories by name.
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {CategoryQueryOrder}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly order?: CategoryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut operation in SettingsClientCategoriesApi.
 * @export
 * @interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPutRequest
 */
export interface SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {UserCategoryUpdateSchema}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut
     */
    readonly userCategoryUpdateSchema: UserCategoryUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsClientCategoriesApi - object-oriented interface
 * @export
 * @class SettingsClientCategoriesApi
 * @extends {BaseAPI}
 */
export class SettingsClientCategoriesApi extends BaseAPI {
    /**
     * Create client category. Role check: is_staff. Permission: client_category_change.
     * @summary Create client category.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPostRequest, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesCreateSettingsUserCategoriesClientPost(requestParameters.userCategoryCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete client category. Role check: is_staff. Permission: client_category_change.
     * @summary Delete client category.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesDeleteSettingsUserCategoriesClientUserCategoryIdDelete(requestParameters.userCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client category. Role check: is_staff. Permission: client_category_view.
     * @summary Get client category.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesGetSelectSettingsUserCategoriesClientUserCategoryIdSelectGet(requestParameters.userCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client category. Role check: is_staff. Permission: client_category_view.
     * @summary Get client category.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesGetSettingsUserCategoriesClientUserCategoryIdGet(requestParameters.userCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of client categories. Role check: is_staff. Permission: client_category_view.
     * @summary List of client categories.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesListSelectSettingsUserCategoriesClientSelectGet(requestParameters.searchFilter, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of client categories. Role check: is_staff. Permission: client_category_view.
     * @summary List of client categories.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesListSettingsUserCategoriesClientGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesListSettingsUserCategoriesClientGet(requestParameters.searchFilter, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client category. Role check: is_staff. Permission: client_category_change.
     * @summary Update client category.
     * @param {SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientCategoriesApi
     */
    public settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut(requestParameters: SettingsClientCategoriesApiSettingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsClientCategoriesApiFp(this.configuration).settingsCategoriesClientCategoriesUpdateSettingsUserCategoriesClientUserCategoryIdPut(requestParameters.userCategoryId, requestParameters.userCategoryUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsClientSourcesApi - axios parameter creator
 * @export
 */
export const SettingsClientSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Create client_source.
         * @param {ClientSourceCreateSchema} clientSourceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesCreateSettingsClientSourcesPost: async (clientSourceCreateSchema: ClientSourceCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientSourceCreateSchema' is not null or undefined
            assertParamExists('settingsDormantsClientSourcesCreateSettingsClientSourcesPost', 'clientSourceCreateSchema', clientSourceCreateSchema)
            const localVarPath = `/settings/client-sources/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientSourceCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Delete client_source.
         * @param {number} clientSourceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete: async (clientSourceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientSourceId' is not null or undefined
            assertParamExists('settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete', 'clientSourceId', clientSourceId)
            const localVarPath = `/settings/client-sources/{client_source_id}/`
                .replace(`{${"client_source_id"}}`, encodeURIComponent(String(clientSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client_source.  Role check: is_staff.  Permission: client_source_view.
         * @summary Get client_source.
         * @param {number} clientSourceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet: async (clientSourceId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientSourceId' is not null or undefined
            assertParamExists('settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet', 'clientSourceId', clientSourceId)
            const localVarPath = `/settings/client-sources/{client_source_id}/`
                .replace(`{${"client_source_id"}}`, encodeURIComponent(String(clientSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get client_source for select.  Role check: is_staff.  No permission required.
         * @summary List of client_sources for select
         * @param {ClientSourceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesListSelectSettingsClientSourcesGet: async (order?: ClientSourceQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/client-sources/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Update client_source.
         * @param {number} clientSourceId 
         * @param {ClientSourceUpdateSchema} clientSourceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut: async (clientSourceId: number, clientSourceUpdateSchema: ClientSourceUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientSourceId' is not null or undefined
            assertParamExists('settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut', 'clientSourceId', clientSourceId)
            // verify required parameter 'clientSourceUpdateSchema' is not null or undefined
            assertParamExists('settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut', 'clientSourceUpdateSchema', clientSourceUpdateSchema)
            const localVarPath = `/settings/client-sources/{client_source_id}/`
                .replace(`{${"client_source_id"}}`, encodeURIComponent(String(clientSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientSourceUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsClientSourcesApi - functional programming interface
 * @export
 */
export const SettingsClientSourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsClientSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Create client_source.
         * @param {ClientSourceCreateSchema} clientSourceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsClientSourcesCreateSettingsClientSourcesPost(clientSourceCreateSchema: ClientSourceCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSourceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsClientSourcesCreateSettingsClientSourcesPost(clientSourceCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Delete client_source.
         * @param {number} clientSourceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete(clientSourceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete(clientSourceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client_source.  Role check: is_staff.  Permission: client_source_view.
         * @summary Get client_source.
         * @param {number} clientSourceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet(clientSourceId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSourceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet(clientSourceId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get client_source for select.  Role check: is_staff.  No permission required.
         * @summary List of client_sources for select
         * @param {ClientSourceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsClientSourcesListSelectSettingsClientSourcesGet(order?: ClientSourceQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSourcePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsClientSourcesListSelectSettingsClientSourcesGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Update client_source.
         * @param {number} clientSourceId 
         * @param {ClientSourceUpdateSchema} clientSourceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut(clientSourceId: number, clientSourceUpdateSchema: ClientSourceUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientSourceDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut(clientSourceId, clientSourceUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsClientSourcesApi - factory interface
 * @export
 */
export const SettingsClientSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsClientSourcesApiFp(configuration)
    return {
        /**
         * Create client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Create client_source.
         * @param {ClientSourceCreateSchema} clientSourceCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesCreateSettingsClientSourcesPost(clientSourceCreateSchema: ClientSourceCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSourceDetailSchema> {
            return localVarFp.settingsDormantsClientSourcesCreateSettingsClientSourcesPost(clientSourceCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Delete client_source.
         * @param {number} clientSourceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete(clientSourceId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete(clientSourceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client_source.  Role check: is_staff.  Permission: client_source_view.
         * @summary Get client_source.
         * @param {number} clientSourceId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet(clientSourceId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientSourceDetailSchema> {
            return localVarFp.settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet(clientSourceId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get client_source for select.  Role check: is_staff.  No permission required.
         * @summary List of client_sources for select
         * @param {ClientSourceQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesListSelectSettingsClientSourcesGet(order?: ClientSourceQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientSourcePage> {
            return localVarFp.settingsDormantsClientSourcesListSelectSettingsClientSourcesGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update client_source.  Role check: is_staff.  Permission: client_source_change.
         * @summary Update client_source.
         * @param {number} clientSourceId 
         * @param {ClientSourceUpdateSchema} clientSourceUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut(clientSourceId: number, clientSourceUpdateSchema: ClientSourceUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<ClientSourceDetailSchema> {
            return localVarFp.settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut(clientSourceId, clientSourceUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsDormantsClientSourcesCreateSettingsClientSourcesPost operation in SettingsClientSourcesApi.
 * @export
 * @interface SettingsClientSourcesApiSettingsDormantsClientSourcesCreateSettingsClientSourcesPostRequest
 */
export interface SettingsClientSourcesApiSettingsDormantsClientSourcesCreateSettingsClientSourcesPostRequest {
    /**
     * 
     * @type {ClientSourceCreateSchema}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesCreateSettingsClientSourcesPost
     */
    readonly clientSourceCreateSchema: ClientSourceCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesCreateSettingsClientSourcesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete operation in SettingsClientSourcesApi.
 * @export
 * @interface SettingsClientSourcesApiSettingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDeleteRequest
 */
export interface SettingsClientSourcesApiSettingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete
     */
    readonly clientSourceId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet operation in SettingsClientSourcesApi.
 * @export
 * @interface SettingsClientSourcesApiSettingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGetRequest
 */
export interface SettingsClientSourcesApiSettingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet
     */
    readonly clientSourceId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsClientSourcesListSelectSettingsClientSourcesGet operation in SettingsClientSourcesApi.
 * @export
 * @interface SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGetRequest
 */
export interface SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGetRequest {
    /**
     * 
     * @type {ClientSourceQueryOrder}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly order?: ClientSourceQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut operation in SettingsClientSourcesApi.
 * @export
 * @interface SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPutRequest
 */
export interface SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut
     */
    readonly clientSourceId: number

    /**
     * 
     * @type {ClientSourceUpdateSchema}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut
     */
    readonly clientSourceUpdateSchema: ClientSourceUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsClientSourcesApi - object-oriented interface
 * @export
 * @class SettingsClientSourcesApi
 * @extends {BaseAPI}
 */
export class SettingsClientSourcesApi extends BaseAPI {
    /**
     * Create client_source.  Role check: is_staff.  Permission: client_source_change.
     * @summary Create client_source.
     * @param {SettingsClientSourcesApiSettingsDormantsClientSourcesCreateSettingsClientSourcesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientSourcesApi
     */
    public settingsDormantsClientSourcesCreateSettingsClientSourcesPost(requestParameters: SettingsClientSourcesApiSettingsDormantsClientSourcesCreateSettingsClientSourcesPostRequest, options?: AxiosRequestConfig) {
        return SettingsClientSourcesApiFp(this.configuration).settingsDormantsClientSourcesCreateSettingsClientSourcesPost(requestParameters.clientSourceCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete client_source.  Role check: is_staff.  Permission: client_source_change.
     * @summary Delete client_source.
     * @param {SettingsClientSourcesApiSettingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientSourcesApi
     */
    public settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete(requestParameters: SettingsClientSourcesApiSettingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsClientSourcesApiFp(this.configuration).settingsDormantsClientSourcesDeleteSettingsClientSourcesClientSourceIdDelete(requestParameters.clientSourceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client_source.  Role check: is_staff.  Permission: client_source_view.
     * @summary Get client_source.
     * @param {SettingsClientSourcesApiSettingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientSourcesApi
     */
    public settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet(requestParameters: SettingsClientSourcesApiSettingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsClientSourcesApiFp(this.configuration).settingsDormantsClientSourcesGetSettingsClientSourcesClientSourceIdGet(requestParameters.clientSourceId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get client_source for select.  Role check: is_staff.  No permission required.
     * @summary List of client_sources for select
     * @param {SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientSourcesApi
     */
    public settingsDormantsClientSourcesListSelectSettingsClientSourcesGet(requestParameters: SettingsClientSourcesApiSettingsDormantsClientSourcesListSelectSettingsClientSourcesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsClientSourcesApiFp(this.configuration).settingsDormantsClientSourcesListSelectSettingsClientSourcesGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update client_source.  Role check: is_staff.  Permission: client_source_change.
     * @summary Update client_source.
     * @param {SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsClientSourcesApi
     */
    public settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut(requestParameters: SettingsClientSourcesApiSettingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsClientSourcesApiFp(this.configuration).settingsDormantsClientSourcesUpdateSettingsClientSourcesClientSourceIdPut(requestParameters.clientSourceId, requestParameters.clientSourceUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsCountriesApi - axios parameter creator
 * @export
 */
export const SettingsCountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all current countries from Settings for register page.  Pagination and filtering by names is used.
         * @summary Get all countries for register page
         * @param {string} [searchFilter] Search by name.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetAllRegisterSettingsCountriesRegisterGet: async (searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/countries/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get all countries
         * @param {CountryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {CountryEUQueryFilter} [euFilter] 
         * @param {string} [searchFilter] Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
         * @param {string} [searchFilterSelect] Search by name. Only one search filter is allowed.
         * @param {boolean} [isActive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetAllSelectSettingsCountriesSelectGet: async (order?: CountryQueryOrder, sort?: BaseSort, euFilter?: CountryEUQueryFilter, searchFilter?: string, searchFilterSelect?: string, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/countries/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (euFilter !== undefined) {
                localVarQueryParameter['euFilter'] = euFilter;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get all countries
         * @param {CountryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {CountryEUQueryFilter} [euFilter] 
         * @param {string} [searchFilter] Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
         * @param {string} [searchFilterSelect] Search by name. Only one search filter is allowed.
         * @param {boolean} [isActive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetAllSettingsCountriesGet: async (order?: CountryQueryOrder, sort?: BaseSort, euFilter?: CountryEUQueryFilter, searchFilter?: string, searchFilterSelect?: string, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (euFilter !== undefined) {
                localVarQueryParameter['euFilter'] = euFilter;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get country detail
         * @param {number} countryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetOneSelectSettingsCountriesCountryIdSelectGet: async (countryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('countriesGetOneSelectSettingsCountriesCountryIdSelectGet', 'countryId', countryId)
            const localVarPath = `/settings/countries/{country_id}/select/`
                .replace(`{${"country_id"}}`, encodeURIComponent(String(countryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get country detail
         * @param {number} countryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetOneSettingsCountriesCountryIdGet: async (countryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('countriesGetOneSettingsCountriesCountryIdGet', 'countryId', countryId)
            const localVarPath = `/settings/countries/{country_id}/`
                .replace(`{${"country_id"}}`, encodeURIComponent(String(countryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update country status.  Perms needed: \'country_view, country_change\'.  Role needed: \'is_staff\'.
         * @summary Update country
         * @param {number} countryId 
         * @param {CountryUpdateSchema} countryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesUpdateOneSettingsCountriesCountryIdPut: async (countryId: number, countryUpdateSchema: CountryUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('countriesUpdateOneSettingsCountriesCountryIdPut', 'countryId', countryId)
            // verify required parameter 'countryUpdateSchema' is not null or undefined
            assertParamExists('countriesUpdateOneSettingsCountriesCountryIdPut', 'countryUpdateSchema', countryUpdateSchema)
            const localVarPath = `/settings/countries/{country_id}/`
                .replace(`{${"country_id"}}`, encodeURIComponent(String(countryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsCountriesApi - functional programming interface
 * @export
 */
export const SettingsCountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsCountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all current countries from Settings for register page.  Pagination and filtering by names is used.
         * @summary Get all countries for register page
         * @param {string} [searchFilter] Search by name.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesGetAllRegisterSettingsCountriesRegisterGet(searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountriesRegisterPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesGetAllRegisterSettingsCountriesRegisterGet(searchFilter, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get all countries
         * @param {CountryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {CountryEUQueryFilter} [euFilter] 
         * @param {string} [searchFilter] Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
         * @param {string} [searchFilterSelect] Search by name. Only one search filter is allowed.
         * @param {boolean} [isActive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesGetAllSelectSettingsCountriesSelectGet(order?: CountryQueryOrder, sort?: BaseSort, euFilter?: CountryEUQueryFilter, searchFilter?: string, searchFilterSelect?: string, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectCountriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesGetAllSelectSettingsCountriesSelectGet(order, sort, euFilter, searchFilter, searchFilterSelect, isActive, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get all countries
         * @param {CountryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {CountryEUQueryFilter} [euFilter] 
         * @param {string} [searchFilter] Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
         * @param {string} [searchFilterSelect] Search by name. Only one search filter is allowed.
         * @param {boolean} [isActive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesGetAllSettingsCountriesGet(order?: CountryQueryOrder, sort?: BaseSort, euFilter?: CountryEUQueryFilter, searchFilter?: string, searchFilterSelect?: string, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesGetAllSettingsCountriesGet(order, sort, euFilter, searchFilter, searchFilterSelect, isActive, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get country detail
         * @param {number} countryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesGetOneSelectSettingsCountriesCountryIdSelectGet(countryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountrySimpleReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesGetOneSelectSettingsCountriesCountryIdSelectGet(countryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get country detail
         * @param {number} countryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesGetOneSettingsCountriesCountryIdGet(countryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesGetOneSettingsCountriesCountryIdGet(countryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update country status.  Perms needed: \'country_view, country_change\'.  Role needed: \'is_staff\'.
         * @summary Update country
         * @param {number} countryId 
         * @param {CountryUpdateSchema} countryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesUpdateOneSettingsCountriesCountryIdPut(countryId: number, countryUpdateSchema: CountryUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesUpdateOneSettingsCountriesCountryIdPut(countryId, countryUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsCountriesApi - factory interface
 * @export
 */
export const SettingsCountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsCountriesApiFp(configuration)
    return {
        /**
         * Get all current countries from Settings for register page.  Pagination and filtering by names is used.
         * @summary Get all countries for register page
         * @param {string} [searchFilter] Search by name.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetAllRegisterSettingsCountriesRegisterGet(searchFilter?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<CountriesRegisterPage> {
            return localVarFp.countriesGetAllRegisterSettingsCountriesRegisterGet(searchFilter, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get all countries
         * @param {CountryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {CountryEUQueryFilter} [euFilter] 
         * @param {string} [searchFilter] Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
         * @param {string} [searchFilterSelect] Search by name. Only one search filter is allowed.
         * @param {boolean} [isActive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetAllSelectSettingsCountriesSelectGet(order?: CountryQueryOrder, sort?: BaseSort, euFilter?: CountryEUQueryFilter, searchFilter?: string, searchFilterSelect?: string, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectCountriesPage> {
            return localVarFp.countriesGetAllSelectSettingsCountriesSelectGet(order, sort, euFilter, searchFilter, searchFilterSelect, isActive, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get all countries
         * @param {CountryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {CountryEUQueryFilter} [euFilter] 
         * @param {string} [searchFilter] Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
         * @param {string} [searchFilterSelect] Search by name. Only one search filter is allowed.
         * @param {boolean} [isActive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetAllSettingsCountriesGet(order?: CountryQueryOrder, sort?: BaseSort, euFilter?: CountryEUQueryFilter, searchFilter?: string, searchFilterSelect?: string, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<CountriesPage> {
            return localVarFp.countriesGetAllSettingsCountriesGet(order, sort, euFilter, searchFilter, searchFilterSelect, isActive, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get country detail
         * @param {number} countryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetOneSelectSettingsCountriesCountryIdSelectGet(countryId: number, acceptLanguage?: string, options?: any): AxiosPromise<CountrySimpleReadSchema> {
            return localVarFp.countriesGetOneSelectSettingsCountriesCountryIdSelectGet(countryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
         * @summary Get country detail
         * @param {number} countryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGetOneSettingsCountriesCountryIdGet(countryId: number, acceptLanguage?: string, options?: any): AxiosPromise<CountryDetailSchema> {
            return localVarFp.countriesGetOneSettingsCountriesCountryIdGet(countryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update country status.  Perms needed: \'country_view, country_change\'.  Role needed: \'is_staff\'.
         * @summary Update country
         * @param {number} countryId 
         * @param {CountryUpdateSchema} countryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesUpdateOneSettingsCountriesCountryIdPut(countryId: number, countryUpdateSchema: CountryUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<CountryDetailSchema> {
            return localVarFp.countriesUpdateOneSettingsCountriesCountryIdPut(countryId, countryUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for countriesGetAllRegisterSettingsCountriesRegisterGet operation in SettingsCountriesApi.
 * @export
 * @interface SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGetRequest
 */
export interface SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGetRequest {
    /**
     * Search by name.
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for countriesGetAllSelectSettingsCountriesSelectGet operation in SettingsCountriesApi.
 * @export
 * @interface SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGetRequest
 */
export interface SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGetRequest {
    /**
     * 
     * @type {CountryQueryOrder}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly order?: CountryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {CountryEUQueryFilter}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly euFilter?: CountryEUQueryFilter

    /**
     * Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search by name. Only one search filter is allowed.
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {boolean}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for countriesGetAllSettingsCountriesGet operation in SettingsCountriesApi.
 * @export
 * @interface SettingsCountriesApiCountriesGetAllSettingsCountriesGetRequest
 */
export interface SettingsCountriesApiCountriesGetAllSettingsCountriesGetRequest {
    /**
     * 
     * @type {CountryQueryOrder}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly order?: CountryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {CountryEUQueryFilter}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly euFilter?: CountryEUQueryFilter

    /**
     * Search by name, name_iso2 and numeric_code. Only one search filter is allowed.
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly searchFilter?: string

    /**
     * Search by name. Only one search filter is allowed.
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {boolean}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetAllSettingsCountriesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for countriesGetOneSelectSettingsCountriesCountryIdSelectGet operation in SettingsCountriesApi.
 * @export
 * @interface SettingsCountriesApiCountriesGetOneSelectSettingsCountriesCountryIdSelectGetRequest
 */
export interface SettingsCountriesApiCountriesGetOneSelectSettingsCountriesCountryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetOneSelectSettingsCountriesCountryIdSelectGet
     */
    readonly countryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetOneSelectSettingsCountriesCountryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for countriesGetOneSettingsCountriesCountryIdGet operation in SettingsCountriesApi.
 * @export
 * @interface SettingsCountriesApiCountriesGetOneSettingsCountriesCountryIdGetRequest
 */
export interface SettingsCountriesApiCountriesGetOneSettingsCountriesCountryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesGetOneSettingsCountriesCountryIdGet
     */
    readonly countryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCountriesApiCountriesGetOneSettingsCountriesCountryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for countriesUpdateOneSettingsCountriesCountryIdPut operation in SettingsCountriesApi.
 * @export
 * @interface SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPutRequest
 */
export interface SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPut
     */
    readonly countryId: number

    /**
     * 
     * @type {CountryUpdateSchema}
     * @memberof SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPut
     */
    readonly countryUpdateSchema: CountryUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsCountriesApi - object-oriented interface
 * @export
 * @class SettingsCountriesApi
 * @extends {BaseAPI}
 */
export class SettingsCountriesApi extends BaseAPI {
    /**
     * Get all current countries from Settings for register page.  Pagination and filtering by names is used.
     * @summary Get all countries for register page
     * @param {SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCountriesApi
     */
    public countriesGetAllRegisterSettingsCountriesRegisterGet(requestParameters: SettingsCountriesApiCountriesGetAllRegisterSettingsCountriesRegisterGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsCountriesApiFp(this.configuration).countriesGetAllRegisterSettingsCountriesRegisterGet(requestParameters.searchFilter, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
     * @summary Get all countries
     * @param {SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCountriesApi
     */
    public countriesGetAllSelectSettingsCountriesSelectGet(requestParameters: SettingsCountriesApiCountriesGetAllSelectSettingsCountriesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsCountriesApiFp(this.configuration).countriesGetAllSelectSettingsCountriesSelectGet(requestParameters.order, requestParameters.sort, requestParameters.euFilter, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.isActive, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current countries from Settings.  Pagination, ordering (default: is_base & desc name) and filtering is used.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
     * @summary Get all countries
     * @param {SettingsCountriesApiCountriesGetAllSettingsCountriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCountriesApi
     */
    public countriesGetAllSettingsCountriesGet(requestParameters: SettingsCountriesApiCountriesGetAllSettingsCountriesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsCountriesApiFp(this.configuration).countriesGetAllSettingsCountriesGet(requestParameters.order, requestParameters.sort, requestParameters.euFilter, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.isActive, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
     * @summary Get country detail
     * @param {SettingsCountriesApiCountriesGetOneSelectSettingsCountriesCountryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCountriesApi
     */
    public countriesGetOneSelectSettingsCountriesCountryIdSelectGet(requestParameters: SettingsCountriesApiCountriesGetOneSelectSettingsCountriesCountryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsCountriesApiFp(this.configuration).countriesGetOneSelectSettingsCountriesCountryIdSelectGet(requestParameters.countryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get country detail.  Perms needed: \'country_view\'.  Role needed: \'is_staff\'.
     * @summary Get country detail
     * @param {SettingsCountriesApiCountriesGetOneSettingsCountriesCountryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCountriesApi
     */
    public countriesGetOneSettingsCountriesCountryIdGet(requestParameters: SettingsCountriesApiCountriesGetOneSettingsCountriesCountryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsCountriesApiFp(this.configuration).countriesGetOneSettingsCountriesCountryIdGet(requestParameters.countryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update country status.  Perms needed: \'country_view, country_change\'.  Role needed: \'is_staff\'.
     * @summary Update country
     * @param {SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCountriesApi
     */
    public countriesUpdateOneSettingsCountriesCountryIdPut(requestParameters: SettingsCountriesApiCountriesUpdateOneSettingsCountriesCountryIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsCountriesApiFp(this.configuration).countriesUpdateOneSettingsCountriesCountryIdPut(requestParameters.countryId, requestParameters.countryUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsCurrenciesApi - axios parameter creator
 * @export
 */
export const SettingsCurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get all currencies
         * @param {BaseSort} [sort] 
         * @param {CurrencyQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetAllSelectSettingsCurrenciesSelectGet: async (sort?: BaseSort, order?: CurrencyQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/currencies/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get all currencies
         * @param {BaseSort} [sort] 
         * @param {CurrencyQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetAllSettingsCurrenciesGet: async (sort?: BaseSort, order?: CurrencyQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/currencies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currency history in Settings.  Pagination and filtering by date_created is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency history
         * @param {number} currencyId 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {string} [creatorId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet: async (currencyId: number, dateCreatedFrom?: string, dateCreatedTo?: string, creatorId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet', 'currencyId', currencyId)
            const localVarPath = `/settings/currencies/{currency_id}/history/`
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (creatorId !== undefined) {
                localVarQueryParameter['creatorId'] = creatorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency detail
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet: async (currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet', 'currencyId', currencyId)
            const localVarPath = `/settings/currencies/{currency_id}/select/`
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency detail
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetOneSettingsCurrenciesCurrencyIdGet: async (currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('currenciesGetOneSettingsCurrenciesCurrencyIdGet', 'currencyId', currencyId)
            const localVarPath = `/settings/currencies/{currency_id}/`
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update currency: is_sync_with_network, rate(if is_sync_with_network is False).  Perms needed: \'currency_in_settings_view, currency_in_settings_change\'.  Role needed: \'is_staff\'.
         * @summary Update currency
         * @param {number} currencyId 
         * @param {CurrencyUpdateSchema} currencyUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesUpdateOneSettingsCurrenciesCurrencyIdPut: async (currencyId: number, currencyUpdateSchema: CurrencyUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('currenciesUpdateOneSettingsCurrenciesCurrencyIdPut', 'currencyId', currencyId)
            // verify required parameter 'currencyUpdateSchema' is not null or undefined
            assertParamExists('currenciesUpdateOneSettingsCurrenciesCurrencyIdPut', 'currencyUpdateSchema', currencyUpdateSchema)
            const localVarPath = `/settings/currencies/{currency_id}/`
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsCurrenciesApi - functional programming interface
 * @export
 */
export const SettingsCurrenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsCurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get all currencies
         * @param {BaseSort} [sort] 
         * @param {CurrencyQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesGetAllSelectSettingsCurrenciesSelectGet(sort?: BaseSort, order?: CurrencyQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SelectCurrencySchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesGetAllSelectSettingsCurrenciesSelectGet(sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get all currencies
         * @param {BaseSort} [sort] 
         * @param {CurrencyQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesGetAllSettingsCurrenciesGet(sort?: BaseSort, order?: CurrencyQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencySchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesGetAllSettingsCurrenciesGet(sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get currency history in Settings.  Pagination and filtering by date_created is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency history
         * @param {number} currencyId 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {string} [creatorId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet(currencyId: number, dateCreatedFrom?: string, dateCreatedTo?: string, creatorId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyHistoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet(currencyId, dateCreatedFrom, dateCreatedTo, creatorId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency detail
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet(currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectCurrencySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet(currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency detail
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesGetOneSettingsCurrenciesCurrencyIdGet(currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesGetOneSettingsCurrenciesCurrencyIdGet(currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update currency: is_sync_with_network, rate(if is_sync_with_network is False).  Perms needed: \'currency_in_settings_view, currency_in_settings_change\'.  Role needed: \'is_staff\'.
         * @summary Update currency
         * @param {number} currencyId 
         * @param {CurrencyUpdateSchema} currencyUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesUpdateOneSettingsCurrenciesCurrencyIdPut(currencyId: number, currencyUpdateSchema: CurrencyUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesUpdateOneSettingsCurrenciesCurrencyIdPut(currencyId, currencyUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsCurrenciesApi - factory interface
 * @export
 */
export const SettingsCurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsCurrenciesApiFp(configuration)
    return {
        /**
         * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get all currencies
         * @param {BaseSort} [sort] 
         * @param {CurrencyQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetAllSelectSettingsCurrenciesSelectGet(sort?: BaseSort, order?: CurrencyQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<Array<SelectCurrencySchema>> {
            return localVarFp.currenciesGetAllSelectSettingsCurrenciesSelectGet(sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get all currencies
         * @param {BaseSort} [sort] 
         * @param {CurrencyQueryOrder} [order] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetAllSettingsCurrenciesGet(sort?: BaseSort, order?: CurrencyQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<Array<CurrencySchema>> {
            return localVarFp.currenciesGetAllSettingsCurrenciesGet(sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currency history in Settings.  Pagination and filtering by date_created is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency history
         * @param {number} currencyId 
         * @param {string} [dateCreatedFrom] 
         * @param {string} [dateCreatedTo] 
         * @param {string} [creatorId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet(currencyId: number, dateCreatedFrom?: string, dateCreatedTo?: string, creatorId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<CurrencyHistoryPage> {
            return localVarFp.currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet(currencyId, dateCreatedFrom, dateCreatedTo, creatorId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency detail
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet(currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectCurrencySchema> {
            return localVarFp.currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet(currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
         * @summary Get currency detail
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGetOneSettingsCurrenciesCurrencyIdGet(currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<CurrencyDetailSchema> {
            return localVarFp.currenciesGetOneSettingsCurrenciesCurrencyIdGet(currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update currency: is_sync_with_network, rate(if is_sync_with_network is False).  Perms needed: \'currency_in_settings_view, currency_in_settings_change\'.  Role needed: \'is_staff\'.
         * @summary Update currency
         * @param {number} currencyId 
         * @param {CurrencyUpdateSchema} currencyUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesUpdateOneSettingsCurrenciesCurrencyIdPut(currencyId: number, currencyUpdateSchema: CurrencyUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<CurrencyDetailSchema> {
            return localVarFp.currenciesUpdateOneSettingsCurrenciesCurrencyIdPut(currencyId, currencyUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for currenciesGetAllSelectSettingsCurrenciesSelectGet operation in SettingsCurrenciesApi.
 * @export
 * @interface SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGetRequest
 */
export interface SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {CurrencyQueryOrder}
     * @memberof SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGet
     */
    readonly order?: CurrencyQueryOrder

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for currenciesGetAllSettingsCurrenciesGet operation in SettingsCurrenciesApi.
 * @export
 * @interface SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGetRequest
 */
export interface SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {CurrencyQueryOrder}
     * @memberof SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGet
     */
    readonly order?: CurrencyQueryOrder

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet operation in SettingsCurrenciesApi.
 * @export
 * @interface SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGetRequest
 */
export interface SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly dateCreatedFrom?: string

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly dateCreatedTo?: string

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly creatorId?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet operation in SettingsCurrenciesApi.
 * @export
 * @interface SettingsCurrenciesApiCurrenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGetRequest
 */
export interface SettingsCurrenciesApiCurrenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCurrenciesApiCurrenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for currenciesGetOneSettingsCurrenciesCurrencyIdGet operation in SettingsCurrenciesApi.
 * @export
 * @interface SettingsCurrenciesApiCurrenciesGetOneSettingsCurrenciesCurrencyIdGetRequest
 */
export interface SettingsCurrenciesApiCurrenciesGetOneSettingsCurrenciesCurrencyIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCurrenciesApiCurrenciesGetOneSettingsCurrenciesCurrencyIdGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesGetOneSettingsCurrenciesCurrencyIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for currenciesUpdateOneSettingsCurrenciesCurrencyIdPut operation in SettingsCurrenciesApi.
 * @export
 * @interface SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPutRequest
 */
export interface SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPut
     */
    readonly currencyId: number

    /**
     * 
     * @type {CurrencyUpdateSchema}
     * @memberof SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPut
     */
    readonly currencyUpdateSchema: CurrencyUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsCurrenciesApi - object-oriented interface
 * @export
 * @class SettingsCurrenciesApi
 * @extends {BaseAPI}
 */
export class SettingsCurrenciesApi extends BaseAPI {
    /**
     * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
     * @summary Get all currencies
     * @param {SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCurrenciesApi
     */
    public currenciesGetAllSelectSettingsCurrenciesSelectGet(requestParameters: SettingsCurrenciesApiCurrenciesGetAllSelectSettingsCurrenciesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsCurrenciesApiFp(this.configuration).currenciesGetAllSelectSettingsCurrenciesSelectGet(requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current currencies from Settings.  Pagination, ordering by column(default is_base & date_created) is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
     * @summary Get all currencies
     * @param {SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCurrenciesApi
     */
    public currenciesGetAllSettingsCurrenciesGet(requestParameters: SettingsCurrenciesApiCurrenciesGetAllSettingsCurrenciesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsCurrenciesApiFp(this.configuration).currenciesGetAllSettingsCurrenciesGet(requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currency history in Settings.  Pagination and filtering by date_created is used.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
     * @summary Get currency history
     * @param {SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCurrenciesApi
     */
    public currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet(requestParameters: SettingsCurrenciesApiCurrenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGetRequest, options?: AxiosRequestConfig) {
        return SettingsCurrenciesApiFp(this.configuration).currenciesGetHistorySettingsCurrenciesCurrencyIdHistoryGet(requestParameters.currencyId, requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.creatorId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
     * @summary Get currency detail
     * @param {SettingsCurrenciesApiCurrenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCurrenciesApi
     */
    public currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet(requestParameters: SettingsCurrenciesApiCurrenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsCurrenciesApiFp(this.configuration).currenciesGetOneSelectSettingsCurrenciesCurrencyIdSelectGet(requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currency detail.  Perms needed: \'currency_in_settings_view\'.  Role needed: \'is_staff\'.
     * @summary Get currency detail
     * @param {SettingsCurrenciesApiCurrenciesGetOneSettingsCurrenciesCurrencyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCurrenciesApi
     */
    public currenciesGetOneSettingsCurrenciesCurrencyIdGet(requestParameters: SettingsCurrenciesApiCurrenciesGetOneSettingsCurrenciesCurrencyIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsCurrenciesApiFp(this.configuration).currenciesGetOneSettingsCurrenciesCurrencyIdGet(requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update currency: is_sync_with_network, rate(if is_sync_with_network is False).  Perms needed: \'currency_in_settings_view, currency_in_settings_change\'.  Role needed: \'is_staff\'.
     * @summary Update currency
     * @param {SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCurrenciesApi
     */
    public currenciesUpdateOneSettingsCurrenciesCurrencyIdPut(requestParameters: SettingsCurrenciesApiCurrenciesUpdateOneSettingsCurrenciesCurrencyIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsCurrenciesApiFp(this.configuration).currenciesUpdateOneSettingsCurrenciesCurrencyIdPut(requestParameters.currencyId, requestParameters.currencyUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsFinancialAnalysisCategoriesApi - axios parameter creator
 * @export
 */
export const SettingsFinancialAnalysisCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Create financial analysis category.
         * @param {FinancialAnalysisCategoryCreateSchema} financialAnalysisCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost: async (financialAnalysisCategoryCreateSchema: FinancialAnalysisCategoryCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisCategoryCreateSchema' is not null or undefined
            assertParamExists('settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost', 'financialAnalysisCategoryCreateSchema', financialAnalysisCategoryCreateSchema)
            const localVarPath = `/settings/financial-analysis/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(financialAnalysisCategoryCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Delete financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete: async (financialAnalysisCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisCategoryId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete', 'financialAnalysisCategoryId', financialAnalysisCategoryId)
            const localVarPath = `/settings/financial-analysis/categories/{financial_analysis_category_id}/`
                .replace(`{${"financial_analysis_category_id"}}`, encodeURIComponent(String(financialAnalysisCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
         * @summary Get financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet: async (financialAnalysisCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisCategoryId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet', 'financialAnalysisCategoryId', financialAnalysisCategoryId)
            const localVarPath = `/settings/financial-analysis/categories/{financial_analysis_category_id}/select/`
                .replace(`{${"financial_analysis_category_id"}}`, encodeURIComponent(String(financialAnalysisCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
         * @summary Get financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet: async (financialAnalysisCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisCategoryId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet', 'financialAnalysisCategoryId', financialAnalysisCategoryId)
            const localVarPath = `/settings/financial-analysis/categories/{financial_analysis_category_id}/`
                .replace(`{${"financial_analysis_category_id"}}`, encodeURIComponent(String(financialAnalysisCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
         * @summary List all financial analysis categories
         * @param {BaseSort} [sort] 
         * @param {AnalyticsCategoryQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet: async (sort?: BaseSort, order?: AnalyticsCategoryQueryOrder, excludeInactive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/financial-analysis/categories/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
         * @summary List all financial analysis categories
         * @param {BaseSort} [sort] 
         * @param {AnalyticsCategoryQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet: async (sort?: BaseSort, order?: AnalyticsCategoryQueryOrder, excludeInactive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/financial-analysis/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update price category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Update financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {FinancialAnalysisCategoryUpdateSchema} financialAnalysisCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut: async (financialAnalysisCategoryId: number, financialAnalysisCategoryUpdateSchema: FinancialAnalysisCategoryUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisCategoryId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut', 'financialAnalysisCategoryId', financialAnalysisCategoryId)
            // verify required parameter 'financialAnalysisCategoryUpdateSchema' is not null or undefined
            assertParamExists('settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut', 'financialAnalysisCategoryUpdateSchema', financialAnalysisCategoryUpdateSchema)
            const localVarPath = `/settings/financial-analysis/categories/{financial_analysis_category_id}/`
                .replace(`{${"financial_analysis_category_id"}}`, encodeURIComponent(String(financialAnalysisCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(financialAnalysisCategoryUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsFinancialAnalysisCategoriesApi - functional programming interface
 * @export
 */
export const SettingsFinancialAnalysisCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsFinancialAnalysisCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Create financial analysis category.
         * @param {FinancialAnalysisCategoryCreateSchema} financialAnalysisCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost(financialAnalysisCategoryCreateSchema: FinancialAnalysisCategoryCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost(financialAnalysisCategoryCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Delete financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete(financialAnalysisCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete(financialAnalysisCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
         * @summary Get financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet(financialAnalysisCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisCategoryReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet(financialAnalysisCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
         * @summary Get financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet(financialAnalysisCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet(financialAnalysisCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
         * @summary List all financial analysis categories
         * @param {BaseSort} [sort] 
         * @param {AnalyticsCategoryQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet(sort?: BaseSort, order?: AnalyticsCategoryQueryOrder, excludeInactive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet(sort, order, excludeInactive, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
         * @summary List all financial analysis categories
         * @param {BaseSort} [sort] 
         * @param {AnalyticsCategoryQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet(sort?: BaseSort, order?: AnalyticsCategoryQueryOrder, excludeInactive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet(sort, order, excludeInactive, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update price category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Update financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {FinancialAnalysisCategoryUpdateSchema} financialAnalysisCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut(financialAnalysisCategoryId: number, financialAnalysisCategoryUpdateSchema: FinancialAnalysisCategoryUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut(financialAnalysisCategoryId, financialAnalysisCategoryUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsFinancialAnalysisCategoriesApi - factory interface
 * @export
 */
export const SettingsFinancialAnalysisCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsFinancialAnalysisCategoriesApiFp(configuration)
    return {
        /**
         * Create financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Create financial analysis category.
         * @param {FinancialAnalysisCategoryCreateSchema} financialAnalysisCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost(financialAnalysisCategoryCreateSchema: FinancialAnalysisCategoryCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisCategoryDetailSchema> {
            return localVarFp.settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost(financialAnalysisCategoryCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Delete financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete(financialAnalysisCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete(financialAnalysisCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
         * @summary Get financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet(financialAnalysisCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisCategoryReadSchema> {
            return localVarFp.settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet(financialAnalysisCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
         * @summary Get financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet(financialAnalysisCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisCategoryDetailSchema> {
            return localVarFp.settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet(financialAnalysisCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
         * @summary List all financial analysis categories
         * @param {BaseSort} [sort] 
         * @param {AnalyticsCategoryQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet(sort?: BaseSort, order?: AnalyticsCategoryQueryOrder, excludeInactive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisCategoryPage> {
            return localVarFp.settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet(sort, order, excludeInactive, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
         * @summary List all financial analysis categories
         * @param {BaseSort} [sort] 
         * @param {AnalyticsCategoryQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet(sort?: BaseSort, order?: AnalyticsCategoryQueryOrder, excludeInactive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisCategoryPage> {
            return localVarFp.settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet(sort, order, excludeInactive, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update price category.  Role check: is_staff.  Permission: financial_analysis_category_change.
         * @summary Update financial analysis category.
         * @param {number} financialAnalysisCategoryId 
         * @param {FinancialAnalysisCategoryUpdateSchema} financialAnalysisCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut(financialAnalysisCategoryId: number, financialAnalysisCategoryUpdateSchema: FinancialAnalysisCategoryUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisCategoryDetailSchema> {
            return localVarFp.settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut(financialAnalysisCategoryId, financialAnalysisCategoryUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPostRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPostRequest {
    /**
     * 
     * @type {FinancialAnalysisCategoryCreateSchema}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost
     */
    readonly financialAnalysisCategoryCreateSchema: FinancialAnalysisCategoryCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDeleteRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete
     */
    readonly financialAnalysisCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGetRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet
     */
    readonly financialAnalysisCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGetRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet
     */
    readonly financialAnalysisCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGetRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {AnalyticsCategoryQueryOrder}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet
     */
    readonly order?: AnalyticsCategoryQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGetRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {AnalyticsCategoryQueryOrder}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet
     */
    readonly order?: AnalyticsCategoryQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut operation in SettingsFinancialAnalysisCategoriesApi.
 * @export
 * @interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPutRequest
 */
export interface SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut
     */
    readonly financialAnalysisCategoryId: number

    /**
     * 
     * @type {FinancialAnalysisCategoryUpdateSchema}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut
     */
    readonly financialAnalysisCategoryUpdateSchema: FinancialAnalysisCategoryUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsFinancialAnalysisCategoriesApi - object-oriented interface
 * @export
 * @class SettingsFinancialAnalysisCategoriesApi
 * @extends {BaseAPI}
 */
export class SettingsFinancialAnalysisCategoriesApi extends BaseAPI {
    /**
     * Create financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
     * @summary Create financial analysis category.
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPostRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesCreateSettingsFinancialAnalysisCategoriesPost(requestParameters.financialAnalysisCategoryCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_change.
     * @summary Delete financial analysis category.
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesDeleteSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdDelete(requestParameters.financialAnalysisCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
     * @summary Get financial analysis category.
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesGetSelectSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdSelectGet(requestParameters.financialAnalysisCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get financial analysis category.  Role check: is_staff.  Permission: financial_analysis_category_view.
     * @summary Get financial analysis category.
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesGetSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdGet(requestParameters.financialAnalysisCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
     * @summary List all financial analysis categories
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesListSelectSettingsFinancialAnalysisCategoriesSelectGet(requestParameters.sort, requestParameters.order, requestParameters.excludeInactive, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current vat rates from Settings.  Perms needed: \'financial_analysis_category_view\'.  Role needed: \'is_staff\'.
     * @summary List all financial analysis categories
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesListSettingsFinancialAnalysisCategoriesGet(requestParameters.sort, requestParameters.order, requestParameters.excludeInactive, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update price category.  Role check: is_staff.  Permission: financial_analysis_category_change.
     * @summary Update financial analysis category.
     * @param {SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisCategoriesApi
     */
    public settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut(requestParameters: SettingsFinancialAnalysisCategoriesApiSettingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisCategoriesApiFp(this.configuration).settingsFinancialAnalysisCategoriesUpdateSettingsFinancialAnalysisCategoriesFinancialAnalysisCategoryIdPut(requestParameters.financialAnalysisCategoryId, requestParameters.financialAnalysisCategoryUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsFinancialAnalysisItemsApi - axios parameter creator
 * @export
 */
export const SettingsFinancialAnalysisItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Create financial analysis Item.
         * @param {FinancialAnalysisItemCreateSchema} financialAnalysisItemCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost: async (financialAnalysisItemCreateSchema: FinancialAnalysisItemCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisItemCreateSchema' is not null or undefined
            assertParamExists('settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost', 'financialAnalysisItemCreateSchema', financialAnalysisItemCreateSchema)
            const localVarPath = `/settings/financial-analysis/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(financialAnalysisItemCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Delete financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete: async (financialAnalysisItemId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisItemId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete', 'financialAnalysisItemId', financialAnalysisItemId)
            const localVarPath = `/settings/financial-analysis/items/{financial_analysis_item_id}/`
                .replace(`{${"financial_analysis_item_id"}}`, encodeURIComponent(String(financialAnalysisItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
         * @summary Get financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet: async (financialAnalysisItemId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisItemId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet', 'financialAnalysisItemId', financialAnalysisItemId)
            const localVarPath = `/settings/financial-analysis/items/{financial_analysis_item_id}/select/`
                .replace(`{${"financial_analysis_item_id"}}`, encodeURIComponent(String(financialAnalysisItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
         * @summary Get financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet: async (financialAnalysisItemId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisItemId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet', 'financialAnalysisItemId', financialAnalysisItemId)
            const localVarPath = `/settings/financial-analysis/items/{financial_analysis_item_id}/`
                .replace(`{${"financial_analysis_item_id"}}`, encodeURIComponent(String(financialAnalysisItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
         * @summary List all financial analysis items
         * @param {BaseSort} [sort] 
         * @param {AnalyticsItemQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search by financial analysis item name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet: async (sort?: BaseSort, order?: AnalyticsItemQueryOrder, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/financial-analysis/items/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
         * @summary List all financial analysis items
         * @param {BaseSort} [sort] 
         * @param {AnalyticsItemQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search by financial analysis item name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet: async (sort?: BaseSort, order?: AnalyticsItemQueryOrder, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/financial-analysis/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Update financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {FinancialAnalysisItemUpdateSchema} financialAnalysisItemUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut: async (financialAnalysisItemId: number, financialAnalysisItemUpdateSchema: FinancialAnalysisItemUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialAnalysisItemId' is not null or undefined
            assertParamExists('settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut', 'financialAnalysisItemId', financialAnalysisItemId)
            // verify required parameter 'financialAnalysisItemUpdateSchema' is not null or undefined
            assertParamExists('settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut', 'financialAnalysisItemUpdateSchema', financialAnalysisItemUpdateSchema)
            const localVarPath = `/settings/financial-analysis/items/{financial_analysis_item_id}/`
                .replace(`{${"financial_analysis_item_id"}}`, encodeURIComponent(String(financialAnalysisItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(financialAnalysisItemUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsFinancialAnalysisItemsApi - functional programming interface
 * @export
 */
export const SettingsFinancialAnalysisItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsFinancialAnalysisItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Create financial analysis Item.
         * @param {FinancialAnalysisItemCreateSchema} financialAnalysisItemCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost(financialAnalysisItemCreateSchema: FinancialAnalysisItemCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisItemDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost(financialAnalysisItemCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Delete financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete(financialAnalysisItemId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete(financialAnalysisItemId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
         * @summary Get financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet(financialAnalysisItemId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFinancialAnalysisItemSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet(financialAnalysisItemId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
         * @summary Get financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet(financialAnalysisItemId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisItemDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet(financialAnalysisItemId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
         * @summary List all financial analysis items
         * @param {BaseSort} [sort] 
         * @param {AnalyticsItemQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search by financial analysis item name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet(sort?: BaseSort, order?: AnalyticsItemQueryOrder, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisItemPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet(sort, order, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
         * @summary List all financial analysis items
         * @param {BaseSort} [sort] 
         * @param {AnalyticsItemQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search by financial analysis item name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet(sort?: BaseSort, order?: AnalyticsItemQueryOrder, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisItemPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet(sort, order, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Update financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {FinancialAnalysisItemUpdateSchema} financialAnalysisItemUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut(financialAnalysisItemId: number, financialAnalysisItemUpdateSchema: FinancialAnalysisItemUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAnalysisItemDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut(financialAnalysisItemId, financialAnalysisItemUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsFinancialAnalysisItemsApi - factory interface
 * @export
 */
export const SettingsFinancialAnalysisItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsFinancialAnalysisItemsApiFp(configuration)
    return {
        /**
         * Create financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Create financial analysis Item.
         * @param {FinancialAnalysisItemCreateSchema} financialAnalysisItemCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost(financialAnalysisItemCreateSchema: FinancialAnalysisItemCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisItemDetailSchema> {
            return localVarFp.settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost(financialAnalysisItemCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Delete financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete(financialAnalysisItemId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete(financialAnalysisItemId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
         * @summary Get financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet(financialAnalysisItemId: number, acceptLanguage?: string, options?: any): AxiosPromise<BaseFinancialAnalysisItemSchema> {
            return localVarFp.settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet(financialAnalysisItemId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
         * @summary Get financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet(financialAnalysisItemId: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisItemDetailSchema> {
            return localVarFp.settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet(financialAnalysisItemId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
         * @summary List all financial analysis items
         * @param {BaseSort} [sort] 
         * @param {AnalyticsItemQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search by financial analysis item name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet(sort?: BaseSort, order?: AnalyticsItemQueryOrder, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisItemPage> {
            return localVarFp.settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet(sort, order, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
         * @summary List all financial analysis items
         * @param {BaseSort} [sort] 
         * @param {AnalyticsItemQueryOrder} [order] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search by financial analysis item name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet(sort?: BaseSort, order?: AnalyticsItemQueryOrder, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisItemPage> {
            return localVarFp.settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet(sort, order, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
         * @summary Update financial analysis Item.
         * @param {number} financialAnalysisItemId 
         * @param {FinancialAnalysisItemUpdateSchema} financialAnalysisItemUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut(financialAnalysisItemId: number, financialAnalysisItemUpdateSchema: FinancialAnalysisItemUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<FinancialAnalysisItemDetailSchema> {
            return localVarFp.settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut(financialAnalysisItemId, financialAnalysisItemUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPostRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPostRequest {
    /**
     * 
     * @type {FinancialAnalysisItemCreateSchema}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost
     */
    readonly financialAnalysisItemCreateSchema: FinancialAnalysisItemCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDeleteRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete
     */
    readonly financialAnalysisItemId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGetRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet
     */
    readonly financialAnalysisItemId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGetRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet
     */
    readonly financialAnalysisItemId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGetRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {AnalyticsItemQueryOrder}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly order?: AnalyticsItemQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search by financial analysis item name
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGetRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {AnalyticsItemQueryOrder}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly order?: AnalyticsItemQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search by financial analysis item name
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut operation in SettingsFinancialAnalysisItemsApi.
 * @export
 * @interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPutRequest
 */
export interface SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut
     */
    readonly financialAnalysisItemId: number

    /**
     * 
     * @type {FinancialAnalysisItemUpdateSchema}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut
     */
    readonly financialAnalysisItemUpdateSchema: FinancialAnalysisItemUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsFinancialAnalysisItemsApi - object-oriented interface
 * @export
 * @class SettingsFinancialAnalysisItemsApi
 * @extends {BaseAPI}
 */
export class SettingsFinancialAnalysisItemsApi extends BaseAPI {
    /**
     * Create financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
     * @summary Create financial analysis Item.
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPostRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsCreateSettingsFinancialAnalysisItemsPost(requestParameters.financialAnalysisItemCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
     * @summary Delete financial analysis Item.
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsDeleteSettingsFinancialAnalysisItemsFinancialAnalysisItemIdDelete(requestParameters.financialAnalysisItemId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
     * @summary Get financial analysis Item.
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsGetSelectSettingsFinancialAnalysisItemsFinancialAnalysisItemIdSelectGet(requestParameters.financialAnalysisItemId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_view.
     * @summary Get financial analysis Item.
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsGetSettingsFinancialAnalysisItemsFinancialAnalysisItemIdGet(requestParameters.financialAnalysisItemId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
     * @summary List all financial analysis items
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsListSelectSettingsFinancialAnalysisItemsSelectGet(requestParameters.sort, requestParameters.order, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current financial analysis items from Settings.  Perms needed: \'financial_analysis_item_view\'  Role needed: \'is_staff\'
     * @summary List all financial analysis items
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsListSettingsFinancialAnalysisItemsGet(requestParameters.sort, requestParameters.order, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch financial analysis Item.  Role check: is_staff.  Permission: financial_analysis_item_change.
     * @summary Update financial analysis Item.
     * @param {SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsFinancialAnalysisItemsApi
     */
    public settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut(requestParameters: SettingsFinancialAnalysisItemsApiSettingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsFinancialAnalysisItemsApiFp(this.configuration).settingsFinancialAnalysisItemsUpdateSettingsFinancialAnalysisItemsFinancialAnalysisItemIdPut(requestParameters.financialAnalysisItemId, requestParameters.financialAnalysisItemUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsMarkupManagerApi - axios parameter creator
 * @export
 */
export const SettingsMarkupManagerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update nomenclature prices by selected filters.  Role check: is_staff.  Permission: markup_manager_change.  If the response is null, then all found nomenclature prices are updated successfully. Also, null response will be received if nomenclature prices by selected filters was not found.
         * @summary Update nomenclature prices.
         * @param {UpdateNomenclaturePrices} updateNomenclaturePrices 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markupManagerUpdateSettingsMarkupManagerPut: async (updateNomenclaturePrices: UpdateNomenclaturePrices, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNomenclaturePrices' is not null or undefined
            assertParamExists('markupManagerUpdateSettingsMarkupManagerPut', 'updateNomenclaturePrices', updateNomenclaturePrices)
            const localVarPath = `/settings/markup-manager/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNomenclaturePrices, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsMarkupManagerApi - functional programming interface
 * @export
 */
export const SettingsMarkupManagerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsMarkupManagerApiAxiosParamCreator(configuration)
    return {
        /**
         * Update nomenclature prices by selected filters.  Role check: is_staff.  Permission: markup_manager_change.  If the response is null, then all found nomenclature prices are updated successfully. Also, null response will be received if nomenclature prices by selected filters was not found.
         * @summary Update nomenclature prices.
         * @param {UpdateNomenclaturePrices} updateNomenclaturePrices 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markupManagerUpdateSettingsMarkupManagerPut(updateNomenclaturePrices: UpdateNomenclaturePrices, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markupManagerUpdateSettingsMarkupManagerPut(updateNomenclaturePrices, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsMarkupManagerApi - factory interface
 * @export
 */
export const SettingsMarkupManagerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsMarkupManagerApiFp(configuration)
    return {
        /**
         * Update nomenclature prices by selected filters.  Role check: is_staff.  Permission: markup_manager_change.  If the response is null, then all found nomenclature prices are updated successfully. Also, null response will be received if nomenclature prices by selected filters was not found.
         * @summary Update nomenclature prices.
         * @param {UpdateNomenclaturePrices} updateNomenclaturePrices 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markupManagerUpdateSettingsMarkupManagerPut(updateNomenclaturePrices: UpdateNomenclaturePrices, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.markupManagerUpdateSettingsMarkupManagerPut(updateNomenclaturePrices, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for markupManagerUpdateSettingsMarkupManagerPut operation in SettingsMarkupManagerApi.
 * @export
 * @interface SettingsMarkupManagerApiMarkupManagerUpdateSettingsMarkupManagerPutRequest
 */
export interface SettingsMarkupManagerApiMarkupManagerUpdateSettingsMarkupManagerPutRequest {
    /**
     * 
     * @type {UpdateNomenclaturePrices}
     * @memberof SettingsMarkupManagerApiMarkupManagerUpdateSettingsMarkupManagerPut
     */
    readonly updateNomenclaturePrices: UpdateNomenclaturePrices

    /**
     * 
     * @type {string}
     * @memberof SettingsMarkupManagerApiMarkupManagerUpdateSettingsMarkupManagerPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsMarkupManagerApi - object-oriented interface
 * @export
 * @class SettingsMarkupManagerApi
 * @extends {BaseAPI}
 */
export class SettingsMarkupManagerApi extends BaseAPI {
    /**
     * Update nomenclature prices by selected filters.  Role check: is_staff.  Permission: markup_manager_change.  If the response is null, then all found nomenclature prices are updated successfully. Also, null response will be received if nomenclature prices by selected filters was not found.
     * @summary Update nomenclature prices.
     * @param {SettingsMarkupManagerApiMarkupManagerUpdateSettingsMarkupManagerPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsMarkupManagerApi
     */
    public markupManagerUpdateSettingsMarkupManagerPut(requestParameters: SettingsMarkupManagerApiMarkupManagerUpdateSettingsMarkupManagerPutRequest, options?: AxiosRequestConfig) {
        return SettingsMarkupManagerApiFp(this.configuration).markupManagerUpdateSettingsMarkupManagerPut(requestParameters.updateNomenclaturePrices, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsNomenclatureCategoriesApi - axios parameter creator
 * @export
 */
export const SettingsNomenclatureCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Create nomenclature category
         * @param {NomenclatureCategoryCreateSchema} nomenclatureCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost: async (nomenclatureCategoryCreateSchema: NomenclatureCategoryCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureCategoryCreateSchema' is not null or undefined
            assertParamExists('nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost', 'nomenclatureCategoryCreateSchema', nomenclatureCategoryCreateSchema)
            const localVarPath = `/settings/nomenclature-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nomenclatureCategoryCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete nomenclature category.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Delete nomenclature category
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete: async (nomenclatureCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureCategoryId' is not null or undefined
            assertParamExists('nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete', 'nomenclatureCategoryId', nomenclatureCategoryId)
            const localVarPath = `/settings/nomenclature-categories/{nomenclature_category_id}/`
                .replace(`{${"nomenclature_category_id"}}`, encodeURIComponent(String(nomenclatureCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all active and used nomenclature (sub-)/categories for markup manager.  Pagination and search by name is used.  For markup manager, get categories - isActive=True, hasReferences=True.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories and subcategories for markup manager
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet: async (page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/nomenclature-categories/markup_manager/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories
         * @param {BaseSort} [sort] 
         * @param {NomenclatureCategoryQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet: async (sort?: BaseSort, order?: NomenclatureCategoryQueryOrder, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/nomenclature-categories/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories
         * @param {BaseSort} [sort] 
         * @param {NomenclatureCategoryQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet: async (sort?: BaseSort, order?: NomenclatureCategoryQueryOrder, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/nomenclature-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature category detail
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet: async (nomenclatureCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureCategoryId' is not null or undefined
            assertParamExists('nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet', 'nomenclatureCategoryId', nomenclatureCategoryId)
            const localVarPath = `/settings/nomenclature-categories/{nomenclature_category_id}/select/`
                .replace(`{${"nomenclature_category_id"}}`, encodeURIComponent(String(nomenclatureCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature category detail
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet: async (nomenclatureCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureCategoryId' is not null or undefined
            assertParamExists('nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet', 'nomenclatureCategoryId', nomenclatureCategoryId)
            const localVarPath = `/settings/nomenclature-categories/{nomenclature_category_id}/`
                .replace(`{${"nomenclature_category_id"}}`, encodeURIComponent(String(nomenclatureCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current nomenclature subcategories from Settings for select.  Pagination and search by name, categories is used.  For create or update pages, get only active categories - isActive=True.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature subcategories for select widget
         * @param {Array<number>} category Filtering by category ID. If None - no subcategory will be shown.
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet: async (category: Array<number>, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet', 'category', category)
            const localVarPath = `/settings/nomenclature-categories/subcategories/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Update nomenclature category
         * @param {number} nomenclatureCategoryId 
         * @param {NomenclatureCategoryUpdateSchema} nomenclatureCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut: async (nomenclatureCategoryId: number, nomenclatureCategoryUpdateSchema: NomenclatureCategoryUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureCategoryId' is not null or undefined
            assertParamExists('nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut', 'nomenclatureCategoryId', nomenclatureCategoryId)
            // verify required parameter 'nomenclatureCategoryUpdateSchema' is not null or undefined
            assertParamExists('nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut', 'nomenclatureCategoryUpdateSchema', nomenclatureCategoryUpdateSchema)
            const localVarPath = `/settings/nomenclature-categories/{nomenclature_category_id}/`
                .replace(`{${"nomenclature_category_id"}}`, encodeURIComponent(String(nomenclatureCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nomenclatureCategoryUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature subcategory detail
         * @param {number} nomenclatureSubcategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet: async (nomenclatureSubcategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureSubcategoryId' is not null or undefined
            assertParamExists('nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet', 'nomenclatureSubcategoryId', nomenclatureSubcategoryId)
            const localVarPath = `/settings/nomenclature-categories/subcategories/{nomenclature_subcategory_id}/select/`
                .replace(`{${"nomenclature_subcategory_id"}}`, encodeURIComponent(String(nomenclatureSubcategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature subcategory detail
         * @param {number} nomenclatureSubcategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet: async (nomenclatureSubcategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomenclatureSubcategoryId' is not null or undefined
            assertParamExists('nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet', 'nomenclatureSubcategoryId', nomenclatureSubcategoryId)
            const localVarPath = `/settings/nomenclature-categories/subcategories/{nomenclature_subcategory_id}/`
                .replace(`{${"nomenclature_subcategory_id"}}`, encodeURIComponent(String(nomenclatureSubcategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsNomenclatureCategoriesApi - functional programming interface
 * @export
 */
export const SettingsNomenclatureCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsNomenclatureCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Create nomenclature category
         * @param {NomenclatureCategoryCreateSchema} nomenclatureCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost(nomenclatureCategoryCreateSchema: NomenclatureCategoryCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureCategorySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost(nomenclatureCategoryCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete nomenclature category.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Delete nomenclature category
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete(nomenclatureCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete(nomenclatureCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all active and used nomenclature (sub-)/categories for markup manager.  Pagination and search by name is used.  For markup manager, get categories - isActive=True, hasReferences=True.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories and subcategories for markup manager
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet(page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkupManagerNomenclatureCategoriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet(page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories
         * @param {BaseSort} [sort] 
         * @param {NomenclatureCategoryQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet(sort?: BaseSort, order?: NomenclatureCategoryQueryOrder, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectNomenclatureCategoriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet(sort, order, isActive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories
         * @param {BaseSort} [sort] 
         * @param {NomenclatureCategoryQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet(sort?: BaseSort, order?: NomenclatureCategoryQueryOrder, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureCategoriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet(sort, order, isActive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature category detail
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet(nomenclatureCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectNomenclatureCategorySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet(nomenclatureCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature category detail
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet(nomenclatureCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet(nomenclatureCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current nomenclature subcategories from Settings for select.  Pagination and search by name, categories is used.  For create or update pages, get only active categories - isActive=True.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature subcategories for select widget
         * @param {Array<number>} category Filtering by category ID. If None - no subcategory will be shown.
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet(category: Array<number>, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectNomenclatureSubcategoriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet(category, isActive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Update nomenclature category
         * @param {number} nomenclatureCategoryId 
         * @param {NomenclatureCategoryUpdateSchema} nomenclatureCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut(nomenclatureCategoryId: number, nomenclatureCategoryUpdateSchema: NomenclatureCategoryUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureCategorySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut(nomenclatureCategoryId, nomenclatureCategoryUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature subcategory detail
         * @param {number} nomenclatureSubcategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet(nomenclatureSubcategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureSubcategorySelectSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet(nomenclatureSubcategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature subcategory detail
         * @param {number} nomenclatureSubcategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet(nomenclatureSubcategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclatureSubcategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet(nomenclatureSubcategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsNomenclatureCategoriesApi - factory interface
 * @export
 */
export const SettingsNomenclatureCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsNomenclatureCategoriesApiFp(configuration)
    return {
        /**
         * Create new nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Create nomenclature category
         * @param {NomenclatureCategoryCreateSchema} nomenclatureCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost(nomenclatureCategoryCreateSchema: NomenclatureCategoryCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureCategorySchema> {
            return localVarFp.nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost(nomenclatureCategoryCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete nomenclature category.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Delete nomenclature category
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete(nomenclatureCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete(nomenclatureCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all active and used nomenclature (sub-)/categories for markup manager.  Pagination and search by name is used.  For markup manager, get categories - isActive=True, hasReferences=True.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories and subcategories for markup manager
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet(page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<MarkupManagerNomenclatureCategoriesPage> {
            return localVarFp.nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet(page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories
         * @param {BaseSort} [sort] 
         * @param {NomenclatureCategoryQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet(sort?: BaseSort, order?: NomenclatureCategoryQueryOrder, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectNomenclatureCategoriesPage> {
            return localVarFp.nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet(sort, order, isActive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature categories
         * @param {BaseSort} [sort] 
         * @param {NomenclatureCategoryQueryOrder} [order] 
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet(sort?: BaseSort, order?: NomenclatureCategoryQueryOrder, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureCategoriesPage> {
            return localVarFp.nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet(sort, order, isActive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature category detail
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet(nomenclatureCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectNomenclatureCategorySchema> {
            return localVarFp.nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet(nomenclatureCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature category detail
         * @param {number} nomenclatureCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet(nomenclatureCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureCategoryDetailSchema> {
            return localVarFp.nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet(nomenclatureCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current nomenclature subcategories from Settings for select.  Pagination and search by name, categories is used.  For create or update pages, get only active categories - isActive=True.  Role needed: \'is_staff\'.
         * @summary Get all nomenclature subcategories for select widget
         * @param {Array<number>} category Filtering by category ID. If None - no subcategory will be shown.
         * @param {boolean} [isActive] 
         * @param {string} [searchFilterSelect] Search by name for select.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet(category: Array<number>, isActive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectNomenclatureSubcategoriesPage> {
            return localVarFp.nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet(category, isActive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
         * @summary Update nomenclature category
         * @param {number} nomenclatureCategoryId 
         * @param {NomenclatureCategoryUpdateSchema} nomenclatureCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut(nomenclatureCategoryId: number, nomenclatureCategoryUpdateSchema: NomenclatureCategoryUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureCategorySchema> {
            return localVarFp.nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut(nomenclatureCategoryId, nomenclatureCategoryUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature subcategory detail
         * @param {number} nomenclatureSubcategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet(nomenclatureSubcategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureSubcategorySelectSchema> {
            return localVarFp.nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet(nomenclatureSubcategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
         * @summary Get nomenclature subcategory detail
         * @param {number} nomenclatureSubcategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet(nomenclatureSubcategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclatureSubcategoryDetailSchema> {
            return localVarFp.nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet(nomenclatureSubcategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPostRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPostRequest {
    /**
     * 
     * @type {NomenclatureCategoryCreateSchema}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost
     */
    readonly nomenclatureCategoryCreateSchema: NomenclatureCategoryCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDeleteRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete
     */
    readonly nomenclatureCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {NomenclatureCategoryQueryOrder}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly order?: NomenclatureCategoryQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly isActive?: boolean

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {NomenclatureCategoryQueryOrder}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly order?: NomenclatureCategoryQueryOrder

    /**
     * 
     * @type {boolean}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly isActive?: boolean

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet
     */
    readonly nomenclatureCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet
     */
    readonly nomenclatureCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGetRequest {
    /**
     * Filtering by category ID. If None - no subcategory will be shown.
     * @type {Array<number>}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet
     */
    readonly category: Array<number>

    /**
     * 
     * @type {boolean}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet
     */
    readonly isActive?: boolean

    /**
     * Search by name for select.
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPutRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut
     */
    readonly nomenclatureCategoryId: number

    /**
     * 
     * @type {NomenclatureCategoryUpdateSchema}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut
     */
    readonly nomenclatureCategoryUpdateSchema: NomenclatureCategoryUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet
     */
    readonly nomenclatureSubcategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet operation in SettingsNomenclatureCategoriesApi.
 * @export
 * @interface SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGetRequest
 */
export interface SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet
     */
    readonly nomenclatureSubcategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsNomenclatureCategoriesApi - object-oriented interface
 * @export
 * @class SettingsNomenclatureCategoriesApi
 * @extends {BaseAPI}
 */
export class SettingsNomenclatureCategoriesApi extends BaseAPI {
    /**
     * Create new nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
     * @summary Create nomenclature category
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPostRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesCreateOneSettingsNomenclatureCategoriesPost(requestParameters.nomenclatureCategoryCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete nomenclature category.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
     * @summary Delete nomenclature category
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesDeleteOneSettingsNomenclatureCategoriesNomenclatureCategoryIdDelete(requestParameters.nomenclatureCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all active and used nomenclature (sub-)/categories for markup manager.  Pagination and search by name is used.  For markup manager, get categories - isActive=True, hasReferences=True.  Role needed: \'is_staff\'.
     * @summary Get all nomenclature categories and subcategories for markup manager
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesGetAllMarkupManagerSettingsNomenclatureCategoriesMarkupManagerGet(requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
     * @summary Get all nomenclature categories
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesGetAllSelectSettingsNomenclatureCategoriesSelectGet(requestParameters.sort, requestParameters.order, requestParameters.isActive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current nomenclature categories from Settings.  Pagination, ordering (default is desc date_created) by column is used.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
     * @summary Get all nomenclature categories
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesGetAllSettingsNomenclatureCategoriesGet(requestParameters.sort, requestParameters.order, requestParameters.isActive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
     * @summary Get nomenclature category detail
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesGetOneSelectSettingsNomenclatureCategoriesNomenclatureCategoryIdSelectGet(requestParameters.nomenclatureCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get nomenclature category detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
     * @summary Get nomenclature category detail
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesGetOneSettingsNomenclatureCategoriesNomenclatureCategoryIdGet(requestParameters.nomenclatureCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current nomenclature subcategories from Settings for select.  Pagination and search by name, categories is used.  For create or update pages, get only active categories - isActive=True.  Role needed: \'is_staff\'.
     * @summary Get all nomenclature subcategories for select widget
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesSubcategoriesGetAllSelectSettingsNomenclatureCategoriesSubcategoriesSelectGet(requestParameters.category, requestParameters.isActive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update nomenclature category.  The nomenclature category name must be unique within the nomenclature categories. Also, nomenclature subcategory names must be unique within the nomenclature subcategories.  Perms needed: \'nomenclature_category_change\'.  Role needed: \'is_staff\'.
     * @summary Update nomenclature category
     * @param {SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureCategoriesUpdateOneSettingsNomenclatureCategoriesNomenclatureCategoryIdPut(requestParameters.nomenclatureCategoryId, requestParameters.nomenclatureCategoryUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
     * @summary Get nomenclature subcategory detail
     * @param {SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureSubcategoriesGetOneSelectSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdSelectGet(requestParameters.nomenclatureSubcategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get nomenclature subcategory detail.  Perms needed: \'nomenclature_category_view\'.  Role needed: \'is_staff\'.
     * @summary Get nomenclature subcategory detail
     * @param {SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNomenclatureCategoriesApi
     */
    public nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet(requestParameters: SettingsNomenclatureCategoriesApiNomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsNomenclatureCategoriesApiFp(this.configuration).nomenclatureSubcategoriesGetOneSettingsNomenclatureCategoriesSubcategoriesNomenclatureSubcategoryIdGet(requestParameters.nomenclatureSubcategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsPositionsApi - axios parameter creator
 * @export
 */
export const SettingsPositionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create position.  Role check: is_staff.  Permission: position_change.
         * @summary Create position.
         * @param {PositionCreateSchema} positionCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsCreateSettingsPositionsPost: async (positionCreateSchema: PositionCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionCreateSchema' is not null or undefined
            assertParamExists('settingsDormantsPositionsCreateSettingsPositionsPost', 'positionCreateSchema', positionCreateSchema)
            const localVarPath = `/settings/positions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete position.  Role check: is_staff.  Permission: position_change.
         * @summary Delete position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete: async (positionId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionId' is not null or undefined
            assertParamExists('settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete', 'positionId', positionId)
            const localVarPath = `/settings/positions/{position_id}/`
                .replace(`{${"position_id"}}`, encodeURIComponent(String(positionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary Get position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet: async (positionId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionId' is not null or undefined
            assertParamExists('settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet', 'positionId', positionId)
            const localVarPath = `/settings/positions/{position_id}/select/`
                .replace(`{${"position_id"}}`, encodeURIComponent(String(positionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary Get position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsGetSettingsPositionsPositionIdGet: async (positionId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionId' is not null or undefined
            assertParamExists('settingsDormantsPositionsGetSettingsPositionsPositionIdGet', 'positionId', positionId)
            const localVarPath = `/settings/positions/{position_id}/`
                .replace(`{${"position_id"}}`, encodeURIComponent(String(positionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary List of positions.
         * @param {PositionQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsListSelectSettingsPositionsSelectGet: async (order?: PositionQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/positions/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary List of positions.
         * @param {PositionQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsListSettingsPositionsGet: async (order?: PositionQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/positions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update position.  Role check: is_staff.  Permission: position_change.
         * @summary Update position.
         * @param {number} positionId 
         * @param {PositionUpdateSchema} positionUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut: async (positionId: number, positionUpdateSchema: PositionUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionId' is not null or undefined
            assertParamExists('settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut', 'positionId', positionId)
            // verify required parameter 'positionUpdateSchema' is not null or undefined
            assertParamExists('settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut', 'positionUpdateSchema', positionUpdateSchema)
            const localVarPath = `/settings/positions/{position_id}/`
                .replace(`{${"position_id"}}`, encodeURIComponent(String(positionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsPositionsApi - functional programming interface
 * @export
 */
export const SettingsPositionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsPositionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create position.  Role check: is_staff.  Permission: position_change.
         * @summary Create position.
         * @param {PositionCreateSchema} positionCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsCreateSettingsPositionsPost(positionCreateSchema: PositionCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsCreateSettingsPositionsPost(positionCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete position.  Role check: is_staff.  Permission: position_change.
         * @summary Delete position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete(positionId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete(positionId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary Get position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet(positionId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionSimpleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet(positionId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary Get position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsGetSettingsPositionsPositionIdGet(positionId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsGetSettingsPositionsPositionIdGet(positionId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary List of positions.
         * @param {PositionQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsListSelectSettingsPositionsSelectGet(order?: PositionQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsListSelectSettingsPositionsSelectGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary List of positions.
         * @param {PositionQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsListSettingsPositionsGet(order?: PositionQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsListSettingsPositionsGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update position.  Role check: is_staff.  Permission: position_change.
         * @summary Update position.
         * @param {number} positionId 
         * @param {PositionUpdateSchema} positionUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut(positionId: number, positionUpdateSchema: PositionUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut(positionId, positionUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsPositionsApi - factory interface
 * @export
 */
export const SettingsPositionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsPositionsApiFp(configuration)
    return {
        /**
         * Create position.  Role check: is_staff.  Permission: position_change.
         * @summary Create position.
         * @param {PositionCreateSchema} positionCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsCreateSettingsPositionsPost(positionCreateSchema: PositionCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<PositionDetailSchema> {
            return localVarFp.settingsDormantsPositionsCreateSettingsPositionsPost(positionCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete position.  Role check: is_staff.  Permission: position_change.
         * @summary Delete position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete(positionId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete(positionId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary Get position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet(positionId: number, acceptLanguage?: string, options?: any): AxiosPromise<PositionSimpleSchema> {
            return localVarFp.settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet(positionId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary Get position.
         * @param {number} positionId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsGetSettingsPositionsPositionIdGet(positionId: number, acceptLanguage?: string, options?: any): AxiosPromise<PositionDetailSchema> {
            return localVarFp.settingsDormantsPositionsGetSettingsPositionsPositionIdGet(positionId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary List of positions.
         * @param {PositionQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsListSelectSettingsPositionsSelectGet(order?: PositionQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<PositionPage> {
            return localVarFp.settingsDormantsPositionsListSelectSettingsPositionsSelectGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get position.  Role check: is_staff.  Permission: position_view.
         * @summary List of positions.
         * @param {PositionQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsListSettingsPositionsGet(order?: PositionQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<PositionPage> {
            return localVarFp.settingsDormantsPositionsListSettingsPositionsGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update position.  Role check: is_staff.  Permission: position_change.
         * @summary Update position.
         * @param {number} positionId 
         * @param {PositionUpdateSchema} positionUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut(positionId: number, positionUpdateSchema: PositionUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<PositionDetailSchema> {
            return localVarFp.settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut(positionId, positionUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsDormantsPositionsCreateSettingsPositionsPost operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsCreateSettingsPositionsPostRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsCreateSettingsPositionsPostRequest {
    /**
     * 
     * @type {PositionCreateSchema}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsCreateSettingsPositionsPost
     */
    readonly positionCreateSchema: PositionCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsCreateSettingsPositionsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsDeleteSettingsPositionsPositionIdDeleteRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsDeleteSettingsPositionsPositionIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete
     */
    readonly positionId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGetRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet
     */
    readonly positionId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsPositionsGetSettingsPositionsPositionIdGet operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsGetSettingsPositionsPositionIdGetRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsGetSettingsPositionsPositionIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsGetSettingsPositionsPositionIdGet
     */
    readonly positionId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsGetSettingsPositionsPositionIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsPositionsListSelectSettingsPositionsSelectGet operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGetRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGetRequest {
    /**
     * 
     * @type {PositionQueryOrder}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly order?: PositionQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsPositionsListSettingsPositionsGet operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGetRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGetRequest {
    /**
     * 
     * @type {PositionQueryOrder}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly order?: PositionQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut operation in SettingsPositionsApi.
 * @export
 * @interface SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPutRequest
 */
export interface SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPut
     */
    readonly positionId: number

    /**
     * 
     * @type {PositionUpdateSchema}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPut
     */
    readonly positionUpdateSchema: PositionUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsPositionsApi - object-oriented interface
 * @export
 * @class SettingsPositionsApi
 * @extends {BaseAPI}
 */
export class SettingsPositionsApi extends BaseAPI {
    /**
     * Create position.  Role check: is_staff.  Permission: position_change.
     * @summary Create position.
     * @param {SettingsPositionsApiSettingsDormantsPositionsCreateSettingsPositionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsCreateSettingsPositionsPost(requestParameters: SettingsPositionsApiSettingsDormantsPositionsCreateSettingsPositionsPostRequest, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsCreateSettingsPositionsPost(requestParameters.positionCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete position.  Role check: is_staff.  Permission: position_change.
     * @summary Delete position.
     * @param {SettingsPositionsApiSettingsDormantsPositionsDeleteSettingsPositionsPositionIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete(requestParameters: SettingsPositionsApiSettingsDormantsPositionsDeleteSettingsPositionsPositionIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsDeleteSettingsPositionsPositionIdDelete(requestParameters.positionId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position.  Role check: is_staff.  Permission: position_view.
     * @summary Get position.
     * @param {SettingsPositionsApiSettingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet(requestParameters: SettingsPositionsApiSettingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsGetSelectSettingsPositionsPositionIdSelectGet(requestParameters.positionId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position.  Role check: is_staff.  Permission: position_view.
     * @summary Get position.
     * @param {SettingsPositionsApiSettingsDormantsPositionsGetSettingsPositionsPositionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsGetSettingsPositionsPositionIdGet(requestParameters: SettingsPositionsApiSettingsDormantsPositionsGetSettingsPositionsPositionIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsGetSettingsPositionsPositionIdGet(requestParameters.positionId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position.  Role check: is_staff.  Permission: position_view.
     * @summary List of positions.
     * @param {SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsListSelectSettingsPositionsSelectGet(requestParameters: SettingsPositionsApiSettingsDormantsPositionsListSelectSettingsPositionsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsListSelectSettingsPositionsSelectGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get position.  Role check: is_staff.  Permission: position_view.
     * @summary List of positions.
     * @param {SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsListSettingsPositionsGet(requestParameters: SettingsPositionsApiSettingsDormantsPositionsListSettingsPositionsGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsListSettingsPositionsGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update position.  Role check: is_staff.  Permission: position_change.
     * @summary Update position.
     * @param {SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPositionsApi
     */
    public settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut(requestParameters: SettingsPositionsApiSettingsDormantsPositionsUpdateSettingsPositionsPositionIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsPositionsApiFp(this.configuration).settingsDormantsPositionsUpdateSettingsPositionsPositionIdPut(requestParameters.positionId, requestParameters.positionUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsPriceCategoriesApi - axios parameter creator
 * @export
 */
export const SettingsPriceCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get nomenclature prices for the selected price category.  Used for CLIENT order(create/update) endpoints. If such price category is inactive for a product nomenclature it will be equal to 0. For service nomenclature the fixed price is taken if it is filled otherwise 0.  Role check: is_staff.  No permissions.
         * @summary Get nomenclature prices for the selected price category.
         * @param {number} priceCategoryId 
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet: async (priceCategoryId: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet', 'priceCategoryId', priceCategoryId)
            // verify required parameter 'nomenclatureIds' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet', 'nomenclatureIds', nomenclatureIds)
            const localVarPath = `/settings/price-categories/{price_category_id}/client-order/nomenclature-prices/`
                .replace(`{${"price_category_id"}}`, encodeURIComponent(String(priceCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nomenclatureIds) {
                localVarQueryParameter['nomenclatureIds'] = nomenclatureIds;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create price category.  Role check: is_staff.  Permission: price_category_change.
         * @summary Create price category.
         * @param {PriceCategoryCreateSchema} priceCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost: async (priceCategoryCreateSchema: PriceCategoryCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryCreateSchema' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost', 'priceCategoryCreateSchema', priceCategoryCreateSchema)
            const localVarPath = `/settings/price-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(priceCategoryCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete price category.  Role check: is_staff.  Permission: price_category_change.
         * @summary Delete price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete: async (priceCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete', 'priceCategoryId', priceCategoryId)
            const localVarPath = `/settings/price-categories/{price_category_id}/`
                .replace(`{${"price_category_id"}}`, encodeURIComponent(String(priceCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary Get price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet: async (priceCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet', 'priceCategoryId', priceCategoryId)
            const localVarPath = `/settings/price-categories/{price_category_id}/select/`
                .replace(`{${"price_category_id"}}`, encodeURIComponent(String(priceCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary Get price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet: async (priceCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet', 'priceCategoryId', priceCategoryId)
            const localVarPath = `/settings/price-categories/{price_category_id}/`
                .replace(`{${"price_category_id"}}`, encodeURIComponent(String(priceCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary List of price categories.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {boolean} [hasNomenclatureReferences] 
         * @param {boolean} [excludeBaseNotRetailPrices] 
         * @param {boolean} [forSupplierOrder] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet: async (order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, hasNomenclatureReferences?: boolean, excludeBaseNotRetailPrices?: boolean, forSupplierOrder?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/price-categories/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (hasNomenclatureReferences !== undefined) {
                localVarQueryParameter['hasNomenclatureReferences'] = hasNomenclatureReferences;
            }

            if (excludeBaseNotRetailPrices !== undefined) {
                localVarQueryParameter['excludeBaseNotRetailPrices'] = excludeBaseNotRetailPrices;
            }

            if (forSupplierOrder !== undefined) {
                localVarQueryParameter['forSupplierOrder'] = forSupplierOrder;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary List of price categories.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {boolean} [hasNomenclatureReferences] 
         * @param {boolean} [excludeBaseNotRetailPrices] 
         * @param {boolean} [forSupplierOrder] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet: async (order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, hasNomenclatureReferences?: boolean, excludeBaseNotRetailPrices?: boolean, forSupplierOrder?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/price-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (hasNomenclatureReferences !== undefined) {
                localVarQueryParameter['hasNomenclatureReferences'] = hasNomenclatureReferences;
            }

            if (excludeBaseNotRetailPrices !== undefined) {
                localVarQueryParameter['excludeBaseNotRetailPrices'] = excludeBaseNotRetailPrices;
            }

            if (forSupplierOrder !== undefined) {
                localVarQueryParameter['forSupplierOrder'] = forSupplierOrder;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get nomenclature prices for the selected price category.  Only \"Прайсовая\" price category is allowed. /settings/price-categories/select/ - use forSupplierOrder=true query param to get it.  Used for SUPPLIER order(create/update) endpoints. 1) For each nomenclature we try to get the last downloaded supplier\'s price with the selected currency. 2) If there is no such price, we try to get the nomenclature average market price by converting it to the selected currency at the selected order rate.  Role check: is_staff.  No permissions.
         * @summary Get nomenclature prices for the selected price category.
         * @param {number} priceCategoryId 
         * @param {number} currencyId Currency from supplier order.
         * @param {number} rate Currency rate from supplier order.
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet: async (priceCategoryId: number, currencyId: number, rate: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet', 'priceCategoryId', priceCategoryId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet', 'currencyId', currencyId)
            // verify required parameter 'rate' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet', 'rate', rate)
            // verify required parameter 'nomenclatureIds' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet', 'nomenclatureIds', nomenclatureIds)
            const localVarPath = `/settings/price-categories/{price_category_id}/supplier-order/nomenclature-prices/`
                .replace(`{${"price_category_id"}}`, encodeURIComponent(String(priceCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (rate !== undefined) {
                localVarQueryParameter['rate'] = rate;
            }

            if (nomenclatureIds) {
                localVarQueryParameter['nomenclatureIds'] = nomenclatureIds;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update price category.  Role check: is_staff.  Permission: price_category_change.  Only base or retail price categories can be updated.
         * @summary Update price category.
         * @param {number} priceCategoryId 
         * @param {PriceCategoryUpdateSchema} priceCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut: async (priceCategoryId: number, priceCategoryUpdateSchema: PriceCategoryUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut', 'priceCategoryId', priceCategoryId)
            // verify required parameter 'priceCategoryUpdateSchema' is not null or undefined
            assertParamExists('settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut', 'priceCategoryUpdateSchema', priceCategoryUpdateSchema)
            const localVarPath = `/settings/price-categories/{price_category_id}/`
                .replace(`{${"price_category_id"}}`, encodeURIComponent(String(priceCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(priceCategoryUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsPriceCategoriesApi - functional programming interface
 * @export
 */
export const SettingsPriceCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsPriceCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get nomenclature prices for the selected price category.  Used for CLIENT order(create/update) endpoints. If such price category is inactive for a product nomenclature it will be equal to 0. For service nomenclature the fixed price is taken if it is filled otherwise 0.  Role check: is_staff.  No permissions.
         * @summary Get nomenclature prices for the selected price category.
         * @param {number} priceCategoryId 
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet(priceCategoryId: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturePricesSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet(priceCategoryId, nomenclatureIds, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create price category.  Role check: is_staff.  Permission: price_category_change.
         * @summary Create price category.
         * @param {PriceCategoryCreateSchema} priceCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost(priceCategoryCreateSchema: PriceCategoryCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost(priceCategoryCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete price category.  Role check: is_staff.  Permission: price_category_change.
         * @summary Delete price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete(priceCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete(priceCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary Get price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet(priceCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceCategorySimpleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet(priceCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary Get price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet(priceCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet(priceCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary List of price categories.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {boolean} [hasNomenclatureReferences] 
         * @param {boolean} [excludeBaseNotRetailPrices] 
         * @param {boolean} [forSupplierOrder] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet(order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, hasNomenclatureReferences?: boolean, excludeBaseNotRetailPrices?: boolean, forSupplierOrder?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet(order, sort, excludeInactive, hasNomenclatureReferences, excludeBaseNotRetailPrices, forSupplierOrder, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary List of price categories.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {boolean} [hasNomenclatureReferences] 
         * @param {boolean} [excludeBaseNotRetailPrices] 
         * @param {boolean} [forSupplierOrder] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet(order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, hasNomenclatureReferences?: boolean, excludeBaseNotRetailPrices?: boolean, forSupplierOrder?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet(order, sort, excludeInactive, hasNomenclatureReferences, excludeBaseNotRetailPrices, forSupplierOrder, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get nomenclature prices for the selected price category.  Only \"Прайсовая\" price category is allowed. /settings/price-categories/select/ - use forSupplierOrder=true query param to get it.  Used for SUPPLIER order(create/update) endpoints. 1) For each nomenclature we try to get the last downloaded supplier\'s price with the selected currency. 2) If there is no such price, we try to get the nomenclature average market price by converting it to the selected currency at the selected order rate.  Role check: is_staff.  No permissions.
         * @summary Get nomenclature prices for the selected price category.
         * @param {number} priceCategoryId 
         * @param {number} currencyId Currency from supplier order.
         * @param {number} rate Currency rate from supplier order.
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet(priceCategoryId: number, currencyId: number, rate: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturePricesSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet(priceCategoryId, currencyId, rate, nomenclatureIds, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update price category.  Role check: is_staff.  Permission: price_category_change.  Only base or retail price categories can be updated.
         * @summary Update price category.
         * @param {number} priceCategoryId 
         * @param {PriceCategoryUpdateSchema} priceCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut(priceCategoryId: number, priceCategoryUpdateSchema: PriceCategoryUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut(priceCategoryId, priceCategoryUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsPriceCategoriesApi - factory interface
 * @export
 */
export const SettingsPriceCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsPriceCategoriesApiFp(configuration)
    return {
        /**
         * Get nomenclature prices for the selected price category.  Used for CLIENT order(create/update) endpoints. If such price category is inactive for a product nomenclature it will be equal to 0. For service nomenclature the fixed price is taken if it is filled otherwise 0.  Role check: is_staff.  No permissions.
         * @summary Get nomenclature prices for the selected price category.
         * @param {number} priceCategoryId 
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet(priceCategoryId: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturePricesSchema> {
            return localVarFp.settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet(priceCategoryId, nomenclatureIds, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create price category.  Role check: is_staff.  Permission: price_category_change.
         * @summary Create price category.
         * @param {PriceCategoryCreateSchema} priceCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost(priceCategoryCreateSchema: PriceCategoryCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<PriceCategoryDetailSchema> {
            return localVarFp.settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost(priceCategoryCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete price category.  Role check: is_staff.  Permission: price_category_change.
         * @summary Delete price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete(priceCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete(priceCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary Get price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet(priceCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<PriceCategorySimpleSchema> {
            return localVarFp.settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet(priceCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary Get price category.
         * @param {number} priceCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet(priceCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<PriceCategoryDetailSchema> {
            return localVarFp.settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet(priceCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary List of price categories.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {boolean} [hasNomenclatureReferences] 
         * @param {boolean} [excludeBaseNotRetailPrices] 
         * @param {boolean} [forSupplierOrder] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet(order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, hasNomenclatureReferences?: boolean, excludeBaseNotRetailPrices?: boolean, forSupplierOrder?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<PriceCategoryPage> {
            return localVarFp.settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet(order, sort, excludeInactive, hasNomenclatureReferences, excludeBaseNotRetailPrices, forSupplierOrder, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get price category.  Role check: is_staff.  Permission: price_category_view.
         * @summary List of price categories.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {boolean} [hasNomenclatureReferences] 
         * @param {boolean} [excludeBaseNotRetailPrices] 
         * @param {boolean} [forSupplierOrder] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet(order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, hasNomenclatureReferences?: boolean, excludeBaseNotRetailPrices?: boolean, forSupplierOrder?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<PriceCategoryPage> {
            return localVarFp.settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet(order, sort, excludeInactive, hasNomenclatureReferences, excludeBaseNotRetailPrices, forSupplierOrder, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get nomenclature prices for the selected price category.  Only \"Прайсовая\" price category is allowed. /settings/price-categories/select/ - use forSupplierOrder=true query param to get it.  Used for SUPPLIER order(create/update) endpoints. 1) For each nomenclature we try to get the last downloaded supplier\'s price with the selected currency. 2) If there is no such price, we try to get the nomenclature average market price by converting it to the selected currency at the selected order rate.  Role check: is_staff.  No permissions.
         * @summary Get nomenclature prices for the selected price category.
         * @param {number} priceCategoryId 
         * @param {number} currencyId Currency from supplier order.
         * @param {number} rate Currency rate from supplier order.
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet(priceCategoryId: number, currencyId: number, rate: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturePricesSchema> {
            return localVarFp.settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet(priceCategoryId, currencyId, rate, nomenclatureIds, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update price category.  Role check: is_staff.  Permission: price_category_change.  Only base or retail price categories can be updated.
         * @summary Update price category.
         * @param {number} priceCategoryId 
         * @param {PriceCategoryUpdateSchema} priceCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut(priceCategoryId: number, priceCategoryUpdateSchema: PriceCategoryUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<PriceCategoryDetailSchema> {
            return localVarFp.settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut(priceCategoryId, priceCategoryUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGetRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet
     */
    readonly priceCategoryId: number

    /**
     * Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
     * @type {Array<number>}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet
     */
    readonly nomenclatureIds: Array<number>

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPostRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPostRequest {
    /**
     * 
     * @type {PriceCategoryCreateSchema}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost
     */
    readonly priceCategoryCreateSchema: PriceCategoryCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDeleteRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete
     */
    readonly priceCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGetRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet
     */
    readonly priceCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGetRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet
     */
    readonly priceCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGetRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGetRequest {
    /**
     * 
     * @type {CategoryQueryOrder}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly order?: CategoryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly hasNomenclatureReferences?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly excludeBaseNotRetailPrices?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly forSupplierOrder?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGetRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGetRequest {
    /**
     * 
     * @type {CategoryQueryOrder}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly order?: CategoryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly hasNomenclatureReferences?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly excludeBaseNotRetailPrices?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly forSupplierOrder?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGetRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet
     */
    readonly priceCategoryId: number

    /**
     * Currency from supplier order.
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet
     */
    readonly currencyId: number

    /**
     * Currency rate from supplier order.
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet
     */
    readonly rate: number

    /**
     * Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
     * @type {Array<number>}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet
     */
    readonly nomenclatureIds: Array<number>

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut operation in SettingsPriceCategoriesApi.
 * @export
 * @interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPutRequest
 */
export interface SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut
     */
    readonly priceCategoryId: number

    /**
     * 
     * @type {PriceCategoryUpdateSchema}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut
     */
    readonly priceCategoryUpdateSchema: PriceCategoryUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsPriceCategoriesApi - object-oriented interface
 * @export
 * @class SettingsPriceCategoriesApi
 * @extends {BaseAPI}
 */
export class SettingsPriceCategoriesApi extends BaseAPI {
    /**
     * Get nomenclature prices for the selected price category.  Used for CLIENT order(create/update) endpoints. If such price category is inactive for a product nomenclature it will be equal to 0. For service nomenclature the fixed price is taken if it is filled otherwise 0.  Role check: is_staff.  No permissions.
     * @summary Get nomenclature prices for the selected price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGetRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesClientOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdClientOrderNomenclaturePricesGet(requestParameters.priceCategoryId, requestParameters.nomenclatureIds, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create price category.  Role check: is_staff.  Permission: price_category_change.
     * @summary Create price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPostRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesCreateSettingsPriceCategoriesPost(requestParameters.priceCategoryCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete price category.  Role check: is_staff.  Permission: price_category_change.
     * @summary Delete price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesDeleteSettingsPriceCategoriesPriceCategoryIdDelete(requestParameters.priceCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get price category.  Role check: is_staff.  Permission: price_category_view.
     * @summary Get price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesGetSelectSettingsPriceCategoriesPriceCategoryIdSelectGet(requestParameters.priceCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get price category.  Role check: is_staff.  Permission: price_category_view.
     * @summary Get price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesGetSettingsPriceCategoriesPriceCategoryIdGet(requestParameters.priceCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get price category.  Role check: is_staff.  Permission: price_category_view.
     * @summary List of price categories.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesListSelectSettingsPriceCategoriesSelectGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.hasNomenclatureReferences, requestParameters.excludeBaseNotRetailPrices, requestParameters.forSupplierOrder, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get price category.  Role check: is_staff.  Permission: price_category_view.
     * @summary List of price categories.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesListSettingsPriceCategoriesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesListSettingsPriceCategoriesGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.hasNomenclatureReferences, requestParameters.excludeBaseNotRetailPrices, requestParameters.forSupplierOrder, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get nomenclature prices for the selected price category.  Only \"Прайсовая\" price category is allowed. /settings/price-categories/select/ - use forSupplierOrder=true query param to get it.  Used for SUPPLIER order(create/update) endpoints. 1) For each nomenclature we try to get the last downloaded supplier\'s price with the selected currency. 2) If there is no such price, we try to get the nomenclature average market price by converting it to the selected currency at the selected order rate.  Role check: is_staff.  No permissions.
     * @summary Get nomenclature prices for the selected price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGetRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesSupplierOrderNomenclaturePricesSettingsPriceCategoriesPriceCategoryIdSupplierOrderNomenclaturePricesGet(requestParameters.priceCategoryId, requestParameters.currencyId, requestParameters.rate, requestParameters.nomenclatureIds, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update price category.  Role check: is_staff.  Permission: price_category_change.  Only base or retail price categories can be updated.
     * @summary Update price category.
     * @param {SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsPriceCategoriesApi
     */
    public settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut(requestParameters: SettingsPriceCategoriesApiSettingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsPriceCategoriesApiFp(this.configuration).settingsCategoriesPriceCategoriesUpdateSettingsPriceCategoriesPriceCategoryIdPut(requestParameters.priceCategoryId, requestParameters.priceCategoryUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsSupplierCategoriesApi - axios parameter creator
 * @export
 */
export const SettingsSupplierCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Create supplier category.
         * @param {UserCategoryCreateSchema} userCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost: async (userCategoryCreateSchema: UserCategoryCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryCreateSchema' is not null or undefined
            assertParamExists('settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost', 'userCategoryCreateSchema', userCategoryCreateSchema)
            const localVarPath = `/settings/user-categories/supplier/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCategoryCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Delete supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete: async (userCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete', 'userCategoryId', userCategoryId)
            const localVarPath = `/settings/user-categories/supplier/{user_category_id}/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
         * @summary Get supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet: async (userCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet', 'userCategoryId', userCategoryId)
            const localVarPath = `/settings/user-categories/supplier/{user_category_id}/select/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
         * @summary Get supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet: async (userCategoryId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet', 'userCategoryId', userCategoryId)
            const localVarPath = `/settings/user-categories/supplier/{user_category_id}/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
         * @summary List of supplier categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet: async (searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/user-categories/supplier/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
         * @summary List of supplier categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet: async (searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/user-categories/supplier/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Update supplier category.
         * @param {number} userCategoryId 
         * @param {UserCategoryUpdateSchema} userCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut: async (userCategoryId: number, userCategoryUpdateSchema: UserCategoryUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCategoryId' is not null or undefined
            assertParamExists('settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut', 'userCategoryId', userCategoryId)
            // verify required parameter 'userCategoryUpdateSchema' is not null or undefined
            assertParamExists('settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut', 'userCategoryUpdateSchema', userCategoryUpdateSchema)
            const localVarPath = `/settings/user-categories/supplier/{user_category_id}/`
                .replace(`{${"user_category_id"}}`, encodeURIComponent(String(userCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCategoryUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsSupplierCategoriesApi - functional programming interface
 * @export
 */
export const SettingsSupplierCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsSupplierCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Create supplier category.
         * @param {UserCategoryCreateSchema} userCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost(userCategoryCreateSchema: UserCategoryCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost(userCategoryCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Delete supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete(userCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete(userCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
         * @summary Get supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet(userCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleUserCategoryReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet(userCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
         * @summary Get supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet(userCategoryId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet(userCategoryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
         * @summary List of supplier categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
         * @summary List of supplier categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Update supplier category.
         * @param {number} userCategoryId 
         * @param {UserCategoryUpdateSchema} userCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut(userCategoryId: number, userCategoryUpdateSchema: UserCategoryUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCategoryDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut(userCategoryId, userCategoryUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsSupplierCategoriesApi - factory interface
 * @export
 */
export const SettingsSupplierCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsSupplierCategoriesApiFp(configuration)
    return {
        /**
         * Create supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Create supplier category.
         * @param {UserCategoryCreateSchema} userCategoryCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost(userCategoryCreateSchema: UserCategoryCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryDetailSchema> {
            return localVarFp.settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost(userCategoryCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Delete supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete(userCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete(userCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
         * @summary Get supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet(userCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<SimpleUserCategoryReadSchema> {
            return localVarFp.settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet(userCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
         * @summary Get supplier category.
         * @param {number} userCategoryId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet(userCategoryId: number, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryDetailSchema> {
            return localVarFp.settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet(userCategoryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
         * @summary List of supplier categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryPage> {
            return localVarFp.settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
         * @summary List of supplier categories.
         * @param {string} [searchFilter] Search user categories by name.
         * @param {CategoryQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet(searchFilter?: string, order?: CategoryQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryPage> {
            return localVarFp.settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet(searchFilter, order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update supplier category. Role check: is_staff. Permission: supplier_category_change.
         * @summary Update supplier category.
         * @param {number} userCategoryId 
         * @param {UserCategoryUpdateSchema} userCategoryUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut(userCategoryId: number, userCategoryUpdateSchema: UserCategoryUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<UserCategoryDetailSchema> {
            return localVarFp.settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut(userCategoryId, userCategoryUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPostRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPostRequest {
    /**
     * 
     * @type {UserCategoryCreateSchema}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost
     */
    readonly userCategoryCreateSchema: UserCategoryCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDeleteRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGetRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGetRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGetRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGetRequest {
    /**
     * Search user categories by name.
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {CategoryQueryOrder}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly order?: CategoryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGetRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGetRequest {
    /**
     * Search user categories by name.
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly searchFilter?: string

    /**
     * 
     * @type {CategoryQueryOrder}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly order?: CategoryQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut operation in SettingsSupplierCategoriesApi.
 * @export
 * @interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPutRequest
 */
export interface SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut
     */
    readonly userCategoryId: number

    /**
     * 
     * @type {UserCategoryUpdateSchema}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut
     */
    readonly userCategoryUpdateSchema: UserCategoryUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsSupplierCategoriesApi - object-oriented interface
 * @export
 * @class SettingsSupplierCategoriesApi
 * @extends {BaseAPI}
 */
export class SettingsSupplierCategoriesApi extends BaseAPI {
    /**
     * Create supplier category. Role check: is_staff. Permission: supplier_category_change.
     * @summary Create supplier category.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPostRequest, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesCreateSettingsUserCategoriesSupplierPost(requestParameters.userCategoryCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete supplier category. Role check: is_staff. Permission: supplier_category_change.
     * @summary Delete supplier category.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesDeleteSettingsUserCategoriesSupplierUserCategoryIdDelete(requestParameters.userCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
     * @summary Get supplier category.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesGetSelectSettingsUserCategoriesSupplierUserCategoryIdSelectGet(requestParameters.userCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier category. Role check: is_staff. Permission: supplier_category_view.
     * @summary Get supplier category.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesGetSettingsUserCategoriesSupplierUserCategoryIdGet(requestParameters.userCategoryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
     * @summary List of supplier categories.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesListSelectSettingsUserCategoriesSupplierSelectGet(requestParameters.searchFilter, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of supplier categories. Role check: is_staff. Permission: supplier_category_view.
     * @summary List of supplier categories.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesListSettingsUserCategoriesSupplierGet(requestParameters.searchFilter, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update supplier category. Role check: is_staff. Permission: supplier_category_change.
     * @summary Update supplier category.
     * @param {SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupplierCategoriesApi
     */
    public settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut(requestParameters: SettingsSupplierCategoriesApiSettingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsSupplierCategoriesApiFp(this.configuration).settingsCategoriesSupplierCategoriesUpdateSettingsUserCategoriesSupplierUserCategoryIdPut(requestParameters.userCategoryId, requestParameters.userCategoryUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsSupportEmailApi - axios parameter creator
 * @export
 */
export const SettingsSupportEmailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get support email.  Role check: is_staff.  Permission: support_email_view.
         * @summary Get support email.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsSupportEmailGetSettingsSupportEmailGet: async (acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/support-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update support email.  Role check: is_staff.  Permission: support_email_view.
         * @summary Get support email.
         * @param {SupportEmailUpdateSchema} supportEmailUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsSupportEmailUpdateSettingsSupportEmailPut: async (supportEmailUpdateSchema: SupportEmailUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supportEmailUpdateSchema' is not null or undefined
            assertParamExists('settingsDormantsSupportEmailUpdateSettingsSupportEmailPut', 'supportEmailUpdateSchema', supportEmailUpdateSchema)
            const localVarPath = `/settings/support-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportEmailUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsSupportEmailApi - functional programming interface
 * @export
 */
export const SettingsSupportEmailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsSupportEmailApiAxiosParamCreator(configuration)
    return {
        /**
         * Get support email.  Role check: is_staff.  Permission: support_email_view.
         * @summary Get support email.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsSupportEmailGetSettingsSupportEmailGet(acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportEmailDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsSupportEmailGetSettingsSupportEmailGet(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update support email.  Role check: is_staff.  Permission: support_email_view.
         * @summary Get support email.
         * @param {SupportEmailUpdateSchema} supportEmailUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsDormantsSupportEmailUpdateSettingsSupportEmailPut(supportEmailUpdateSchema: SupportEmailUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportEmailDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsDormantsSupportEmailUpdateSettingsSupportEmailPut(supportEmailUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsSupportEmailApi - factory interface
 * @export
 */
export const SettingsSupportEmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsSupportEmailApiFp(configuration)
    return {
        /**
         * Get support email.  Role check: is_staff.  Permission: support_email_view.
         * @summary Get support email.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsSupportEmailGetSettingsSupportEmailGet(acceptLanguage?: string, options?: any): AxiosPromise<SupportEmailDetailSchema> {
            return localVarFp.settingsDormantsSupportEmailGetSettingsSupportEmailGet(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update support email.  Role check: is_staff.  Permission: support_email_view.
         * @summary Get support email.
         * @param {SupportEmailUpdateSchema} supportEmailUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsDormantsSupportEmailUpdateSettingsSupportEmailPut(supportEmailUpdateSchema: SupportEmailUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupportEmailDetailSchema> {
            return localVarFp.settingsDormantsSupportEmailUpdateSettingsSupportEmailPut(supportEmailUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsDormantsSupportEmailGetSettingsSupportEmailGet operation in SettingsSupportEmailApi.
 * @export
 * @interface SettingsSupportEmailApiSettingsDormantsSupportEmailGetSettingsSupportEmailGetRequest
 */
export interface SettingsSupportEmailApiSettingsDormantsSupportEmailGetSettingsSupportEmailGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SettingsSupportEmailApiSettingsDormantsSupportEmailGetSettingsSupportEmailGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsDormantsSupportEmailUpdateSettingsSupportEmailPut operation in SettingsSupportEmailApi.
 * @export
 * @interface SettingsSupportEmailApiSettingsDormantsSupportEmailUpdateSettingsSupportEmailPutRequest
 */
export interface SettingsSupportEmailApiSettingsDormantsSupportEmailUpdateSettingsSupportEmailPutRequest {
    /**
     * 
     * @type {SupportEmailUpdateSchema}
     * @memberof SettingsSupportEmailApiSettingsDormantsSupportEmailUpdateSettingsSupportEmailPut
     */
    readonly supportEmailUpdateSchema: SupportEmailUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsSupportEmailApiSettingsDormantsSupportEmailUpdateSettingsSupportEmailPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsSupportEmailApi - object-oriented interface
 * @export
 * @class SettingsSupportEmailApi
 * @extends {BaseAPI}
 */
export class SettingsSupportEmailApi extends BaseAPI {
    /**
     * Get support email.  Role check: is_staff.  Permission: support_email_view.
     * @summary Get support email.
     * @param {SettingsSupportEmailApiSettingsDormantsSupportEmailGetSettingsSupportEmailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupportEmailApi
     */
    public settingsDormantsSupportEmailGetSettingsSupportEmailGet(requestParameters: SettingsSupportEmailApiSettingsDormantsSupportEmailGetSettingsSupportEmailGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsSupportEmailApiFp(this.configuration).settingsDormantsSupportEmailGetSettingsSupportEmailGet(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update support email.  Role check: is_staff.  Permission: support_email_view.
     * @summary Get support email.
     * @param {SettingsSupportEmailApiSettingsDormantsSupportEmailUpdateSettingsSupportEmailPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSupportEmailApi
     */
    public settingsDormantsSupportEmailUpdateSettingsSupportEmailPut(requestParameters: SettingsSupportEmailApiSettingsDormantsSupportEmailUpdateSettingsSupportEmailPutRequest, options?: AxiosRequestConfig) {
        return SettingsSupportEmailApiFp(this.configuration).settingsDormantsSupportEmailUpdateSettingsSupportEmailPut(requestParameters.supportEmailUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsTermsOfDeliveryIncotermsApi - axios parameter creator
 * @export
 */
export const SettingsTermsOfDeliveryIncotermsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Create new terms of delivery incoterm
         * @param {IncotermCreateSchema} incotermCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsCreateOneSettingsIncotermsPost: async (incotermCreateSchema: IncotermCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incotermCreateSchema' is not null or undefined
            assertParamExists('incotermsCreateOneSettingsIncotermsPost', 'incotermCreateSchema', incotermCreateSchema)
            const localVarPath = `/settings/incoterms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incotermCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete terms of delivery incoterm.  Deletion is not available if the incoterm is applied somewhere.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Delete terms of delivery incoterm
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsDeleteOneSettingsIncotermsIncotermIdDelete: async (incotermId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incotermId' is not null or undefined
            assertParamExists('incotermsDeleteOneSettingsIncotermsIncotermIdDelete', 'incotermId', incotermId)
            const localVarPath = `/settings/incoterms/{incoterm_id}/`
                .replace(`{${"incoterm_id"}}`, encodeURIComponent(String(incotermId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get all incoterms delivery terms
         * @param {BaseSort} [sort] 
         * @param {IncotermQueryOrder} [order] 
         * @param {string} [searchFilter] Search by term and delivery terms
         * @param {IncotermCategoryFilter} [category] Filtering by category. If None - all incoterms will be shown.
         * @param {boolean} [isActive] Get active or inactive incoterms. If None - all incoterms will be shown
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetAllSelectSettingsIncotermsSelectGet: async (sort?: BaseSort, order?: IncotermQueryOrder, searchFilter?: string, category?: IncotermCategoryFilter, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/incoterms/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get all incoterms delivery terms
         * @param {BaseSort} [sort] 
         * @param {IncotermQueryOrder} [order] 
         * @param {string} [searchFilter] Search by term and delivery terms
         * @param {IncotermCategoryFilter} [category] Filtering by category. If None - all incoterms will be shown.
         * @param {boolean} [isActive] Get active or inactive incoterms. If None - all incoterms will be shown
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetAllSettingsIncotermsGet: async (sort?: BaseSort, order?: IncotermQueryOrder, searchFilter?: string, category?: IncotermCategoryFilter, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/incoterms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get terms of delivery incoterm detail
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet: async (incotermId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incotermId' is not null or undefined
            assertParamExists('incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet', 'incotermId', incotermId)
            const localVarPath = `/settings/incoterms/{incoterm_id}/select/`
                .replace(`{${"incoterm_id"}}`, encodeURIComponent(String(incotermId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get terms of delivery incoterm detail
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetOneSettingsIncotermsIncotermIdGet: async (incotermId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incotermId' is not null or undefined
            assertParamExists('incotermsGetOneSettingsIncotermsIncotermIdGet', 'incotermId', incotermId)
            const localVarPath = `/settings/incoterms/{incoterm_id}/`
                .replace(`{${"incoterm_id"}}`, encodeURIComponent(String(incotermId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Update terms of delivery incoterm
         * @param {number} incotermId 
         * @param {IncotermUpdateSchema} incotermUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsUpdateOneSettingsIncotermsIncotermIdPut: async (incotermId: number, incotermUpdateSchema: IncotermUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incotermId' is not null or undefined
            assertParamExists('incotermsUpdateOneSettingsIncotermsIncotermIdPut', 'incotermId', incotermId)
            // verify required parameter 'incotermUpdateSchema' is not null or undefined
            assertParamExists('incotermsUpdateOneSettingsIncotermsIncotermIdPut', 'incotermUpdateSchema', incotermUpdateSchema)
            const localVarPath = `/settings/incoterms/{incoterm_id}/`
                .replace(`{${"incoterm_id"}}`, encodeURIComponent(String(incotermId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incotermUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsTermsOfDeliveryIncotermsApi - functional programming interface
 * @export
 */
export const SettingsTermsOfDeliveryIncotermsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsTermsOfDeliveryIncotermsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Create new terms of delivery incoterm
         * @param {IncotermCreateSchema} incotermCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsCreateOneSettingsIncotermsPost(incotermCreateSchema: IncotermCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncotermDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsCreateOneSettingsIncotermsPost(incotermCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete terms of delivery incoterm.  Deletion is not available if the incoterm is applied somewhere.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Delete terms of delivery incoterm
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsDeleteOneSettingsIncotermsIncotermIdDelete(incotermId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsDeleteOneSettingsIncotermsIncotermIdDelete(incotermId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get all incoterms delivery terms
         * @param {BaseSort} [sort] 
         * @param {IncotermQueryOrder} [order] 
         * @param {string} [searchFilter] Search by term and delivery terms
         * @param {IncotermCategoryFilter} [category] Filtering by category. If None - all incoterms will be shown.
         * @param {boolean} [isActive] Get active or inactive incoterms. If None - all incoterms will be shown
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsGetAllSelectSettingsIncotermsSelectGet(sort?: BaseSort, order?: IncotermQueryOrder, searchFilter?: string, category?: IncotermCategoryFilter, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectIncotermsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsGetAllSelectSettingsIncotermsSelectGet(sort, order, searchFilter, category, isActive, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get all incoterms delivery terms
         * @param {BaseSort} [sort] 
         * @param {IncotermQueryOrder} [order] 
         * @param {string} [searchFilter] Search by term and delivery terms
         * @param {IncotermCategoryFilter} [category] Filtering by category. If None - all incoterms will be shown.
         * @param {boolean} [isActive] Get active or inactive incoterms. If None - all incoterms will be shown
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsGetAllSettingsIncotermsGet(sort?: BaseSort, order?: IncotermQueryOrder, searchFilter?: string, category?: IncotermCategoryFilter, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncotermsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsGetAllSettingsIncotermsGet(sort, order, searchFilter, category, isActive, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get terms of delivery incoterm detail
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet(incotermId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectIncotermSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet(incotermId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get terms of delivery incoterm detail
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsGetOneSettingsIncotermsIncotermIdGet(incotermId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncotermDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsGetOneSettingsIncotermsIncotermIdGet(incotermId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Update terms of delivery incoterm
         * @param {number} incotermId 
         * @param {IncotermUpdateSchema} incotermUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incotermsUpdateOneSettingsIncotermsIncotermIdPut(incotermId: number, incotermUpdateSchema: IncotermUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncotermDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incotermsUpdateOneSettingsIncotermsIncotermIdPut(incotermId, incotermUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsTermsOfDeliveryIncotermsApi - factory interface
 * @export
 */
export const SettingsTermsOfDeliveryIncotermsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsTermsOfDeliveryIncotermsApiFp(configuration)
    return {
        /**
         * Create new terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Create new terms of delivery incoterm
         * @param {IncotermCreateSchema} incotermCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsCreateOneSettingsIncotermsPost(incotermCreateSchema: IncotermCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<IncotermDetailSchema> {
            return localVarFp.incotermsCreateOneSettingsIncotermsPost(incotermCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete terms of delivery incoterm.  Deletion is not available if the incoterm is applied somewhere.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Delete terms of delivery incoterm
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsDeleteOneSettingsIncotermsIncotermIdDelete(incotermId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.incotermsDeleteOneSettingsIncotermsIncotermIdDelete(incotermId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get all incoterms delivery terms
         * @param {BaseSort} [sort] 
         * @param {IncotermQueryOrder} [order] 
         * @param {string} [searchFilter] Search by term and delivery terms
         * @param {IncotermCategoryFilter} [category] Filtering by category. If None - all incoterms will be shown.
         * @param {boolean} [isActive] Get active or inactive incoterms. If None - all incoterms will be shown
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetAllSelectSettingsIncotermsSelectGet(sort?: BaseSort, order?: IncotermQueryOrder, searchFilter?: string, category?: IncotermCategoryFilter, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectIncotermsPage> {
            return localVarFp.incotermsGetAllSelectSettingsIncotermsSelectGet(sort, order, searchFilter, category, isActive, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get all incoterms delivery terms
         * @param {BaseSort} [sort] 
         * @param {IncotermQueryOrder} [order] 
         * @param {string} [searchFilter] Search by term and delivery terms
         * @param {IncotermCategoryFilter} [category] Filtering by category. If None - all incoterms will be shown.
         * @param {boolean} [isActive] Get active or inactive incoterms. If None - all incoterms will be shown
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetAllSettingsIncotermsGet(sort?: BaseSort, order?: IncotermQueryOrder, searchFilter?: string, category?: IncotermCategoryFilter, isActive?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<IncotermsPage> {
            return localVarFp.incotermsGetAllSettingsIncotermsGet(sort, order, searchFilter, category, isActive, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get terms of delivery incoterm detail
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet(incotermId: number, acceptLanguage?: string, options?: any): AxiosPromise<SelectIncotermSchema> {
            return localVarFp.incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet(incotermId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
         * @summary Get terms of delivery incoterm detail
         * @param {number} incotermId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsGetOneSettingsIncotermsIncotermIdGet(incotermId: number, acceptLanguage?: string, options?: any): AxiosPromise<IncotermDetailSchema> {
            return localVarFp.incotermsGetOneSettingsIncotermsIncotermIdGet(incotermId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
         * @summary Update terms of delivery incoterm
         * @param {number} incotermId 
         * @param {IncotermUpdateSchema} incotermUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incotermsUpdateOneSettingsIncotermsIncotermIdPut(incotermId: number, incotermUpdateSchema: IncotermUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<IncotermDetailSchema> {
            return localVarFp.incotermsUpdateOneSettingsIncotermsIncotermIdPut(incotermId, incotermUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for incotermsCreateOneSettingsIncotermsPost operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsCreateOneSettingsIncotermsPostRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsCreateOneSettingsIncotermsPostRequest {
    /**
     * 
     * @type {IncotermCreateSchema}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsCreateOneSettingsIncotermsPost
     */
    readonly incotermCreateSchema: IncotermCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsCreateOneSettingsIncotermsPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for incotermsDeleteOneSettingsIncotermsIncotermIdDelete operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsDeleteOneSettingsIncotermsIncotermIdDeleteRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsDeleteOneSettingsIncotermsIncotermIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsDeleteOneSettingsIncotermsIncotermIdDelete
     */
    readonly incotermId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsDeleteOneSettingsIncotermsIncotermIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for incotermsGetAllSelectSettingsIncotermsSelectGet operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGetRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {IncotermQueryOrder}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly order?: IncotermQueryOrder

    /**
     * Search by term and delivery terms
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by category. If None - all incoterms will be shown.
     * @type {IncotermCategoryFilter}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly category?: IncotermCategoryFilter

    /**
     * Get active or inactive incoterms. If None - all incoterms will be shown
     * @type {boolean}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for incotermsGetAllSettingsIncotermsGet operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGetRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {IncotermQueryOrder}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly order?: IncotermQueryOrder

    /**
     * Search by term and delivery terms
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly searchFilter?: string

    /**
     * Filtering by category. If None - all incoterms will be shown.
     * @type {IncotermCategoryFilter}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly category?: IncotermCategoryFilter

    /**
     * Get active or inactive incoterms. If None - all incoterms will be shown
     * @type {boolean}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSelectSettingsIncotermsIncotermIdSelectGetRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSelectSettingsIncotermsIncotermIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet
     */
    readonly incotermId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for incotermsGetOneSettingsIncotermsIncotermIdGet operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSettingsIncotermsIncotermIdGetRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSettingsIncotermsIncotermIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSettingsIncotermsIncotermIdGet
     */
    readonly incotermId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSettingsIncotermsIncotermIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for incotermsUpdateOneSettingsIncotermsIncotermIdPut operation in SettingsTermsOfDeliveryIncotermsApi.
 * @export
 * @interface SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPutRequest
 */
export interface SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPut
     */
    readonly incotermId: number

    /**
     * 
     * @type {IncotermUpdateSchema}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPut
     */
    readonly incotermUpdateSchema: IncotermUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsTermsOfDeliveryIncotermsApi - object-oriented interface
 * @export
 * @class SettingsTermsOfDeliveryIncotermsApi
 * @extends {BaseAPI}
 */
export class SettingsTermsOfDeliveryIncotermsApi extends BaseAPI {
    /**
     * Create new terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
     * @summary Create new terms of delivery incoterm
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsCreateOneSettingsIncotermsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsCreateOneSettingsIncotermsPost(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsCreateOneSettingsIncotermsPostRequest, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsCreateOneSettingsIncotermsPost(requestParameters.incotermCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete terms of delivery incoterm.  Deletion is not available if the incoterm is applied somewhere.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
     * @summary Delete terms of delivery incoterm
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsDeleteOneSettingsIncotermsIncotermIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsDeleteOneSettingsIncotermsIncotermIdDelete(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsDeleteOneSettingsIncotermsIncotermIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsDeleteOneSettingsIncotermsIncotermIdDelete(requestParameters.incotermId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
     * @summary Get all incoterms delivery terms
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsGetAllSelectSettingsIncotermsSelectGet(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSelectSettingsIncotermsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsGetAllSelectSettingsIncotermsSelectGet(requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.category, requestParameters.isActive, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current incoterms delivery terms in settings.  Pagination, filtering and ordering is used.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
     * @summary Get all incoterms delivery terms
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsGetAllSettingsIncotermsGet(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsGetAllSettingsIncotermsGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsGetAllSettingsIncotermsGet(requestParameters.sort, requestParameters.order, requestParameters.searchFilter, requestParameters.category, requestParameters.isActive, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
     * @summary Get terms of delivery incoterm detail
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSelectSettingsIncotermsIncotermIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSelectSettingsIncotermsIncotermIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsGetOneSelectSettingsIncotermsIncotermIdSelectGet(requestParameters.incotermId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get terms of delivery incoterm detail.  Perms needed: \'incoterm_view\'.  Role needed: \'is_staff\'.
     * @summary Get terms of delivery incoterm detail
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSettingsIncotermsIncotermIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsGetOneSettingsIncotermsIncotermIdGet(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsGetOneSettingsIncotermsIncotermIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsGetOneSettingsIncotermsIncotermIdGet(requestParameters.incotermId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update terms of delivery incoterm.  Perms needed: \'incoterm_change\'.  Role needed: \'is_staff\'.
     * @summary Update terms of delivery incoterm
     * @param {SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTermsOfDeliveryIncotermsApi
     */
    public incotermsUpdateOneSettingsIncotermsIncotermIdPut(requestParameters: SettingsTermsOfDeliveryIncotermsApiIncotermsUpdateOneSettingsIncotermsIncotermIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsTermsOfDeliveryIncotermsApiFp(this.configuration).incotermsUpdateOneSettingsIncotermsIncotermIdPut(requestParameters.incotermId, requestParameters.incotermUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsVatRatesApi - axios parameter creator
 * @export
 */
export const SettingsVatRatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete vat rate(if it not is base).  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
         * @summary Delete vat rate
         * @param {number} vatRateId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesDeleteOneSettingsVatRatesVatRateIdDelete: async (vatRateId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vatRateId' is not null or undefined
            assertParamExists('vatRatesDeleteOneSettingsVatRatesVatRateIdDelete', 'vatRateId', vatRateId)
            const localVarPath = `/settings/vat-rates/{vat_rate_id}/`
                .replace(`{${"vat_rate_id"}}`, encodeURIComponent(String(vatRateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all current vat rates from Settings.  Pagination, ordering(default is_base & desc date_created) by column is used.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
         * @summary Get all vat rates
         * @param {BaseSort} [sort] 
         * @param {VatRateQueryOrder} [order] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesGetAllSettingsVatRatesGet: async (sort?: BaseSort, order?: VatRateQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/vat-rates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vat rate detail.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
         * @summary Get vat rate detail
         * @param {number} vatRateId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesGetOneSettingsVatRatesVatRateIdGet: async (vatRateId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vatRateId' is not null or undefined
            assertParamExists('vatRatesGetOneSettingsVatRatesVatRateIdGet', 'vatRateId', vatRateId)
            const localVarPath = `/settings/vat-rates/{vat_rate_id}/`
                .replace(`{${"vat_rate_id"}}`, encodeURIComponent(String(vatRateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update vat rate: status(if it not is base), name, rate.  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
         * @summary Update vat rate
         * @param {number} vatRateId 
         * @param {VatRateUpdateSchema} vatRateUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesUpdateOneSettingsVatRatesVatRateIdPut: async (vatRateId: number, vatRateUpdateSchema: VatRateUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vatRateId' is not null or undefined
            assertParamExists('vatRatesUpdateOneSettingsVatRatesVatRateIdPut', 'vatRateId', vatRateId)
            // verify required parameter 'vatRateUpdateSchema' is not null or undefined
            assertParamExists('vatRatesUpdateOneSettingsVatRatesVatRateIdPut', 'vatRateUpdateSchema', vatRateUpdateSchema)
            const localVarPath = `/settings/vat-rates/{vat_rate_id}/`
                .replace(`{${"vat_rate_id"}}`, encodeURIComponent(String(vatRateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vatRateUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsVatRatesApi - functional programming interface
 * @export
 */
export const SettingsVatRatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsVatRatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete vat rate(if it not is base).  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
         * @summary Delete vat rate
         * @param {number} vatRateId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vatRatesDeleteOneSettingsVatRatesVatRateIdDelete(vatRateId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vatRatesDeleteOneSettingsVatRatesVatRateIdDelete(vatRateId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all current vat rates from Settings.  Pagination, ordering(default is_base & desc date_created) by column is used.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
         * @summary Get all vat rates
         * @param {BaseSort} [sort] 
         * @param {VatRateQueryOrder} [order] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vatRatesGetAllSettingsVatRatesGet(sort?: BaseSort, order?: VatRateQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatRatesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vatRatesGetAllSettingsVatRatesGet(sort, order, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get vat rate detail.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
         * @summary Get vat rate detail
         * @param {number} vatRateId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vatRatesGetOneSettingsVatRatesVatRateIdGet(vatRateId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatRateDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vatRatesGetOneSettingsVatRatesVatRateIdGet(vatRateId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update vat rate: status(if it not is base), name, rate.  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
         * @summary Update vat rate
         * @param {number} vatRateId 
         * @param {VatRateUpdateSchema} vatRateUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vatRatesUpdateOneSettingsVatRatesVatRateIdPut(vatRateId: number, vatRateUpdateSchema: VatRateUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatRateSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vatRatesUpdateOneSettingsVatRatesVatRateIdPut(vatRateId, vatRateUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsVatRatesApi - factory interface
 * @export
 */
export const SettingsVatRatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsVatRatesApiFp(configuration)
    return {
        /**
         * Delete vat rate(if it not is base).  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
         * @summary Delete vat rate
         * @param {number} vatRateId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesDeleteOneSettingsVatRatesVatRateIdDelete(vatRateId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.vatRatesDeleteOneSettingsVatRatesVatRateIdDelete(vatRateId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all current vat rates from Settings.  Pagination, ordering(default is_base & desc date_created) by column is used.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
         * @summary Get all vat rates
         * @param {BaseSort} [sort] 
         * @param {VatRateQueryOrder} [order] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesGetAllSettingsVatRatesGet(sort?: BaseSort, order?: VatRateQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<VatRatesPage> {
            return localVarFp.vatRatesGetAllSettingsVatRatesGet(sort, order, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vat rate detail.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
         * @summary Get vat rate detail
         * @param {number} vatRateId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesGetOneSettingsVatRatesVatRateIdGet(vatRateId: number, acceptLanguage?: string, options?: any): AxiosPromise<VatRateDetailSchema> {
            return localVarFp.vatRatesGetOneSettingsVatRatesVatRateIdGet(vatRateId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update vat rate: status(if it not is base), name, rate.  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
         * @summary Update vat rate
         * @param {number} vatRateId 
         * @param {VatRateUpdateSchema} vatRateUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vatRatesUpdateOneSettingsVatRatesVatRateIdPut(vatRateId: number, vatRateUpdateSchema: VatRateUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<VatRateSchema> {
            return localVarFp.vatRatesUpdateOneSettingsVatRatesVatRateIdPut(vatRateId, vatRateUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for vatRatesDeleteOneSettingsVatRatesVatRateIdDelete operation in SettingsVatRatesApi.
 * @export
 * @interface SettingsVatRatesApiVatRatesDeleteOneSettingsVatRatesVatRateIdDeleteRequest
 */
export interface SettingsVatRatesApiVatRatesDeleteOneSettingsVatRatesVatRateIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsVatRatesApiVatRatesDeleteOneSettingsVatRatesVatRateIdDelete
     */
    readonly vatRateId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsVatRatesApiVatRatesDeleteOneSettingsVatRatesVatRateIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for vatRatesGetAllSettingsVatRatesGet operation in SettingsVatRatesApi.
 * @export
 * @interface SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGetRequest
 */
export interface SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGetRequest {
    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {VatRateQueryOrder}
     * @memberof SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGet
     */
    readonly order?: VatRateQueryOrder

    /**
     * 
     * @type {number}
     * @memberof SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for vatRatesGetOneSettingsVatRatesVatRateIdGet operation in SettingsVatRatesApi.
 * @export
 * @interface SettingsVatRatesApiVatRatesGetOneSettingsVatRatesVatRateIdGetRequest
 */
export interface SettingsVatRatesApiVatRatesGetOneSettingsVatRatesVatRateIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsVatRatesApiVatRatesGetOneSettingsVatRatesVatRateIdGet
     */
    readonly vatRateId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsVatRatesApiVatRatesGetOneSettingsVatRatesVatRateIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for vatRatesUpdateOneSettingsVatRatesVatRateIdPut operation in SettingsVatRatesApi.
 * @export
 * @interface SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPutRequest
 */
export interface SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPut
     */
    readonly vatRateId: number

    /**
     * 
     * @type {VatRateUpdateSchema}
     * @memberof SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPut
     */
    readonly vatRateUpdateSchema: VatRateUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsVatRatesApi - object-oriented interface
 * @export
 * @class SettingsVatRatesApi
 * @extends {BaseAPI}
 */
export class SettingsVatRatesApi extends BaseAPI {
    /**
     * Delete vat rate(if it not is base).  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
     * @summary Delete vat rate
     * @param {SettingsVatRatesApiVatRatesDeleteOneSettingsVatRatesVatRateIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsVatRatesApi
     */
    public vatRatesDeleteOneSettingsVatRatesVatRateIdDelete(requestParameters: SettingsVatRatesApiVatRatesDeleteOneSettingsVatRatesVatRateIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsVatRatesApiFp(this.configuration).vatRatesDeleteOneSettingsVatRatesVatRateIdDelete(requestParameters.vatRateId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all current vat rates from Settings.  Pagination, ordering(default is_base & desc date_created) by column is used.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
     * @summary Get all vat rates
     * @param {SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsVatRatesApi
     */
    public vatRatesGetAllSettingsVatRatesGet(requestParameters: SettingsVatRatesApiVatRatesGetAllSettingsVatRatesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsVatRatesApiFp(this.configuration).vatRatesGetAllSettingsVatRatesGet(requestParameters.sort, requestParameters.order, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vat rate detail.  Perms needed: \'vat_rate_view\'.  Role needed: \'is_staff\'.
     * @summary Get vat rate detail
     * @param {SettingsVatRatesApiVatRatesGetOneSettingsVatRatesVatRateIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsVatRatesApi
     */
    public vatRatesGetOneSettingsVatRatesVatRateIdGet(requestParameters: SettingsVatRatesApiVatRatesGetOneSettingsVatRatesVatRateIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsVatRatesApiFp(this.configuration).vatRatesGetOneSettingsVatRatesVatRateIdGet(requestParameters.vatRateId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update vat rate: status(if it not is base), name, rate.  Perms needed: \'vat_rate_view, vat_rate_change\'.  Role needed: \'is_staff\'.
     * @summary Update vat rate
     * @param {SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsVatRatesApi
     */
    public vatRatesUpdateOneSettingsVatRatesVatRateIdPut(requestParameters: SettingsVatRatesApiVatRatesUpdateOneSettingsVatRatesVatRateIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsVatRatesApiFp(this.configuration).vatRatesUpdateOneSettingsVatRatesVatRateIdPut(requestParameters.vatRateId, requestParameters.vatRateUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsWarehousesApi - axios parameter creator
 * @export
 */
export const SettingsWarehousesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Create warehouse.
         * @param {WarehouseCreateSchema} warehouseCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesCreateSettingsWarehousesPost: async (warehouseCreateSchema: WarehouseCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseCreateSchema' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesCreateSettingsWarehousesPost', 'warehouseCreateSchema', warehouseCreateSchema)
            const localVarPath = `/settings/warehouses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(warehouseCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete warehouse. Only if it is not has any references from other models.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Delete warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete: async (warehouseId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete', 'warehouseId', warehouseId)
            const localVarPath = `/settings/warehouses/{warehouse_id}/`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary Get warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet: async (warehouseId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet', 'warehouseId', warehouseId)
            const localVarPath = `/settings/warehouses/{warehouse_id}/select/`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary Get warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet: async (warehouseId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet', 'warehouseId', warehouseId)
            const localVarPath = `/settings/warehouses/{warehouse_id}/`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
         * @summary List of warehouses.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet: async (order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/warehouses/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
         * @summary List of warehouses.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesListSettingsWarehousesGet: async (order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/warehouses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary List of warehouses for settings.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet: async (order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/warehouses/settings/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary List of warehouses for settings.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet: async (order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/warehouses/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current stock balances of nomenclatures in the warehouse.  Role check: is_staff.  No permissions.
         * @summary Get current stock balances of nomenclatures in the warehouse.
         * @param {number} warehouseId 
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet: async (warehouseId: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet', 'warehouseId', warehouseId)
            // verify required parameter 'nomenclatureIds' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet', 'nomenclatureIds', nomenclatureIds)
            const localVarPath = `/settings/warehouses/{warehouse_id}/stock-balances/`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nomenclatureIds) {
                localVarQueryParameter['nomenclatureIds'] = nomenclatureIds;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Update warehouse.
         * @param {number} warehouseId 
         * @param {WarehouseUpdateSchema} warehouseUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut: async (warehouseId: number, warehouseUpdateSchema: WarehouseUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut', 'warehouseId', warehouseId)
            // verify required parameter 'warehouseUpdateSchema' is not null or undefined
            assertParamExists('settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut', 'warehouseUpdateSchema', warehouseUpdateSchema)
            const localVarPath = `/settings/warehouses/{warehouse_id}/`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(warehouseUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsWarehousesApi - functional programming interface
 * @export
 */
export const SettingsWarehousesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsWarehousesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Create warehouse.
         * @param {WarehouseCreateSchema} warehouseCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesCreateSettingsWarehousesPost(warehouseCreateSchema: WarehouseCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesCreateSettingsWarehousesPost(warehouseCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete warehouse. Only if it is not has any references from other models.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Delete warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete(warehouseId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete(warehouseId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary Get warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet(warehouseId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleWarehouseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet(warehouseId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary Get warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet(warehouseId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet(warehouseId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
         * @summary List of warehouses.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehousePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
         * @summary List of warehouses.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesListSettingsWarehousesGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehousePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesListSettingsWarehousesGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary List of warehouses for settings.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehousePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary List of warehouses for settings.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehousePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current stock balances of nomenclatures in the warehouse.  Role check: is_staff.  No permissions.
         * @summary Get current stock balances of nomenclatures in the warehouse.
         * @param {number} warehouseId 
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet(warehouseId: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseStockBalancesSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet(warehouseId, nomenclatureIds, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Update warehouse.
         * @param {number} warehouseId 
         * @param {WarehouseUpdateSchema} warehouseUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut(warehouseId: number, warehouseUpdateSchema: WarehouseUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseDetailSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut(warehouseId, warehouseUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsWarehousesApi - factory interface
 * @export
 */
export const SettingsWarehousesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsWarehousesApiFp(configuration)
    return {
        /**
         * Create warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Create warehouse.
         * @param {WarehouseCreateSchema} warehouseCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesCreateSettingsWarehousesPost(warehouseCreateSchema: WarehouseCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<WarehouseDetailSchema> {
            return localVarFp.settingsCategoriesWarehousesCreateSettingsWarehousesPost(warehouseCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete warehouse. Only if it is not has any references from other models.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Delete warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete(warehouseId: number, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete(warehouseId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary Get warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet(warehouseId: number, acceptLanguage?: string, options?: any): AxiosPromise<SimpleWarehouseSchema> {
            return localVarFp.settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet(warehouseId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary Get warehouse.
         * @param {number} warehouseId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet(warehouseId: number, acceptLanguage?: string, options?: any): AxiosPromise<WarehouseDetailSchema> {
            return localVarFp.settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet(warehouseId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
         * @summary List of warehouses.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<WarehousePage> {
            return localVarFp.settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
         * @summary List of warehouses.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesListSettingsWarehousesGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<WarehousePage> {
            return localVarFp.settingsCategoriesWarehousesListSettingsWarehousesGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary List of warehouses for settings.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<WarehousePage> {
            return localVarFp.settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
         * @summary List of warehouses for settings.
         * @param {WarehouseQueryOrder} [order] 
         * @param {BaseSort} [sort] 
         * @param {boolean} [excludeInactive] 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet(order?: WarehouseQueryOrder, sort?: BaseSort, excludeInactive?: boolean, searchFilterSelect?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<WarehousePage> {
            return localVarFp.settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet(order, sort, excludeInactive, searchFilterSelect, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current stock balances of nomenclatures in the warehouse.  Role check: is_staff.  No permissions.
         * @summary Get current stock balances of nomenclatures in the warehouse.
         * @param {number} warehouseId 
         * @param {Array<number>} nomenclatureIds Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet(warehouseId: number, nomenclatureIds: Array<number>, acceptLanguage?: string, options?: any): AxiosPromise<WarehouseStockBalancesSchema> {
            return localVarFp.settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet(warehouseId, nomenclatureIds, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
         * @summary Update warehouse.
         * @param {number} warehouseId 
         * @param {WarehouseUpdateSchema} warehouseUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut(warehouseId: number, warehouseUpdateSchema: WarehouseUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<WarehouseDetailSchema> {
            return localVarFp.settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut(warehouseId, warehouseUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for settingsCategoriesWarehousesCreateSettingsWarehousesPost operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesCreateSettingsWarehousesPostRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesCreateSettingsWarehousesPostRequest {
    /**
     * 
     * @type {WarehouseCreateSchema}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesCreateSettingsWarehousesPost
     */
    readonly warehouseCreateSchema: WarehouseCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesCreateSettingsWarehousesPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDeleteRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete
     */
    readonly warehouseId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet
     */
    readonly warehouseId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet
     */
    readonly warehouseId: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGetRequest {
    /**
     * 
     * @type {WarehouseQueryOrder}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly order?: WarehouseQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesListSettingsWarehousesGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGetRequest {
    /**
     * 
     * @type {WarehouseQueryOrder}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly order?: WarehouseQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGetRequest {
    /**
     * 
     * @type {WarehouseQueryOrder}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly order?: WarehouseQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGetRequest {
    /**
     * 
     * @type {WarehouseQueryOrder}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly order?: WarehouseQueryOrder

    /**
     * 
     * @type {BaseSort}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {boolean}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly excludeInactive?: boolean

    /**
     * Search filter by name
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly searchFilterSelect?: string

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGetRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet
     */
    readonly warehouseId: number

    /**
     * Filtering by nomenclature IDs. At list 1 nomenclature ID is required.
     * @type {Array<number>}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet
     */
    readonly nomenclatureIds: Array<number>

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut operation in SettingsWarehousesApi.
 * @export
 * @interface SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPutRequest
 */
export interface SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut
     */
    readonly warehouseId: number

    /**
     * 
     * @type {WarehouseUpdateSchema}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut
     */
    readonly warehouseUpdateSchema: WarehouseUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SettingsWarehousesApi - object-oriented interface
 * @export
 * @class SettingsWarehousesApi
 * @extends {BaseAPI}
 */
export class SettingsWarehousesApi extends BaseAPI {
    /**
     * Create warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
     * @summary Create warehouse.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesCreateSettingsWarehousesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesCreateSettingsWarehousesPost(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesCreateSettingsWarehousesPostRequest, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesCreateSettingsWarehousesPost(requestParameters.warehouseCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete warehouse. Only if it is not has any references from other models.  Role check: is_staff.  Permission: warehouse_in_settings_change.
     * @summary Delete warehouse.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDeleteRequest, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesDeleteSettingsWarehousesWarehouseIdDelete(requestParameters.warehouseId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
     * @summary Get warehouse.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesGetSelectSettingsWarehousesWarehouseIdSelectGet(requestParameters.warehouseId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
     * @summary Get warehouse.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGetRequest, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesGetSettingsWarehousesWarehouseIdGet(requestParameters.warehouseId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
     * @summary List of warehouses.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesListSelectSettingsWarehousesSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesListSelectSettingsWarehousesSelectGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get warehouses.  Role check: is_staff.  Permission: warehouse_view_warehouse.
     * @summary List of warehouses.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesListSettingsWarehousesGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesListSettingsWarehousesGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesListSettingsWarehousesGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
     * @summary List of warehouses for settings.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesSettingsListSelectSettingsWarehousesSettingsSelectGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_view.
     * @summary List of warehouses for settings.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGetRequest = {}, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesSettingsListSettingsWarehousesSettingsGet(requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.searchFilterSelect, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current stock balances of nomenclatures in the warehouse.  Role check: is_staff.  No permissions.
     * @summary Get current stock balances of nomenclatures in the warehouse.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGetRequest, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesStockBalancesSettingsWarehousesWarehouseIdStockBalancesGet(requestParameters.warehouseId, requestParameters.nomenclatureIds, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update warehouse.  Role check: is_staff.  Permission: warehouse_in_settings_change.
     * @summary Update warehouse.
     * @param {SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWarehousesApi
     */
    public settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut(requestParameters: SettingsWarehousesApiSettingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPutRequest, options?: AxiosRequestConfig) {
        return SettingsWarehousesApiFp(this.configuration).settingsCategoriesWarehousesUpdateSettingsWarehousesWarehouseIdPut(requestParameters.warehouseId, requestParameters.warehouseUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StaffApi - axios parameter creator
 * @export
 */
export const StaffApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Activate staff user. Both for \'in processing\' and \'inactive\' users.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffActivateStaffStaffIdActivatePut: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffActivateStaffStaffIdActivatePut', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/activate/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change staff user login.  Role check: is_staff.  Permission: staff_change.
         * @summary Change staff user login.
         * @param {string} staffId 
         * @param {StaffUpdateEmailSchema} staffUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffChangeLoginStaffStaffIdChangeLoginPut: async (staffId: string, staffUpdateEmailSchema: StaffUpdateEmailSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffChangeLoginStaffStaffIdChangeLoginPut', 'staffId', staffId)
            // verify required parameter 'staffUpdateEmailSchema' is not null or undefined
            assertParamExists('usersStaffChangeLoginStaffStaffIdChangeLoginPut', 'staffUpdateEmailSchema', staffUpdateEmailSchema)
            const localVarPath = `/staff/{staff_id}/change-login/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffUpdateEmailSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Create staff user.
         * @param {StaffCreateSchema} staffCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffCreateStaffPost: async (staffCreateSchema: StaffCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffCreateSchema' is not null or undefined
            assertParamExists('usersStaffCreateStaffPost', 'staffCreateSchema', staffCreateSchema)
            const localVarPath = `/staff/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: staff_change.
         * @summary Deactivate staff user.
         * @param {string} staffId 
         * @param {DeactivateStaffSchema} deactivateStaffSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffDeactivateStaffStaffIdDeactivatePut: async (staffId: string, deactivateStaffSchema: DeactivateStaffSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffDeactivateStaffStaffIdDeactivatePut', 'staffId', staffId)
            // verify required parameter 'deactivateStaffSchema' is not null or undefined
            assertParamExists('usersStaffDeactivateStaffStaffIdDeactivatePut', 'deactivateStaffSchema', deactivateStaffSchema)
            const localVarPath = `/staff/{staff_id}/deactivate/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deactivateStaffSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Delete \'in processing\' staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffDeleteStaffStaffIdDeleteDelete: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffDeleteStaffStaffIdDeleteDelete', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/delete/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if staff user can be fired.  Role check: is_staff.  Permission: staff_change.
         * @summary Make fire check for staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffFireCheckStaffStaffIdFireGet: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffFireCheckStaffStaffIdFireGet', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/fire/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fire staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Fire staff user.
         * @param {string} staffId 
         * @param {FireStaffSchema} fireStaffSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffFireStaffStaffIdFirePut: async (staffId: string, fireStaffSchema: FireStaffSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffFireStaffStaffIdFirePut', 'staffId', staffId)
            // verify required parameter 'fireStaffSchema' is not null or undefined
            assertParamExists('usersStaffFireStaffStaffIdFirePut', 'fireStaffSchema', fireStaffSchema)
            const localVarPath = `/staff/{staff_id}/fire/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fireStaffSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate temporary password for staff user.  Role check: is_staff.  Permission: staff_change.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent. Superuser password cannot be generated/reset.
         * @summary Generate temporary password for staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut: async (staffId: string, acceptLanguage?: string, body?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/generate-temporary-password/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view.
         * @summary Get staff user full info.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGetFullInfoStaffStaffIdFullInfoGet: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffGetFullInfoStaffStaffIdFullInfoGet', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/full-info/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGetSelectStaffStaffIdSelectGet: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffGetSelectStaffStaffIdSelectGet', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/select/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGetStaffStaffIdGet: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffGetStaffStaffIdGet', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
         * @summary List of staff users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {StaffQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {number} [positionId] Staff Position id.
         * @param {StaffStatuses} [staffStatus] Staff status. Active is default.
         * @param {Array<string>} [onlyWithPermissions] Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
         * @param {Array<StaffStatuses>} [statuses] Staff statuses. If None - all statuses will be shown.
         * @param {boolean} [excludeSuperuser] Exclude superuser from list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffListSelectStaffSelectGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: StaffQueryOrder, sort?: BaseSort, excludeInactive?: boolean, positionId?: number, staffStatus?: StaffStatuses, onlyWithPermissions?: Array<string>, statuses?: Array<StaffStatuses>, excludeSuperuser?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staff/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (positionId !== undefined) {
                localVarQueryParameter['positionId'] = positionId;
            }

            if (staffStatus !== undefined) {
                localVarQueryParameter['staffStatus'] = staffStatus;
            }

            if (onlyWithPermissions) {
                localVarQueryParameter['onlyWithPermissions'] = onlyWithPermissions;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (excludeSuperuser !== undefined) {
                localVarQueryParameter['excludeSuperuser'] = excludeSuperuser;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
         * @summary List of staff users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {StaffQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {number} [positionId] Staff Position id.
         * @param {StaffStatuses} [staffStatus] Staff status. Active is default.
         * @param {Array<string>} [onlyWithPermissions] Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
         * @param {Array<StaffStatuses>} [statuses] Staff statuses. If None - all statuses will be shown.
         * @param {boolean} [excludeSuperuser] Exclude superuser from list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffListStaffGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: StaffQueryOrder, sort?: BaseSort, excludeInactive?: boolean, positionId?: number, staffStatus?: StaffStatuses, onlyWithPermissions?: Array<string>, statuses?: Array<StaffStatuses>, excludeSuperuser?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staff/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (positionId !== undefined) {
                localVarQueryParameter['positionId'] = positionId;
            }

            if (staffStatus !== undefined) {
                localVarQueryParameter['staffStatus'] = staffStatus;
            }

            if (onlyWithPermissions) {
                localVarQueryParameter['onlyWithPermissions'] = onlyWithPermissions;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (excludeSuperuser !== undefined) {
                localVarQueryParameter['excludeSuperuser'] = excludeSuperuser;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff user clients statistic.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user clients statistic.
         * @param {string} staffId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffStatisticsStaffStaffIdStatisticsGet: async (staffId: string, currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffStatisticsStaffStaffIdStatisticsGet', 'staffId', staffId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('usersStaffStatisticsStaffStaffIdStatisticsGet', 'currencyId', currencyId)
            const localVarPath = `/staff/{staff_id}/statistics/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change staff user avatar.  Role check: is_staff.  Permission: staff_change.
         * @summary Change staff user avatar.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffUpdateAvatarStaffStaffIdAvatarPut: async (staffId: string, acceptLanguage?: string, avatar?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffUpdateAvatarStaffStaffIdAvatarPut', 'staffId', staffId)
            const localVarPath = `/staff/{staff_id}/avatar/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update staff user.  Role check: is_staff.  Permission: staff_change.  Always send \'email\' field, even if it is not changed or if it is read-only. Email will be changed only if it is not used by another user and only if user status in DB is \'in processing\'.
         * @summary Update staff user.
         * @param {string} staffId 
         * @param {StaffUpdateSchema} staffUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffUpdateStaffStaffIdPut: async (staffId: string, staffUpdateSchema: StaffUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffUpdateStaffStaffIdPut', 'staffId', staffId)
            // verify required parameter 'staffUpdateSchema' is not null or undefined
            assertParamExists('usersStaffUpdateStaffStaffIdPut', 'staffUpdateSchema', staffUpdateSchema)
            const localVarPath = `/staff/{staff_id}/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent/staff unclosed documents.  Role check: is_staff. Permission: staff_change, staff_view.
         * @summary Get agent/staff unclosed documents
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUnclosedDocumentsStaffUnclosedDocumentsGet: async (userId: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUnclosedDocumentsStaffUnclosedDocumentsGet', 'userId', userId)
            const localVarPath = `/staff/unclosed-documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaffApi - functional programming interface
 * @export
 */
export const StaffApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaffApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Activate staff user. Both for \'in processing\' and \'inactive\' users.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffActivateStaffStaffIdActivatePut(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffActivateStaffStaffIdActivatePut(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change staff user login.  Role check: is_staff.  Permission: staff_change.
         * @summary Change staff user login.
         * @param {string} staffId 
         * @param {StaffUpdateEmailSchema} staffUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffChangeLoginStaffStaffIdChangeLoginPut(staffId: string, staffUpdateEmailSchema: StaffUpdateEmailSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffChangeLoginStaffStaffIdChangeLoginPut(staffId, staffUpdateEmailSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Create staff user.
         * @param {StaffCreateSchema} staffCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffCreateStaffPost(staffCreateSchema: StaffCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffCreateStaffPost(staffCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: staff_change.
         * @summary Deactivate staff user.
         * @param {string} staffId 
         * @param {DeactivateStaffSchema} deactivateStaffSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffDeactivateStaffStaffIdDeactivatePut(staffId: string, deactivateStaffSchema: DeactivateStaffSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffDeactivateStaffStaffIdDeactivatePut(staffId, deactivateStaffSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Delete \'in processing\' staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffDeleteStaffStaffIdDeleteDelete(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffDeleteStaffStaffIdDeleteDelete(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if staff user can be fired.  Role check: is_staff.  Permission: staff_change.
         * @summary Make fire check for staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffFireCheckStaffStaffIdFireGet(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireCheckStatusSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffFireCheckStaffStaffIdFireGet(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fire staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Fire staff user.
         * @param {string} staffId 
         * @param {FireStaffSchema} fireStaffSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffFireStaffStaffIdFirePut(staffId: string, fireStaffSchema: FireStaffSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffFireStaffStaffIdFirePut(staffId, fireStaffSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate temporary password for staff user.  Role check: is_staff.  Permission: staff_change.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent. Superuser password cannot be generated/reset.
         * @summary Generate temporary password for staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut(staffId: string, acceptLanguage?: string, body?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut(staffId, acceptLanguage, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view.
         * @summary Get staff user full info.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffGetFullInfoStaffStaffIdFullInfoGet(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffFullInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffGetFullInfoStaffStaffIdFullInfoGet(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffGetSelectStaffStaffIdSelectGet(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleUserSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffGetSelectStaffStaffIdSelectGet(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffGetStaffStaffIdGet(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffGetStaffStaffIdGet(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
         * @summary List of staff users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {StaffQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {number} [positionId] Staff Position id.
         * @param {StaffStatuses} [staffStatus] Staff status. Active is default.
         * @param {Array<string>} [onlyWithPermissions] Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
         * @param {Array<StaffStatuses>} [statuses] Staff statuses. If None - all statuses will be shown.
         * @param {boolean} [excludeSuperuser] Exclude superuser from list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffListSelectStaffSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: StaffQueryOrder, sort?: BaseSort, excludeInactive?: boolean, positionId?: number, staffStatus?: StaffStatuses, onlyWithPermissions?: Array<string>, statuses?: Array<StaffStatuses>, excludeSuperuser?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleStaffPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffListSelectStaffSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, positionId, staffStatus, onlyWithPermissions, statuses, excludeSuperuser, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
         * @summary List of staff users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {StaffQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {number} [positionId] Staff Position id.
         * @param {StaffStatuses} [staffStatus] Staff status. Active is default.
         * @param {Array<string>} [onlyWithPermissions] Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
         * @param {Array<StaffStatuses>} [statuses] Staff statuses. If None - all statuses will be shown.
         * @param {boolean} [excludeSuperuser] Exclude superuser from list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffListStaffGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: StaffQueryOrder, sort?: BaseSort, excludeInactive?: boolean, positionId?: number, staffStatus?: StaffStatuses, onlyWithPermissions?: Array<string>, statuses?: Array<StaffStatuses>, excludeSuperuser?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffListStaffGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, positionId, staffStatus, onlyWithPermissions, statuses, excludeSuperuser, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff user clients statistic.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user clients statistic.
         * @param {string} staffId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffStatisticsStaffStaffIdStatisticsGet(staffId: string, currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInvoicesDetailedStatisticsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffStatisticsStaffStaffIdStatisticsGet(staffId, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change staff user avatar.  Role check: is_staff.  Permission: staff_change.
         * @summary Change staff user avatar.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffUpdateAvatarStaffStaffIdAvatarPut(staffId: string, acceptLanguage?: string, avatar?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffUpdateAvatarStaffStaffIdAvatarPut(staffId, acceptLanguage, avatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update staff user.  Role check: is_staff.  Permission: staff_change.  Always send \'email\' field, even if it is not changed or if it is read-only. Email will be changed only if it is not used by another user and only if user status in DB is \'in processing\'.
         * @summary Update staff user.
         * @param {string} staffId 
         * @param {StaffUpdateSchema} staffUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffUpdateStaffStaffIdPut(staffId: string, staffUpdateSchema: StaffUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffUpdateStaffStaffIdPut(staffId, staffUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get agent/staff unclosed documents.  Role check: is_staff. Permission: staff_change, staff_view.
         * @summary Get agent/staff unclosed documents
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUnclosedDocumentsStaffUnclosedDocumentsGet(userId: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUnclosedDocumentPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUnclosedDocumentsStaffUnclosedDocumentsGet(userId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StaffApi - factory interface
 * @export
 */
export const StaffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaffApiFp(configuration)
    return {
        /**
         * Activate staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Activate staff user. Both for \'in processing\' and \'inactive\' users.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffActivateStaffStaffIdActivatePut(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffActivateStaffStaffIdActivatePut(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change staff user login.  Role check: is_staff.  Permission: staff_change.
         * @summary Change staff user login.
         * @param {string} staffId 
         * @param {StaffUpdateEmailSchema} staffUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffChangeLoginStaffStaffIdChangeLoginPut(staffId: string, staffUpdateEmailSchema: StaffUpdateEmailSchema, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffChangeLoginStaffStaffIdChangeLoginPut(staffId, staffUpdateEmailSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Create staff user.
         * @param {StaffCreateSchema} staffCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffCreateStaffPost(staffCreateSchema: StaffCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffCreateStaffPost(staffCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: staff_change.
         * @summary Deactivate staff user.
         * @param {string} staffId 
         * @param {DeactivateStaffSchema} deactivateStaffSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffDeactivateStaffStaffIdDeactivatePut(staffId: string, deactivateStaffSchema: DeactivateStaffSchema, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffDeactivateStaffStaffIdDeactivatePut(staffId, deactivateStaffSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Delete \'in processing\' staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffDeleteStaffStaffIdDeleteDelete(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersStaffDeleteStaffStaffIdDeleteDelete(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if staff user can be fired.  Role check: is_staff.  Permission: staff_change.
         * @summary Make fire check for staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffFireCheckStaffStaffIdFireGet(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<FireCheckStatusSchema> {
            return localVarFp.usersStaffFireCheckStaffStaffIdFireGet(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire staff user.  Role check: is_staff.  Permission: staff_change.
         * @summary Fire staff user.
         * @param {string} staffId 
         * @param {FireStaffSchema} fireStaffSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffFireStaffStaffIdFirePut(staffId: string, fireStaffSchema: FireStaffSchema, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffFireStaffStaffIdFirePut(staffId, fireStaffSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate temporary password for staff user.  Role check: is_staff.  Permission: staff_change.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent. Superuser password cannot be generated/reset.
         * @summary Generate temporary password for staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut(staffId: string, acceptLanguage?: string, body?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut(staffId, acceptLanguage, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view.
         * @summary Get staff user full info.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGetFullInfoStaffStaffIdFullInfoGet(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<StaffFullInfoSchema> {
            return localVarFp.usersStaffGetFullInfoStaffStaffIdFullInfoGet(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGetSelectStaffStaffIdSelectGet(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<SimpleUserSchema> {
            return localVarFp.usersStaffGetSelectStaffStaffIdSelectGet(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffGetStaffStaffIdGet(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffGetStaffStaffIdGet(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
         * @summary List of staff users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {StaffQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {number} [positionId] Staff Position id.
         * @param {StaffStatuses} [staffStatus] Staff status. Active is default.
         * @param {Array<string>} [onlyWithPermissions] Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
         * @param {Array<StaffStatuses>} [statuses] Staff statuses. If None - all statuses will be shown.
         * @param {boolean} [excludeSuperuser] Exclude superuser from list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffListSelectStaffSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: StaffQueryOrder, sort?: BaseSort, excludeInactive?: boolean, positionId?: number, staffStatus?: StaffStatuses, onlyWithPermissions?: Array<string>, statuses?: Array<StaffStatuses>, excludeSuperuser?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SimpleStaffPage> {
            return localVarFp.usersStaffListSelectStaffSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, positionId, staffStatus, onlyWithPermissions, statuses, excludeSuperuser, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
         * @summary List of staff users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {StaffQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {number} [positionId] Staff Position id.
         * @param {StaffStatuses} [staffStatus] Staff status. Active is default.
         * @param {Array<string>} [onlyWithPermissions] Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
         * @param {Array<StaffStatuses>} [statuses] Staff statuses. If None - all statuses will be shown.
         * @param {boolean} [excludeSuperuser] Exclude superuser from list.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffListStaffGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: StaffQueryOrder, sort?: BaseSort, excludeInactive?: boolean, positionId?: number, staffStatus?: StaffStatuses, onlyWithPermissions?: Array<string>, statuses?: Array<StaffStatuses>, excludeSuperuser?: boolean, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<StaffPage> {
            return localVarFp.usersStaffListStaffGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, positionId, staffStatus, onlyWithPermissions, statuses, excludeSuperuser, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff user clients statistic.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
         * @summary Get staff user clients statistic.
         * @param {string} staffId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffStatisticsStaffStaffIdStatisticsGet(staffId: string, currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<ClientInvoicesDetailedStatisticsSchema> {
            return localVarFp.usersStaffStatisticsStaffStaffIdStatisticsGet(staffId, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change staff user avatar.  Role check: is_staff.  Permission: staff_change.
         * @summary Change staff user avatar.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {File} [avatar] Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffUpdateAvatarStaffStaffIdAvatarPut(staffId: string, acceptLanguage?: string, avatar?: File, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffUpdateAvatarStaffStaffIdAvatarPut(staffId, acceptLanguage, avatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update staff user.  Role check: is_staff.  Permission: staff_change.  Always send \'email\' field, even if it is not changed or if it is read-only. Email will be changed only if it is not used by another user and only if user status in DB is \'in processing\'.
         * @summary Update staff user.
         * @param {string} staffId 
         * @param {StaffUpdateSchema} staffUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffUpdateStaffStaffIdPut(staffId: string, staffUpdateSchema: StaffUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<StaffSchema> {
            return localVarFp.usersStaffUpdateStaffStaffIdPut(staffId, staffUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent/staff unclosed documents.  Role check: is_staff. Permission: staff_change, staff_view.
         * @summary Get agent/staff unclosed documents
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUnclosedDocumentsStaffUnclosedDocumentsGet(userId: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserUnclosedDocumentPage> {
            return localVarFp.usersUnclosedDocumentsStaffUnclosedDocumentsGet(userId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersStaffActivateStaffStaffIdActivatePut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffActivateStaffStaffIdActivatePutRequest
 */
export interface StaffApiUsersStaffActivateStaffStaffIdActivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffActivateStaffStaffIdActivatePut
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffActivateStaffStaffIdActivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffChangeLoginStaffStaffIdChangeLoginPut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPutRequest
 */
export interface StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPut
     */
    readonly staffId: string

    /**
     * 
     * @type {StaffUpdateEmailSchema}
     * @memberof StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPut
     */
    readonly staffUpdateEmailSchema: StaffUpdateEmailSchema

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffCreateStaffPost operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffCreateStaffPostRequest
 */
export interface StaffApiUsersStaffCreateStaffPostRequest {
    /**
     * 
     * @type {StaffCreateSchema}
     * @memberof StaffApiUsersStaffCreateStaffPost
     */
    readonly staffCreateSchema: StaffCreateSchema

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffCreateStaffPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffDeactivateStaffStaffIdDeactivatePut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePutRequest
 */
export interface StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePut
     */
    readonly staffId: string

    /**
     * 
     * @type {DeactivateStaffSchema}
     * @memberof StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePut
     */
    readonly deactivateStaffSchema: DeactivateStaffSchema

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffDeleteStaffStaffIdDeleteDelete operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffDeleteStaffStaffIdDeleteDeleteRequest
 */
export interface StaffApiUsersStaffDeleteStaffStaffIdDeleteDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffDeleteStaffStaffIdDeleteDelete
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffDeleteStaffStaffIdDeleteDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffFireCheckStaffStaffIdFireGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffFireCheckStaffStaffIdFireGetRequest
 */
export interface StaffApiUsersStaffFireCheckStaffStaffIdFireGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffFireCheckStaffStaffIdFireGet
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffFireCheckStaffStaffIdFireGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffFireStaffStaffIdFirePut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffFireStaffStaffIdFirePutRequest
 */
export interface StaffApiUsersStaffFireStaffStaffIdFirePutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffFireStaffStaffIdFirePut
     */
    readonly staffId: string

    /**
     * 
     * @type {FireStaffSchema}
     * @memberof StaffApiUsersStaffFireStaffStaffIdFirePut
     */
    readonly fireStaffSchema: FireStaffSchema

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffFireStaffStaffIdFirePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPutRequest
 */
export interface StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut
     */
    readonly acceptLanguage?: string

    /**
     * 
     * @type {boolean}
     * @memberof StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut
     */
    readonly body?: boolean
}

/**
 * Request parameters for usersStaffGetFullInfoStaffStaffIdFullInfoGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffGetFullInfoStaffStaffIdFullInfoGetRequest
 */
export interface StaffApiUsersStaffGetFullInfoStaffStaffIdFullInfoGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGetFullInfoStaffStaffIdFullInfoGet
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGetFullInfoStaffStaffIdFullInfoGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffGetSelectStaffStaffIdSelectGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffGetSelectStaffStaffIdSelectGetRequest
 */
export interface StaffApiUsersStaffGetSelectStaffStaffIdSelectGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGetSelectStaffStaffIdSelectGet
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGetSelectStaffStaffIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffGetStaffStaffIdGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffGetStaffStaffIdGetRequest
 */
export interface StaffApiUsersStaffGetStaffStaffIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGetStaffStaffIdGet
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffGetStaffStaffIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffListSelectStaffSelectGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffListSelectStaffSelectGetRequest
 */
export interface StaffApiUsersStaffListSelectStaffSelectGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {StaffQueryOrder}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly order?: StaffQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Staff Position id.
     * @type {number}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly positionId?: number

    /**
     * Staff status. Active is default.
     * @type {StaffStatuses}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly staffStatus?: StaffStatuses

    /**
     * Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
     * @type {Array<string>}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly onlyWithPermissions?: Array<string>

    /**
     * Staff statuses. If None - all statuses will be shown.
     * @type {Array<StaffStatuses>}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly statuses?: Array<StaffStatuses>

    /**
     * Exclude superuser from list.
     * @type {boolean}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly excludeSuperuser?: boolean

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffListSelectStaffSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffListStaffGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffListStaffGetRequest
 */
export interface StaffApiUsersStaffListStaffGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {StaffQueryOrder}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly order?: StaffQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly excludeInactive?: boolean

    /**
     * Staff Position id.
     * @type {number}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly positionId?: number

    /**
     * Staff status. Active is default.
     * @type {StaffStatuses}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly staffStatus?: StaffStatuses

    /**
     * Only staff with specified permission will be returned.Used in closing documents modal. (\&#39;crm_change_clients\&#39; + \&#39;crm_change_client_order\&#39;)Also used for manager lookup (\&#39;crm_change_clients, warehouse_change_suppliers, crm_change_agent_access\&#39;)У менеджера выбираемого клиенту должны быть права: crm_change_clients, auto_distribution_clients_view
     * @type {Array<string>}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly onlyWithPermissions?: Array<string>

    /**
     * Staff statuses. If None - all statuses will be shown.
     * @type {Array<StaffStatuses>}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly statuses?: Array<StaffStatuses>

    /**
     * Exclude superuser from list.
     * @type {boolean}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly excludeSuperuser?: boolean

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffListStaffGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffStatisticsStaffStaffIdStatisticsGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGetRequest
 */
export interface StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGet
     */
    readonly staffId: string

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffUpdateAvatarStaffStaffIdAvatarPut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPutRequest
 */
export interface StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPut
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPut
     */
    readonly acceptLanguage?: string

    /**
     * Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
     * @type {File}
     * @memberof StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPut
     */
    readonly avatar?: File
}

/**
 * Request parameters for usersStaffUpdateStaffStaffIdPut operation in StaffApi.
 * @export
 * @interface StaffApiUsersStaffUpdateStaffStaffIdPutRequest
 */
export interface StaffApiUsersStaffUpdateStaffStaffIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffUpdateStaffStaffIdPut
     */
    readonly staffId: string

    /**
     * 
     * @type {StaffUpdateSchema}
     * @memberof StaffApiUsersStaffUpdateStaffStaffIdPut
     */
    readonly staffUpdateSchema: StaffUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersStaffUpdateStaffStaffIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersUnclosedDocumentsStaffUnclosedDocumentsGet operation in StaffApi.
 * @export
 * @interface StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGetRequest
 */
export interface StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGet
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * StaffApi - object-oriented interface
 * @export
 * @class StaffApi
 * @extends {BaseAPI}
 */
export class StaffApi extends BaseAPI {
    /**
     * Activate staff user.  Role check: is_staff.  Permission: staff_change.
     * @summary Activate staff user. Both for \'in processing\' and \'inactive\' users.
     * @param {StaffApiUsersStaffActivateStaffStaffIdActivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffActivateStaffStaffIdActivatePut(requestParameters: StaffApiUsersStaffActivateStaffStaffIdActivatePutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffActivateStaffStaffIdActivatePut(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change staff user login.  Role check: is_staff.  Permission: staff_change.
     * @summary Change staff user login.
     * @param {StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffChangeLoginStaffStaffIdChangeLoginPut(requestParameters: StaffApiUsersStaffChangeLoginStaffStaffIdChangeLoginPutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffChangeLoginStaffStaffIdChangeLoginPut(requestParameters.staffId, requestParameters.staffUpdateEmailSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create staff user.  Role check: is_staff.  Permission: staff_change.
     * @summary Create staff user.
     * @param {StaffApiUsersStaffCreateStaffPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffCreateStaffPost(requestParameters: StaffApiUsersStaffCreateStaffPostRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffCreateStaffPost(requestParameters.staffCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate staff user and change responsible for all his orders.  Role check: is_staff.  Permission: staff_change.
     * @summary Deactivate staff user.
     * @param {StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffDeactivateStaffStaffIdDeactivatePut(requestParameters: StaffApiUsersStaffDeactivateStaffStaffIdDeactivatePutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffDeactivateStaffStaffIdDeactivatePut(requestParameters.staffId, requestParameters.deactivateStaffSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete staff user.  Role check: is_staff.  Permission: staff_change.
     * @summary Delete \'in processing\' staff user.
     * @param {StaffApiUsersStaffDeleteStaffStaffIdDeleteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffDeleteStaffStaffIdDeleteDelete(requestParameters: StaffApiUsersStaffDeleteStaffStaffIdDeleteDeleteRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffDeleteStaffStaffIdDeleteDelete(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if staff user can be fired.  Role check: is_staff.  Permission: staff_change.
     * @summary Make fire check for staff user.
     * @param {StaffApiUsersStaffFireCheckStaffStaffIdFireGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffFireCheckStaffStaffIdFireGet(requestParameters: StaffApiUsersStaffFireCheckStaffStaffIdFireGetRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffFireCheckStaffStaffIdFireGet(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fire staff user.  Role check: is_staff.  Permission: staff_change.
     * @summary Fire staff user.
     * @param {StaffApiUsersStaffFireStaffStaffIdFirePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffFireStaffStaffIdFirePut(requestParameters: StaffApiUsersStaffFireStaffStaffIdFirePutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffFireStaffStaffIdFirePut(requestParameters.staffId, requestParameters.fireStaffSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate temporary password for staff user.  Role check: is_staff.  Permission: staff_change.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent. Superuser password cannot be generated/reset.
     * @summary Generate temporary password for staff user.
     * @param {StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut(requestParameters: StaffApiUsersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffGenerateTemporaryPasswordStaffStaffIdGenerateTemporaryPasswordPut(requestParameters.staffId, requestParameters.acceptLanguage, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff user.  Role check: is_staff.  Permission: staff_view.
     * @summary Get staff user full info.
     * @param {StaffApiUsersStaffGetFullInfoStaffStaffIdFullInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffGetFullInfoStaffStaffIdFullInfoGet(requestParameters: StaffApiUsersStaffGetFullInfoStaffStaffIdFullInfoGetRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffGetFullInfoStaffStaffIdFullInfoGet(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
     * @summary Get staff user.
     * @param {StaffApiUsersStaffGetSelectStaffStaffIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffGetSelectStaffStaffIdSelectGet(requestParameters: StaffApiUsersStaffGetSelectStaffStaffIdSelectGetRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffGetSelectStaffStaffIdSelectGet(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff user.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
     * @summary Get staff user.
     * @param {StaffApiUsersStaffGetStaffStaffIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffGetStaffStaffIdGet(requestParameters: StaffApiUsersStaffGetStaffStaffIdGetRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffGetStaffStaffIdGet(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
     * @summary List of staff users.
     * @param {StaffApiUsersStaffListSelectStaffSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffListSelectStaffSelectGet(requestParameters: StaffApiUsersStaffListSelectStaffSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffListSelectStaffSelectGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.positionId, requestParameters.staffStatus, requestParameters.onlyWithPermissions, requestParameters.statuses, requestParameters.excludeSuperuser, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff users.  Role check: is_staff.  Permission: staff_view.  Use \'only_with_permissions\' query param to filter staff users by permissions. Samples: crm_change_clients, warehouse_change_suppliers, crm_change_agent_access This is used for manager lookup for user create/update.
     * @summary List of staff users.
     * @param {StaffApiUsersStaffListStaffGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffListStaffGet(requestParameters: StaffApiUsersStaffListStaffGetRequest = {}, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffListStaffGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.positionId, requestParameters.staffStatus, requestParameters.onlyWithPermissions, requestParameters.statuses, requestParameters.excludeSuperuser, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff user clients statistic.  Role check: is_staff.  Permission: staff_view. permissions_staff_skip_for_myself: True.
     * @summary Get staff user clients statistic.
     * @param {StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffStatisticsStaffStaffIdStatisticsGet(requestParameters: StaffApiUsersStaffStatisticsStaffStaffIdStatisticsGetRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffStatisticsStaffStaffIdStatisticsGet(requestParameters.staffId, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change staff user avatar.  Role check: is_staff.  Permission: staff_change.
     * @summary Change staff user avatar.
     * @param {StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffUpdateAvatarStaffStaffIdAvatarPut(requestParameters: StaffApiUsersStaffUpdateAvatarStaffStaffIdAvatarPutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffUpdateAvatarStaffStaffIdAvatarPut(requestParameters.staffId, requestParameters.acceptLanguage, requestParameters.avatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update staff user.  Role check: is_staff.  Permission: staff_change.  Always send \'email\' field, even if it is not changed or if it is read-only. Email will be changed only if it is not used by another user and only if user status in DB is \'in processing\'.
     * @summary Update staff user.
     * @param {StaffApiUsersStaffUpdateStaffStaffIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersStaffUpdateStaffStaffIdPut(requestParameters: StaffApiUsersStaffUpdateStaffStaffIdPutRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersStaffUpdateStaffStaffIdPut(requestParameters.staffId, requestParameters.staffUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent/staff unclosed documents.  Role check: is_staff. Permission: staff_change, staff_view.
     * @summary Get agent/staff unclosed documents
     * @param {StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffApi
     */
    public usersUnclosedDocumentsStaffUnclosedDocumentsGet(requestParameters: StaffApiUsersUnclosedDocumentsStaffUnclosedDocumentsGetRequest, options?: AxiosRequestConfig) {
        return StaffApiFp(this.configuration).usersUnclosedDocumentsStaffUnclosedDocumentsGet(requestParameters.userId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StaffPermissionsApi - axios parameter creator
 * @export
 */
export const StaffPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get staff user permissions.  Role check: is_staff.  Permission: staff_view.
         * @summary List of staff user permissions.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffPermissionsListStaffPermissionsStaffIdGet: async (staffId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffPermissionsListStaffPermissionsStaffIdGet', 'staffId', staffId)
            const localVarPath = `/staff/permissions/{staff_id}/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staff user permissions.  Role check: is_staff.  Permission: staff_change.  Superuser permission can\'t be changed (PermissionsUpdateException will be raised). Inactive staff user permissions can\'t be changed (PermissionsUpdateException will be raised).  view_users_permissions: list[bool] = [     staff_permissions.crm_view_clients,     staff_permissions.warehouse_view_suppliers,     staff_permissions.crm_view_other_manager_client_access,     staff_permissions.warehouse_view_other_manager_supplier_access, ]  compensation_permissions: list[bool] = [     staff_permissions.crm_warehouse_view_compensation,     staff_permissions.crm_warehouse_change_compensation,     staff_permissions.crm_warehouse_post_compensation,     staff_permissions.crm_warehouse_cancel_compensation, ]  If ANY among compensation_permissions is presented (true), then ALL of view_users_permissions should be presented (true). Otherwise, PermissionsUpdateException will be raised.
         * @summary Update staff user permissions.
         * @param {string} staffId 
         * @param {StaffPermissionsSchema} staffPermissionsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffPermissionsUpdateStaffPermissionsStaffIdPut: async (staffId: string, staffPermissionsSchema: StaffPermissionsSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('usersStaffPermissionsUpdateStaffPermissionsStaffIdPut', 'staffId', staffId)
            // verify required parameter 'staffPermissionsSchema' is not null or undefined
            assertParamExists('usersStaffPermissionsUpdateStaffPermissionsStaffIdPut', 'staffPermissionsSchema', staffPermissionsSchema)
            const localVarPath = `/staff/permissions/{staff_id}/`
                .replace(`{${"staff_id"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffPermissionsSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaffPermissionsApi - functional programming interface
 * @export
 */
export const StaffPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaffPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get staff user permissions.  Role check: is_staff.  Permission: staff_view.
         * @summary List of staff user permissions.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffPermissionsListStaffPermissionsStaffIdGet(staffId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPermissionsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffPermissionsListStaffPermissionsStaffIdGet(staffId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get staff user permissions.  Role check: is_staff.  Permission: staff_change.  Superuser permission can\'t be changed (PermissionsUpdateException will be raised). Inactive staff user permissions can\'t be changed (PermissionsUpdateException will be raised).  view_users_permissions: list[bool] = [     staff_permissions.crm_view_clients,     staff_permissions.warehouse_view_suppliers,     staff_permissions.crm_view_other_manager_client_access,     staff_permissions.warehouse_view_other_manager_supplier_access, ]  compensation_permissions: list[bool] = [     staff_permissions.crm_warehouse_view_compensation,     staff_permissions.crm_warehouse_change_compensation,     staff_permissions.crm_warehouse_post_compensation,     staff_permissions.crm_warehouse_cancel_compensation, ]  If ANY among compensation_permissions is presented (true), then ALL of view_users_permissions should be presented (true). Otherwise, PermissionsUpdateException will be raised.
         * @summary Update staff user permissions.
         * @param {string} staffId 
         * @param {StaffPermissionsSchema} staffPermissionsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStaffPermissionsUpdateStaffPermissionsStaffIdPut(staffId: string, staffPermissionsSchema: StaffPermissionsSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffPermissionsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStaffPermissionsUpdateStaffPermissionsStaffIdPut(staffId, staffPermissionsSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StaffPermissionsApi - factory interface
 * @export
 */
export const StaffPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaffPermissionsApiFp(configuration)
    return {
        /**
         * Get staff user permissions.  Role check: is_staff.  Permission: staff_view.
         * @summary List of staff user permissions.
         * @param {string} staffId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffPermissionsListStaffPermissionsStaffIdGet(staffId: string, acceptLanguage?: string, options?: any): AxiosPromise<StaffPermissionsSchema> {
            return localVarFp.usersStaffPermissionsListStaffPermissionsStaffIdGet(staffId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staff user permissions.  Role check: is_staff.  Permission: staff_change.  Superuser permission can\'t be changed (PermissionsUpdateException will be raised). Inactive staff user permissions can\'t be changed (PermissionsUpdateException will be raised).  view_users_permissions: list[bool] = [     staff_permissions.crm_view_clients,     staff_permissions.warehouse_view_suppliers,     staff_permissions.crm_view_other_manager_client_access,     staff_permissions.warehouse_view_other_manager_supplier_access, ]  compensation_permissions: list[bool] = [     staff_permissions.crm_warehouse_view_compensation,     staff_permissions.crm_warehouse_change_compensation,     staff_permissions.crm_warehouse_post_compensation,     staff_permissions.crm_warehouse_cancel_compensation, ]  If ANY among compensation_permissions is presented (true), then ALL of view_users_permissions should be presented (true). Otherwise, PermissionsUpdateException will be raised.
         * @summary Update staff user permissions.
         * @param {string} staffId 
         * @param {StaffPermissionsSchema} staffPermissionsSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStaffPermissionsUpdateStaffPermissionsStaffIdPut(staffId: string, staffPermissionsSchema: StaffPermissionsSchema, acceptLanguage?: string, options?: any): AxiosPromise<StaffPermissionsSchema> {
            return localVarFp.usersStaffPermissionsUpdateStaffPermissionsStaffIdPut(staffId, staffPermissionsSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersStaffPermissionsListStaffPermissionsStaffIdGet operation in StaffPermissionsApi.
 * @export
 * @interface StaffPermissionsApiUsersStaffPermissionsListStaffPermissionsStaffIdGetRequest
 */
export interface StaffPermissionsApiUsersStaffPermissionsListStaffPermissionsStaffIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffPermissionsApiUsersStaffPermissionsListStaffPermissionsStaffIdGet
     */
    readonly staffId: string

    /**
     * 
     * @type {string}
     * @memberof StaffPermissionsApiUsersStaffPermissionsListStaffPermissionsStaffIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersStaffPermissionsUpdateStaffPermissionsStaffIdPut operation in StaffPermissionsApi.
 * @export
 * @interface StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPutRequest
 */
export interface StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPut
     */
    readonly staffId: string

    /**
     * 
     * @type {StaffPermissionsSchema}
     * @memberof StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPut
     */
    readonly staffPermissionsSchema: StaffPermissionsSchema

    /**
     * 
     * @type {string}
     * @memberof StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * StaffPermissionsApi - object-oriented interface
 * @export
 * @class StaffPermissionsApi
 * @extends {BaseAPI}
 */
export class StaffPermissionsApi extends BaseAPI {
    /**
     * Get staff user permissions.  Role check: is_staff.  Permission: staff_view.
     * @summary List of staff user permissions.
     * @param {StaffPermissionsApiUsersStaffPermissionsListStaffPermissionsStaffIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffPermissionsApi
     */
    public usersStaffPermissionsListStaffPermissionsStaffIdGet(requestParameters: StaffPermissionsApiUsersStaffPermissionsListStaffPermissionsStaffIdGetRequest, options?: AxiosRequestConfig) {
        return StaffPermissionsApiFp(this.configuration).usersStaffPermissionsListStaffPermissionsStaffIdGet(requestParameters.staffId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staff user permissions.  Role check: is_staff.  Permission: staff_change.  Superuser permission can\'t be changed (PermissionsUpdateException will be raised). Inactive staff user permissions can\'t be changed (PermissionsUpdateException will be raised).  view_users_permissions: list[bool] = [     staff_permissions.crm_view_clients,     staff_permissions.warehouse_view_suppliers,     staff_permissions.crm_view_other_manager_client_access,     staff_permissions.warehouse_view_other_manager_supplier_access, ]  compensation_permissions: list[bool] = [     staff_permissions.crm_warehouse_view_compensation,     staff_permissions.crm_warehouse_change_compensation,     staff_permissions.crm_warehouse_post_compensation,     staff_permissions.crm_warehouse_cancel_compensation, ]  If ANY among compensation_permissions is presented (true), then ALL of view_users_permissions should be presented (true). Otherwise, PermissionsUpdateException will be raised.
     * @summary Update staff user permissions.
     * @param {StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaffPermissionsApi
     */
    public usersStaffPermissionsUpdateStaffPermissionsStaffIdPut(requestParameters: StaffPermissionsApiUsersStaffPermissionsUpdateStaffPermissionsStaffIdPutRequest, options?: AxiosRequestConfig) {
        return StaffPermissionsApiFp(this.configuration).usersStaffPermissionsUpdateStaffPermissionsStaffIdPut(requestParameters.staffId, requestParameters.staffPermissionsSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SuppliersApi - axios parameter creator
 * @export
 */
export const SuppliersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Activate staff user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersActivateSuppliersSupplierIdActivatePut: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersActivateSuppliersSupplierIdActivatePut', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/activate/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier user login.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Change supplier user login.
         * @param {string} supplierId 
         * @param {SupplierUpdateEmailSchema} supplierUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut: async (supplierId: string, supplierUpdateEmailSchema: SupplierUpdateEmailSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut', 'supplierId', supplierId)
            // verify required parameter 'supplierUpdateEmailSchema' is not null or undefined
            assertParamExists('usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut', 'supplierUpdateEmailSchema', supplierUpdateEmailSchema)
            const localVarPath = `/suppliers/{supplier_id}/change-login/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierUpdateEmailSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier user phone.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Send an email with a new phone to a supplier.
         * @summary Change supplier user phone.
         * @param {string} supplierId 
         * @param {SupplierUpdatePhoneSchema} supplierUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut: async (supplierId: string, supplierUpdatePhoneSchema: SupplierUpdatePhoneSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut', 'supplierId', supplierId)
            // verify required parameter 'supplierUpdatePhoneSchema' is not null or undefined
            assertParamExists('usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut', 'supplierUpdatePhoneSchema', supplierUpdatePhoneSchema)
            const localVarPath = `/suppliers/{supplier_id}/change-phone/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierUpdatePhoneSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Create supplier user.
         * @param {SupplierCreateSchema} supplierCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersCreateSuppliersPost: async (supplierCreateSchema: SupplierCreateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierCreateSchema' is not null or undefined
            assertParamExists('usersSuppliersCreateSuppliersPost', 'supplierCreateSchema', supplierCreateSchema)
            const localVarPath = `/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Deactivate staff user.
         * @param {string} supplierId 
         * @param {SupplierDeactivationSchema} supplierDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut: async (supplierId: string, supplierDeactivationSchema: SupplierDeactivationSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut', 'supplierId', supplierId)
            // verify required parameter 'supplierDeactivationSchema' is not null or undefined
            assertParamExists('usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut', 'supplierDeactivationSchema', supplierDeactivationSchema)
            const localVarPath = `/suppliers/{supplier_id}/deactivate/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierDeactivationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Check if user has debts or overpayments.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/debts-and-overpayments/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Delete \'in processing\' supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersDeleteSuppliersSupplierIdDeleteDelete: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersDeleteSuppliersSupplierIdDeleteDelete', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/delete/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate temporary password for supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for supplier user.
         * @param {string} supplierId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut: async (supplierId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut', 'supplierId', supplierId)
            // verify required parameter 'generateTemporaryPasswordSchema' is not null or undefined
            assertParamExists('usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut', 'generateTemporaryPasswordSchema', generateTemporaryPasswordSchema)
            const localVarPath = `/suppliers/{supplier_id}/generate-temporary-password/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateTemporaryPasswordSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier user full info.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user full info.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/full-info/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGetSelectSuppliersSupplierIdSelectGet: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersGetSelectSuppliersSupplierIdSelectGet', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/select/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGetSuppliersSupplierIdGet: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersGetSuppliersSupplierIdGet', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of suppliers users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {SupplierQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [supplierCategoryId] 
         * @param {SupplierStatuses} [supplierStatus] 
         * @param {string} [supplierManagerId] Supplier manager id. Use for staff suppliers list (pass current user id).
         * @param {SupplierLabels} [label] Supplier label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersListSelectSuppliersSelectGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: SupplierQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, supplierCategoryId?: number, supplierStatus?: SupplierStatuses, supplierManagerId?: string, label?: SupplierLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/suppliers/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (supplierStatus !== undefined) {
                localVarQueryParameter['supplierStatus'] = supplierStatus;
            }

            if (supplierManagerId !== undefined) {
                localVarQueryParameter['supplierManagerId'] = supplierManagerId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of suppliers users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {SupplierQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [supplierCategoryId] 
         * @param {SupplierStatuses} [supplierStatus] 
         * @param {string} [supplierManagerId] Supplier manager id. Use for staff suppliers list (pass current user id).
         * @param {SupplierLabels} [label] Supplier label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersListSuppliersGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: SupplierQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, supplierCategoryId?: number, supplierStatus?: SupplierStatuses, supplierManagerId?: string, label?: SupplierLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/suppliers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counterAgentKind'] = counterAgentKind;
            }

            if (supplierCategoryId !== undefined) {
                localVarQueryParameter['supplierCategoryId'] = supplierCategoryId;
            }

            if (supplierStatus !== undefined) {
                localVarQueryParameter['supplierStatus'] = supplierStatus;
            }

            if (supplierManagerId !== undefined) {
                localVarQueryParameter['supplierManagerId'] = supplierManagerId;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send current supplier user phone to email after phone change.  Role check: is_staff. Permission: warehouse_change_suppliers
         * @summary Send current supplier user phone to email after phone change.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost', 'supplierId', supplierId)
            const localVarPath = `/suppliers/{supplier_id}/send-phone-email/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier user statistics.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user statistics.
         * @param {string} supplierId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet: async (supplierId: string, currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet', 'supplierId', supplierId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet', 'currencyId', currencyId)
            const localVarPath = `/suppliers/{supplier_id}/statistics/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currencyId !== undefined) {
                localVarQueryParameter['currencyId'] = currencyId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Turn to supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers, warehouse_change_suppliers, warehouse_change_other_manager_supplier_access
         * @summary Add supplier role to user.
         * @param {string} userId 
         * @param {SupplierTurnSchema} supplierTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut: async (userId: string, supplierTurnSchema: SupplierTurnSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut', 'userId', userId)
            // verify required parameter 'supplierTurnSchema' is not null or undefined
            assertParamExists('usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut', 'supplierTurnSchema', supplierTurnSchema)
            const localVarPath = `/suppliers/{user_id}/turn-supplier/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierTurnSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change supplier user avatar.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change supplier user avatar.
         * @param {string} supplierId 
         * @param {File} avatar Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut: async (supplierId: string, avatar: File, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut', 'supplierId', supplierId)
            // verify required parameter 'avatar' is not null or undefined
            assertParamExists('usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut', 'avatar', avatar)
            const localVarPath = `/suppliers/{supplier_id}/avatar/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Requires \'warehouse_change_price_type\' permission to change a price type.  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if supplier status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update supplier user.
         * @param {string} supplierId 
         * @param {SupplierUpdateSchema} supplierUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersUpdateSuppliersSupplierIdPut: async (supplierId: string, supplierUpdateSchema: SupplierUpdateSchema, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('usersSuppliersUpdateSuppliersSupplierIdPut', 'supplierId', supplierId)
            // verify required parameter 'supplierUpdateSchema' is not null or undefined
            assertParamExists('usersSuppliersUpdateSuppliersSupplierIdPut', 'supplierUpdateSchema', supplierUpdateSchema)
            const localVarPath = `/suppliers/{supplier_id}/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supplierUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuppliersApi - functional programming interface
 * @export
 */
export const SuppliersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SuppliersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Activate staff user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersActivateSuppliersSupplierIdActivatePut(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersActivateSuppliersSupplierIdActivatePut(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier user login.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Change supplier user login.
         * @param {string} supplierId 
         * @param {SupplierUpdateEmailSchema} supplierUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut(supplierId: string, supplierUpdateEmailSchema: SupplierUpdateEmailSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut(supplierId, supplierUpdateEmailSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier user phone.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Send an email with a new phone to a supplier.
         * @summary Change supplier user phone.
         * @param {string} supplierId 
         * @param {SupplierUpdatePhoneSchema} supplierUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut(supplierId: string, supplierUpdatePhoneSchema: SupplierUpdatePhoneSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut(supplierId, supplierUpdatePhoneSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Create supplier user.
         * @param {SupplierCreateSchema} supplierCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersCreateSuppliersPost(supplierCreateSchema: SupplierCreateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersCreateSuppliersPost(supplierCreateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Deactivate staff user.
         * @param {string} supplierId 
         * @param {SupplierDeactivationSchema} supplierDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut(supplierId: string, supplierDeactivationSchema: SupplierDeactivationSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut(supplierId, supplierDeactivationSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Check if user has debts or overpayments.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DebtOrOverpaymentSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Delete \'in processing\' supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersDeleteSuppliersSupplierIdDeleteDelete(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersDeleteSuppliersSupplierIdDeleteDelete(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate temporary password for supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for supplier user.
         * @param {string} supplierId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut(supplierId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut(supplierId, generateTemporaryPasswordSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier user full info.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user full info.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierFullInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersGetSelectSuppliersSupplierIdSelectGet(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleUserSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersGetSelectSuppliersSupplierIdSelectGet(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersGetSuppliersSupplierIdGet(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersGetSuppliersSupplierIdGet(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of suppliers users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {SupplierQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [supplierCategoryId] 
         * @param {SupplierStatuses} [supplierStatus] 
         * @param {string} [supplierManagerId] Supplier manager id. Use for staff suppliers list (pass current user id).
         * @param {SupplierLabels} [label] Supplier label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersListSelectSuppliersSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: SupplierQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, supplierCategoryId?: number, supplierStatus?: SupplierStatuses, supplierManagerId?: string, label?: SupplierLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSimplePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersListSelectSuppliersSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, supplierCategoryId, supplierStatus, supplierManagerId, label, currencyId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of suppliers users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {SupplierQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [supplierCategoryId] 
         * @param {SupplierStatuses} [supplierStatus] 
         * @param {string} [supplierManagerId] Supplier manager id. Use for staff suppliers list (pass current user id).
         * @param {SupplierLabels} [label] Supplier label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersListSuppliersGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: SupplierQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, supplierCategoryId?: number, supplierStatus?: SupplierStatuses, supplierManagerId?: string, label?: SupplierLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersListSuppliersGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, supplierCategoryId, supplierStatus, supplierManagerId, label, currencyId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send current supplier user phone to email after phone change.  Role check: is_staff. Permission: warehouse_change_suppliers
         * @summary Send current supplier user phone to email after phone change.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier user statistics.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user statistics.
         * @param {string} supplierId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet(supplierId: string, currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStatisticsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet(supplierId, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Turn to supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers, warehouse_change_suppliers, warehouse_change_other_manager_supplier_access
         * @summary Add supplier role to user.
         * @param {string} userId 
         * @param {SupplierTurnSchema} supplierTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut(userId: string, supplierTurnSchema: SupplierTurnSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut(userId, supplierTurnSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change supplier user avatar.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change supplier user avatar.
         * @param {string} supplierId 
         * @param {File} avatar Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut(supplierId: string, avatar: File, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut(supplierId, avatar, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Requires \'warehouse_change_price_type\' permission to change a price type.  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if supplier status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update supplier user.
         * @param {string} supplierId 
         * @param {SupplierUpdateSchema} supplierUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSuppliersUpdateSuppliersSupplierIdPut(supplierId: string, supplierUpdateSchema: SupplierUpdateSchema, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSuppliersUpdateSuppliersSupplierIdPut(supplierId, supplierUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SuppliersApi - factory interface
 * @export
 */
export const SuppliersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SuppliersApiFp(configuration)
    return {
        /**
         * Activate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Activate staff user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersActivateSuppliersSupplierIdActivatePut(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersActivateSuppliersSupplierIdActivatePut(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier user login.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Change supplier user login.
         * @param {string} supplierId 
         * @param {SupplierUpdateEmailSchema} supplierUpdateEmailSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut(supplierId: string, supplierUpdateEmailSchema: SupplierUpdateEmailSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut(supplierId, supplierUpdateEmailSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier user phone.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Send an email with a new phone to a supplier.
         * @summary Change supplier user phone.
         * @param {string} supplierId 
         * @param {SupplierUpdatePhoneSchema} supplierUpdatePhoneSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut(supplierId: string, supplierUpdatePhoneSchema: SupplierUpdatePhoneSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut(supplierId, supplierUpdatePhoneSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create staff user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Create supplier user.
         * @param {SupplierCreateSchema} supplierCreateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersCreateSuppliersPost(supplierCreateSchema: SupplierCreateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersCreateSuppliersPost(supplierCreateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Deactivate staff user.
         * @param {string} supplierId 
         * @param {SupplierDeactivationSchema} supplierDeactivationSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut(supplierId: string, supplierDeactivationSchema: SupplierDeactivationSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut(supplierId, supplierDeactivationSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if user has debts or overpayments.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Check if user has debts or overpayments.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<Array<DebtOrOverpaymentSchema>> {
            return localVarFp.usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Delete \'in processing\' supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersDeleteSuppliersSupplierIdDeleteDelete(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersSuppliersDeleteSuppliersSupplierIdDeleteDelete(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate temporary password for supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
         * @summary Generate temporary password for supplier user.
         * @param {string} supplierId 
         * @param {GenerateTemporaryPasswordSchema} generateTemporaryPasswordSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut(supplierId: string, generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut(supplierId, generateTemporaryPasswordSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier user full info.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user full info.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<SupplierFullInfoSchema> {
            return localVarFp.usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGetSelectSuppliersSupplierIdSelectGet(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<SimpleUserSchema> {
            return localVarFp.usersSuppliersGetSelectSuppliersSupplierIdSelectGet(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersGetSuppliersSupplierIdGet(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersGetSuppliersSupplierIdGet(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of suppliers users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {SupplierQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [supplierCategoryId] 
         * @param {SupplierStatuses} [supplierStatus] 
         * @param {string} [supplierManagerId] Supplier manager id. Use for staff suppliers list (pass current user id).
         * @param {SupplierLabels} [label] Supplier label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersListSelectSuppliersSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: SupplierQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, supplierCategoryId?: number, supplierStatus?: SupplierStatuses, supplierManagerId?: string, label?: SupplierLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSimplePage> {
            return localVarFp.usersSuppliersListSelectSuppliersSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, supplierCategoryId, supplierStatus, supplierManagerId, label, currencyId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary List of suppliers users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {SupplierQueryOrder} [order] Ordering. Desc id is default.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {CounterAgentKinds} [counterAgentKind] 
         * @param {number} [supplierCategoryId] 
         * @param {SupplierStatuses} [supplierStatus] 
         * @param {string} [supplierManagerId] Supplier manager id. Use for staff suppliers list (pass current user id).
         * @param {SupplierLabels} [label] Supplier label.
         * @param {number} [currencyId] Currency id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersListSuppliersGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: SupplierQueryOrder, sort?: BaseSort, excludeInactive?: boolean, counterAgentKind?: CounterAgentKinds, supplierCategoryId?: number, supplierStatus?: SupplierStatuses, supplierManagerId?: string, label?: SupplierLabels, currencyId?: number, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<SupplierPage> {
            return localVarFp.usersSuppliersListSuppliersGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, counterAgentKind, supplierCategoryId, supplierStatus, supplierManagerId, label, currencyId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Send current supplier user phone to email after phone change.  Role check: is_staff. Permission: warehouse_change_suppliers
         * @summary Send current supplier user phone to email after phone change.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier user statistics.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Get supplier user statistics.
         * @param {string} supplierId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet(supplierId: string, currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<UserStatisticsSchema> {
            return localVarFp.usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet(supplierId, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Turn to supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers, warehouse_change_suppliers, warehouse_change_other_manager_supplier_access
         * @summary Add supplier role to user.
         * @param {string} userId 
         * @param {SupplierTurnSchema} supplierTurnSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut(userId: string, supplierTurnSchema: SupplierTurnSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut(userId, supplierTurnSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Change supplier user avatar.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
         * @summary Change supplier user avatar.
         * @param {string} supplierId 
         * @param {File} avatar Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut(supplierId: string, avatar: File, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut(supplierId, avatar, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Requires \'warehouse_change_price_type\' permission to change a price type.  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if supplier status in [IN_PROCESSING, UNCONFIRMED]
         * @summary Update supplier user.
         * @param {string} supplierId 
         * @param {SupplierUpdateSchema} supplierUpdateSchema 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSuppliersUpdateSuppliersSupplierIdPut(supplierId: string, supplierUpdateSchema: SupplierUpdateSchema, acceptLanguage?: string, options?: any): AxiosPromise<SupplierSchema> {
            return localVarFp.usersSuppliersUpdateSuppliersSupplierIdPut(supplierId, supplierUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersSuppliersActivateSuppliersSupplierIdActivatePut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersActivateSuppliersSupplierIdActivatePutRequest
 */
export interface SuppliersApiUsersSuppliersActivateSuppliersSupplierIdActivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersActivateSuppliersSupplierIdActivatePut
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersActivateSuppliersSupplierIdActivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPutRequest
 */
export interface SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut
     */
    readonly supplierId: string

    /**
     * 
     * @type {SupplierUpdateEmailSchema}
     * @memberof SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut
     */
    readonly supplierUpdateEmailSchema: SupplierUpdateEmailSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePutRequest
 */
export interface SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut
     */
    readonly supplierId: string

    /**
     * 
     * @type {SupplierUpdatePhoneSchema}
     * @memberof SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut
     */
    readonly supplierUpdatePhoneSchema: SupplierUpdatePhoneSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersCreateSuppliersPost operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersCreateSuppliersPostRequest
 */
export interface SuppliersApiUsersSuppliersCreateSuppliersPostRequest {
    /**
     * 
     * @type {SupplierCreateSchema}
     * @memberof SuppliersApiUsersSuppliersCreateSuppliersPost
     */
    readonly supplierCreateSchema: SupplierCreateSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersCreateSuppliersPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePutRequest
 */
export interface SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePut
     */
    readonly supplierId: string

    /**
     * 
     * @type {SupplierDeactivationSchema}
     * @memberof SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePut
     */
    readonly supplierDeactivationSchema: SupplierDeactivationSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGetRequest
 */
export interface SuppliersApiUsersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersDeleteSuppliersSupplierIdDeleteDelete operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersDeleteSuppliersSupplierIdDeleteDeleteRequest
 */
export interface SuppliersApiUsersSuppliersDeleteSuppliersSupplierIdDeleteDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersDeleteSuppliersSupplierIdDeleteDelete
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersDeleteSuppliersSupplierIdDeleteDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPutRequest
 */
export interface SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut
     */
    readonly supplierId: string

    /**
     * 
     * @type {GenerateTemporaryPasswordSchema}
     * @memberof SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut
     */
    readonly generateTemporaryPasswordSchema: GenerateTemporaryPasswordSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGetRequest
 */
export interface SuppliersApiUsersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersGetSelectSuppliersSupplierIdSelectGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersGetSelectSuppliersSupplierIdSelectGetRequest
 */
export interface SuppliersApiUsersSuppliersGetSelectSuppliersSupplierIdSelectGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGetSelectSuppliersSupplierIdSelectGet
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGetSelectSuppliersSupplierIdSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersGetSuppliersSupplierIdGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersGetSuppliersSupplierIdGetRequest
 */
export interface SuppliersApiUsersSuppliersGetSuppliersSupplierIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGetSuppliersSupplierIdGet
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersGetSuppliersSupplierIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersListSelectSuppliersSelectGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersListSelectSuppliersSelectGetRequest
 */
export interface SuppliersApiUsersSuppliersListSelectSuppliersSelectGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {SupplierQueryOrder}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly order?: SupplierQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierStatuses}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly supplierStatus?: SupplierStatuses

    /**
     * Supplier manager id. Use for staff suppliers list (pass current user id).
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly supplierManagerId?: string

    /**
     * Supplier label.
     * @type {SupplierLabels}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly label?: SupplierLabels

    /**
     * Currency id.
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSelectSuppliersSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersListSuppliersGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersListSuppliersGetRequest
 */
export interface SuppliersApiUsersSuppliersListSuppliersGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly countryId?: number

    /**
     * Ordering. Desc id is default.
     * @type {SupplierQueryOrder}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly order?: SupplierQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly excludeInactive?: boolean

    /**
     * 
     * @type {CounterAgentKinds}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly counterAgentKind?: CounterAgentKinds

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly supplierCategoryId?: number

    /**
     * 
     * @type {SupplierStatuses}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly supplierStatus?: SupplierStatuses

    /**
     * Supplier manager id. Use for staff suppliers list (pass current user id).
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly supplierManagerId?: string

    /**
     * Supplier label.
     * @type {SupplierLabels}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly label?: SupplierLabels

    /**
     * Currency id.
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly currencyId?: number

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersListSuppliersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPostRequest
 */
export interface SuppliersApiUsersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGetRequest
 */
export interface SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGet
     */
    readonly supplierId: string

    /**
     * 
     * @type {number}
     * @memberof SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPutRequest
 */
export interface SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut
     */
    readonly userId: string

    /**
     * 
     * @type {SupplierTurnSchema}
     * @memberof SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut
     */
    readonly supplierTurnSchema: SupplierTurnSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPutRequest
 */
export interface SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut
     */
    readonly supplierId: string

    /**
     * Avatar file, not more than 5MB. JPEG/PNG/WEBP formats are supported.
     * @type {File}
     * @memberof SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut
     */
    readonly avatar: File

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSuppliersUpdateSuppliersSupplierIdPut operation in SuppliersApi.
 * @export
 * @interface SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPutRequest
 */
export interface SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPut
     */
    readonly supplierId: string

    /**
     * 
     * @type {SupplierUpdateSchema}
     * @memberof SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPut
     */
    readonly supplierUpdateSchema: SupplierUpdateSchema

    /**
     * 
     * @type {string}
     * @memberof SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPut
     */
    readonly acceptLanguage?: string
}

/**
 * SuppliersApi - object-oriented interface
 * @export
 * @class SuppliersApi
 * @extends {BaseAPI}
 */
export class SuppliersApi extends BaseAPI {
    /**
     * Activate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Activate staff user.
     * @param {SuppliersApiUsersSuppliersActivateSuppliersSupplierIdActivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersActivateSuppliersSupplierIdActivatePut(requestParameters: SuppliersApiUsersSuppliersActivateSuppliersSupplierIdActivatePutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersActivateSuppliersSupplierIdActivatePut(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier user login.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
     * @summary Change supplier user login.
     * @param {SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut(requestParameters: SuppliersApiUsersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersChangeLoginSuppliersSupplierIdChangeLoginPut(requestParameters.supplierId, requestParameters.supplierUpdateEmailSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier user phone.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Send an email with a new phone to a supplier.
     * @summary Change supplier user phone.
     * @param {SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut(requestParameters: SuppliersApiUsersSuppliersChangePhoneSuppliersSupplierIdChangePhonePutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersChangePhoneSuppliersSupplierIdChangePhonePut(requestParameters.supplierId, requestParameters.supplierUpdatePhoneSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create staff user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Create supplier user.
     * @param {SuppliersApiUsersSuppliersCreateSuppliersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersCreateSuppliersPost(requestParameters: SuppliersApiUsersSuppliersCreateSuppliersPostRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersCreateSuppliersPost(requestParameters.supplierCreateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Deactivate staff user.
     * @param {SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut(requestParameters: SuppliersApiUsersSuppliersDeactivateSuppliersSupplierIdDeactivatePutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersDeactivateSuppliersSupplierIdDeactivatePut(requestParameters.supplierId, requestParameters.supplierDeactivationSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if user has debts or overpayments.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Check if user has debts or overpayments.
     * @param {SuppliersApiUsersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet(requestParameters: SuppliersApiUsersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGetRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersDebtsAndOverpaymentsSuppliersSupplierIdDebtsAndOverpaymentsGet(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Delete \'in processing\' supplier user.
     * @param {SuppliersApiUsersSuppliersDeleteSuppliersSupplierIdDeleteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersDeleteSuppliersSupplierIdDeleteDelete(requestParameters: SuppliersApiUsersSuppliersDeleteSuppliersSupplierIdDeleteDeleteRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersDeleteSuppliersSupplierIdDeleteDelete(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate temporary password for supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  If send_email is True, email with a temporary password will be sent to user. If send_email is False, a temporary password will be generated, but email will not be sent.
     * @summary Generate temporary password for supplier user.
     * @param {SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut(requestParameters: SuppliersApiUsersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersGenerateTemporaryPasswordSuppliersSupplierIdGenerateTemporaryPasswordPut(requestParameters.supplierId, requestParameters.generateTemporaryPasswordSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier user full info.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get supplier user full info.
     * @param {SuppliersApiUsersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet(requestParameters: SuppliersApiUsersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGetRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersGetFullInfoSuppliersSupplierIdFullInfoGet(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get supplier user.
     * @param {SuppliersApiUsersSuppliersGetSelectSuppliersSupplierIdSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersGetSelectSuppliersSupplierIdSelectGet(requestParameters: SuppliersApiUsersSuppliersGetSelectSuppliersSupplierIdSelectGetRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersGetSelectSuppliersSupplierIdSelectGet(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get supplier user.
     * @param {SuppliersApiUsersSuppliersGetSuppliersSupplierIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersGetSuppliersSupplierIdGet(requestParameters: SuppliersApiUsersSuppliersGetSuppliersSupplierIdGetRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersGetSuppliersSupplierIdGet(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary List of suppliers users.
     * @param {SuppliersApiUsersSuppliersListSelectSuppliersSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersListSelectSuppliersSelectGet(requestParameters: SuppliersApiUsersSuppliersListSelectSuppliersSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersListSelectSuppliersSelectGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.counterAgentKind, requestParameters.supplierCategoryId, requestParameters.supplierStatus, requestParameters.supplierManagerId, requestParameters.label, requestParameters.currencyId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier users.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary List of suppliers users.
     * @param {SuppliersApiUsersSuppliersListSuppliersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersListSuppliersGet(requestParameters: SuppliersApiUsersSuppliersListSuppliersGetRequest = {}, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersListSuppliersGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.counterAgentKind, requestParameters.supplierCategoryId, requestParameters.supplierStatus, requestParameters.supplierManagerId, requestParameters.label, requestParameters.currencyId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send current supplier user phone to email after phone change.  Role check: is_staff. Permission: warehouse_change_suppliers
     * @summary Send current supplier user phone to email after phone change.
     * @param {SuppliersApiUsersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost(requestParameters: SuppliersApiUsersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPostRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersSendPhoneEmailSuppliersSupplierIdSendPhoneEmailPost(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier user statistics.  Role check: is_staff.  Permission: warehouse_view_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Get supplier user statistics.
     * @param {SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet(requestParameters: SuppliersApiUsersSuppliersStatisticsSuppliersSupplierIdStatisticsGetRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersStatisticsSuppliersSupplierIdStatisticsGet(requestParameters.supplierId, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Turn to supplier user.  Role check: is_staff.  Permission: warehouse_view_suppliers, warehouse_change_suppliers, warehouse_change_other_manager_supplier_access
     * @summary Add supplier role to user.
     * @param {SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut(requestParameters: SuppliersApiUsersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersTurnToSupplierSuppliersUserIdTurnSupplierPut(requestParameters.userId, requestParameters.supplierTurnSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change supplier user avatar.  Role check: is_staff.  Permission: warehouse_change_suppliers  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.
     * @summary Change supplier user avatar.
     * @param {SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut(requestParameters: SuppliersApiUsersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersUpdateAvatarSuppliersSupplierIdAvatarPut(requestParameters.supplierId, requestParameters.avatar, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update supplier user.  Role check: is_staff.  Permission: warehouse_change_suppliers  Requires \'warehouse_change_price_type\' permission to change a price type.  Permission \'warehouse_change_other_manager_supplier_access\' needed for any change action on another manager user. Permission \'warehouse_view_other_manager_supplier_access\' needed for any view action on another manager user. If a user is superuser, one has all permissions.  Email/Phone will be changed only if supplier status in [IN_PROCESSING, UNCONFIRMED]
     * @summary Update supplier user.
     * @param {SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuppliersApi
     */
    public usersSuppliersUpdateSuppliersSupplierIdPut(requestParameters: SuppliersApiUsersSuppliersUpdateSuppliersSupplierIdPutRequest, options?: AxiosRequestConfig) {
        return SuppliersApiFp(this.configuration).usersSuppliersUpdateSuppliersSupplierIdPut(requestParameters.supplierId, requestParameters.supplierUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSupplierPricesApi - axios parameter creator
 * @export
 */
export const UserSupplierPricesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List of price nomenclatures.
         * @summary Get list of price nomenclatures.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search for customs_code, vendor_code
         * @param {number} [countryId] Country id.
         * @param {string} [supplierId] Supplier id.
         * @param {number} [nomenclatureId] Nomenclature id.
         * @param {CommonNomenclatureUnits} [unit] Unit.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {PriceNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, countryId?: number, supplierId?: string, nomenclatureId?: number, unit?: CommonNomenclatureUnits, sort?: BaseSort, order?: PriceNomenclatureQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/supplier-prices/nomenclature-prices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            if (nomenclatureId !== undefined) {
                localVarQueryParameter['nomenclatureId'] = nomenclatureId;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get latest price list of supplier.
         * @summary Get latest price list of supplier.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet', 'supplierId', supplierId)
            const localVarPath = `/supplier-prices/price-list/{supplier_id}/latest/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create price list task of supplier.
         * @summary Create price list task of supplier.
         * @param {string} supplierId 
         * @param {File} file 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost: async (supplierId: string, file: File, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost', 'supplierId', supplierId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost', 'file', file)
            const localVarPath = `/supplier-prices/price-list-task/{supplier_id}/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (logsLimit !== undefined) {
                localVarQueryParameter['logsLimit'] = logsLimit;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete price list task of supplier.
         * @summary Delete price list task of supplier.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete: async (supplierId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete', 'supplierId', supplierId)
            const localVarPath = `/supplier-prices/price-list-task/{supplier_id}/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get price list task of supplier.
         * @summary Get price list task of supplier.
         * @param {string} supplierId 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet: async (supplierId: string, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet', 'supplierId', supplierId)
            const localVarPath = `/supplier-prices/price-list-task/{supplier_id}/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (logsLimit !== undefined) {
                localVarQueryParameter['logsLimit'] = logsLimit;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save price list task results to supplier prices.
         * @summary Save price list task results to supplier prices.
         * @param {string} supplierId 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost: async (supplierId: string, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost', 'supplierId', supplierId)
            const localVarPath = `/supplier-prices/price-list-task/{supplier_id}/save/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (logsLimit !== undefined) {
                localVarQueryParameter['logsLimit'] = logsLimit;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start price list task of supplier.
         * @summary Start price list task of supplier.
         * @param {string} supplierId 
         * @param {StartPriceListTaskSchema} startPriceListTaskSchema 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut: async (supplierId: string, startPriceListTaskSchema: StartPriceListTaskSchema, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplierId' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut', 'supplierId', supplierId)
            // verify required parameter 'startPriceListTaskSchema' is not null or undefined
            assertParamExists('supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut', 'startPriceListTaskSchema', startPriceListTaskSchema)
            const localVarPath = `/supplier-prices/price-list-task/{supplier_id}/start/`
                .replace(`{${"supplier_id"}}`, encodeURIComponent(String(supplierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (logsLimit !== undefined) {
                localVarQueryParameter['logsLimit'] = logsLimit;
            }

            if (reversed !== undefined) {
                localVarQueryParameter['reversed'] = reversed;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startPriceListTaskSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSupplierPricesApi - functional programming interface
 * @export
 */
export const UserSupplierPricesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSupplierPricesApiAxiosParamCreator(configuration)
    return {
        /**
         * List of price nomenclatures.
         * @summary Get list of price nomenclatures.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search for customs_code, vendor_code
         * @param {number} [countryId] Country id.
         * @param {string} [supplierId] Supplier id.
         * @param {number} [nomenclatureId] Nomenclature id.
         * @param {CommonNomenclatureUnits} [unit] Unit.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {PriceNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, countryId?: number, supplierId?: string, nomenclatureId?: number, unit?: CommonNomenclatureUnits, sort?: BaseSort, order?: PriceNomenclatureQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NomenclaturePricePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet(dateCreatedFrom, dateCreatedTo, searchFilter, countryId, supplierId, nomenclatureId, unit, sort, order, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get latest price list of supplier.
         * @summary Get latest price list of supplier.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceListSchemaWithCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create price list task of supplier.
         * @summary Create price list task of supplier.
         * @param {string} supplierId 
         * @param {File} file 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost(supplierId: string, file: File, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceListTaskSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost(supplierId, file, sort, logsLimit, reversed, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete price list task of supplier.
         * @summary Delete price list task of supplier.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete(supplierId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete(supplierId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get price list task of supplier.
         * @summary Get price list task of supplier.
         * @param {string} supplierId 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet(supplierId: string, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceListTaskSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet(supplierId, sort, logsLimit, reversed, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Save price list task results to supplier prices.
         * @summary Save price list task results to supplier prices.
         * @param {string} supplierId 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost(supplierId: string, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceListTaskSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost(supplierId, sort, logsLimit, reversed, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start price list task of supplier.
         * @summary Start price list task of supplier.
         * @param {string} supplierId 
         * @param {StartPriceListTaskSchema} startPriceListTaskSchema 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut(supplierId: string, startPriceListTaskSchema: StartPriceListTaskSchema, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceListTaskSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut(supplierId, startPriceListTaskSchema, sort, logsLimit, reversed, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSupplierPricesApi - factory interface
 * @export
 */
export const UserSupplierPricesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSupplierPricesApiFp(configuration)
    return {
        /**
         * List of price nomenclatures.
         * @summary Get list of price nomenclatures.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search for customs_code, vendor_code
         * @param {number} [countryId] Country id.
         * @param {string} [supplierId] Supplier id.
         * @param {number} [nomenclatureId] Nomenclature id.
         * @param {CommonNomenclatureUnits} [unit] Unit.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {PriceNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, countryId?: number, supplierId?: string, nomenclatureId?: number, unit?: CommonNomenclatureUnits, sort?: BaseSort, order?: PriceNomenclatureQueryOrder, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<NomenclaturePricePage> {
            return localVarFp.supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet(dateCreatedFrom, dateCreatedTo, searchFilter, countryId, supplierId, nomenclatureId, unit, sort, order, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get latest price list of supplier.
         * @summary Get latest price list of supplier.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<PriceListSchemaWithCount> {
            return localVarFp.supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create price list task of supplier.
         * @summary Create price list task of supplier.
         * @param {string} supplierId 
         * @param {File} file 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost(supplierId: string, file: File, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: any): AxiosPromise<PriceListTaskSchema> {
            return localVarFp.supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost(supplierId, file, sort, logsLimit, reversed, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete price list task of supplier.
         * @summary Delete price list task of supplier.
         * @param {string} supplierId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete(supplierId: string, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete(supplierId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get price list task of supplier.
         * @summary Get price list task of supplier.
         * @param {string} supplierId 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet(supplierId: string, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: any): AxiosPromise<PriceListTaskSchema> {
            return localVarFp.supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet(supplierId, sort, logsLimit, reversed, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Save price list task results to supplier prices.
         * @summary Save price list task results to supplier prices.
         * @param {string} supplierId 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost(supplierId: string, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: any): AxiosPromise<PriceListTaskSchema> {
            return localVarFp.supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost(supplierId, sort, logsLimit, reversed, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Start price list task of supplier.
         * @summary Start price list task of supplier.
         * @param {string} supplierId 
         * @param {StartPriceListTaskSchema} startPriceListTaskSchema 
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {number} [logsLimit] Limit of logs to return
         * @param {boolean} [reversed] Reversed order of logs
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut(supplierId: string, startPriceListTaskSchema: StartPriceListTaskSchema, sort?: BaseSort, logsLimit?: number, reversed?: boolean, acceptLanguage?: string, options?: any): AxiosPromise<PriceListTaskSchema> {
            return localVarFp.supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut(supplierId, startPriceListTaskSchema, sort, logsLimit, reversed, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGetRequest
 */
export interface UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search for customs_code, vendor_code
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly searchFilter?: string

    /**
     * Country id.
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly countryId?: number

    /**
     * Supplier id.
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly supplierId?: string

    /**
     * Nomenclature id.
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly nomenclatureId?: number

    /**
     * Unit.
     * @type {CommonNomenclatureUnits}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly unit?: CommonNomenclatureUnits

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {PriceNomenclatureQueryOrder}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly order?: PriceNomenclatureQueryOrder

    /**
     * 
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGetRequest
 */
export interface UserSupplierPricesApiSupplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPostRequest
 */
export interface UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost
     */
    readonly supplierId: string

    /**
     * 
     * @type {File}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost
     */
    readonly file: File

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost
     */
    readonly sort?: BaseSort

    /**
     * Limit of logs to return
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost
     */
    readonly logsLimit?: number

    /**
     * Reversed order of logs
     * @type {boolean}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost
     */
    readonly reversed?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDeleteRequest
 */
export interface UserSupplierPricesApiSupplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete
     */
    readonly supplierId: string

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGetRequest
 */
export interface UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet
     */
    readonly supplierId: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet
     */
    readonly sort?: BaseSort

    /**
     * Limit of logs to return
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet
     */
    readonly logsLimit?: number

    /**
     * Reversed order of logs
     * @type {boolean}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet
     */
    readonly reversed?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePostRequest
 */
export interface UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePostRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost
     */
    readonly supplierId: string

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost
     */
    readonly sort?: BaseSort

    /**
     * Limit of logs to return
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost
     */
    readonly logsLimit?: number

    /**
     * Reversed order of logs
     * @type {boolean}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost
     */
    readonly reversed?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut operation in UserSupplierPricesApi.
 * @export
 * @interface UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPutRequest
 */
export interface UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPutRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut
     */
    readonly supplierId: string

    /**
     * 
     * @type {StartPriceListTaskSchema}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut
     */
    readonly startPriceListTaskSchema: StartPriceListTaskSchema

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut
     */
    readonly sort?: BaseSort

    /**
     * Limit of logs to return
     * @type {number}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut
     */
    readonly logsLimit?: number

    /**
     * Reversed order of logs
     * @type {boolean}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut
     */
    readonly reversed?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut
     */
    readonly acceptLanguage?: string
}

/**
 * UserSupplierPricesApi - object-oriented interface
 * @export
 * @class UserSupplierPricesApi
 * @extends {BaseAPI}
 */
export class UserSupplierPricesApi extends BaseAPI {
    /**
     * List of price nomenclatures.
     * @summary Get list of price nomenclatures.
     * @param {UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet(requestParameters: UserSupplierPricesApiSupplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGetRequest = {}, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesNomenclaturePriceListSupplierPricesNomenclaturePricesGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.countryId, requestParameters.supplierId, requestParameters.nomenclatureId, requestParameters.unit, requestParameters.sort, requestParameters.order, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get latest price list of supplier.
     * @summary Get latest price list of supplier.
     * @param {UserSupplierPricesApiSupplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet(requestParameters: UserSupplierPricesApiSupplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGetRequest, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesPriceListGetLatestSupplierPricesPriceListSupplierIdLatestGet(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create price list task of supplier.
     * @summary Create price list task of supplier.
     * @param {UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost(requestParameters: UserSupplierPricesApiSupplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPostRequest, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesPriceListTaskCreateSupplierPricesPriceListTaskSupplierIdPost(requestParameters.supplierId, requestParameters.file, requestParameters.sort, requestParameters.logsLimit, requestParameters.reversed, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete price list task of supplier.
     * @summary Delete price list task of supplier.
     * @param {UserSupplierPricesApiSupplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete(requestParameters: UserSupplierPricesApiSupplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDeleteRequest, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesPriceListTaskDeleteSupplierPricesPriceListTaskSupplierIdDelete(requestParameters.supplierId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get price list task of supplier.
     * @summary Get price list task of supplier.
     * @param {UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet(requestParameters: UserSupplierPricesApiSupplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGetRequest, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesPriceListTaskGetSupplierPricesPriceListTaskSupplierIdGet(requestParameters.supplierId, requestParameters.sort, requestParameters.logsLimit, requestParameters.reversed, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save price list task results to supplier prices.
     * @summary Save price list task results to supplier prices.
     * @param {UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost(requestParameters: UserSupplierPricesApiSupplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePostRequest, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesPriceListTaskSaveSupplierPricesPriceListTaskSupplierIdSavePost(requestParameters.supplierId, requestParameters.sort, requestParameters.logsLimit, requestParameters.reversed, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start price list task of supplier.
     * @summary Start price list task of supplier.
     * @param {UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSupplierPricesApi
     */
    public supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut(requestParameters: UserSupplierPricesApiSupplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPutRequest, options?: AxiosRequestConfig) {
        return UserSupplierPricesApiFp(this.configuration).supplierPricesPriceListTaskStartSupplierPricesPriceListTaskSupplierIdStartPut(requestParameters.supplierId, requestParameters.startPriceListTaskSchema, requestParameters.sort, requestParameters.logsLimit, requestParameters.reversed, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user\'s list.  Role check: is_staff.
         * @summary List of all users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {UserQueryOrder} [order] Order.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {Array<UserTypes>} [roles] Roles
         * @param {NoteTypes} [noteType] Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {string} [noteObjectId] Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAllListSelectUsersSelectGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: UserQueryOrder, sort?: BaseSort, excludeInactive?: boolean, roles?: Array<UserTypes>, noteType?: NoteTypes, noteObjectId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/select/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (noteType !== undefined) {
                localVarQueryParameter['noteType'] = noteType;
            }

            if (noteObjectId !== undefined) {
                localVarQueryParameter['noteObjectId'] = noteObjectId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s list.  Role check: is_staff.
         * @summary List of all users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {UserQueryOrder} [order] Order.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {Array<UserTypes>} [roles] Roles
         * @param {NoteTypes} [noteType] Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {string} [noteObjectId] Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAllListUsersGet: async (dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: UserQueryOrder, sort?: BaseSort, excludeInactive?: boolean, roles?: Array<UserTypes>, noteType?: NoteTypes, noteObjectId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateCreatedFrom !== undefined) {
                localVarQueryParameter['dateCreatedFrom'] = (dateCreatedFrom as any instanceof Date) ?
                    (dateCreatedFrom as any).toISOString().substr(0,10) :
                    dateCreatedFrom;
            }

            if (dateCreatedTo !== undefined) {
                localVarQueryParameter['dateCreatedTo'] = (dateCreatedTo as any instanceof Date) ?
                    (dateCreatedTo as any).toISOString().substr(0,10) :
                    dateCreatedTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (searchFilterSelect !== undefined) {
                localVarQueryParameter['searchFilterSelect'] = searchFilterSelect;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (excludeInactive !== undefined) {
                localVarQueryParameter['excludeInactive'] = excludeInactive;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (noteType !== undefined) {
                localVarQueryParameter['noteType'] = noteType;
            }

            if (noteObjectId !== undefined) {
                localVarQueryParameter['noteObjectId'] = noteObjectId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if non-staff user with similar name exists.  Role check: is_staff.
         * @summary Check if non-staff user with similar name exists
         * @param {string} name 
         * @param {string} [excludeId] Exclude user id
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSimilarNameUsersSimilarNamePost: async (name: string, excludeId?: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('usersSimilarNameUsersSimilarNamePost', 'name', name)
            const localVarPath = `/users/similar-name/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (excludeId !== undefined) {
                localVarQueryParameter['exclude_id'] = excludeId;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user currency by id.  Role check: is_staff.
         * @summary Get user currency
         * @param {string} userId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet: async (userId: string, currencyId: number, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet', 'userId', userId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet', 'currencyId', currencyId)
            const localVarPath = `/users/user-currencies/{user_id}/{currency_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of user currencies.  Role check: is_staff.
         * @summary Get list of user currencies
         * @param {string} userId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet: async (userId: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet', 'userId', userId)
            const localVarPath = `/users/user-currencies/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vat number policy (vat rate and if vat field required).  Role check: is_staff.  Permission: staff_view.
         * @summary Get vat number policy (vat rate and if vat field required)
         * @param {number} countryId Country id
         * @param {CounterAgentKinds} counterAgentKind Counter agent kind
         * @param {boolean} isVatPayer Is vat payer
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUtilsVatPolicyUsersVatPolicyGet: async (countryId: number, counterAgentKind: CounterAgentKinds, isVatPayer: boolean, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('usersUtilsVatPolicyUsersVatPolicyGet', 'countryId', countryId)
            // verify required parameter 'counterAgentKind' is not null or undefined
            assertParamExists('usersUtilsVatPolicyUsersVatPolicyGet', 'counterAgentKind', counterAgentKind)
            // verify required parameter 'isVatPayer' is not null or undefined
            assertParamExists('usersUtilsVatPolicyUsersVatPolicyGet', 'isVatPayer', isVatPayer)
            const localVarPath = `/users/vat-policy/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (countryId !== undefined) {
                localVarQueryParameter['country_id'] = countryId;
            }

            if (counterAgentKind !== undefined) {
                localVarQueryParameter['counter_agent_kind'] = counterAgentKind;
            }

            if (isVatPayer !== undefined) {
                localVarQueryParameter['is_vat_payer'] = isVatPayer;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Audit user vat number.  Role check: is_staff.
         * @summary Audit user vat number
         * @param {string} userId 
         * @param {CabinetUserKinds} kind Counter agent kind
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersVatAuditUsersVatAuditUserIdPost: async (userId: string, kind: CabinetUserKinds, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersVatAuditUsersVatAuditUserIdPost', 'userId', userId)
            // verify required parameter 'kind' is not null or undefined
            assertParamExists('usersVatAuditUsersVatAuditUserIdPost', 'kind', kind)
            const localVarPath = `/users/vat-audit/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user\'s list.  Role check: is_staff.
         * @summary List of all users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {UserQueryOrder} [order] Order.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {Array<UserTypes>} [roles] Roles
         * @param {NoteTypes} [noteType] Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {string} [noteObjectId] Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAllListSelectUsersSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: UserQueryOrder, sort?: BaseSort, excludeInactive?: boolean, roles?: Array<UserTypes>, noteType?: NoteTypes, noteObjectId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAllListSelectUsersSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, roles, noteType, noteObjectId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s list.  Role check: is_staff.
         * @summary List of all users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {UserQueryOrder} [order] Order.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {Array<UserTypes>} [roles] Roles
         * @param {NoteTypes} [noteType] Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {string} [noteObjectId] Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAllListUsersGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: UserQueryOrder, sort?: BaseSort, excludeInactive?: boolean, roles?: Array<UserTypes>, noteType?: NoteTypes, noteObjectId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAllListUsersGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, roles, noteType, noteObjectId, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if non-staff user with similar name exists.  Role check: is_staff.
         * @summary Check if non-staff user with similar name exists
         * @param {string} name 
         * @param {string} [excludeId] Exclude user id
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSimilarNameUsersSimilarNamePost(name: string, excludeId?: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimilarNameSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSimilarNameUsersSimilarNamePost(name, excludeId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user currency by id.  Role check: is_staff.
         * @summary Get user currency
         * @param {string} userId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet(userId: string, currencyId: number, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComplexUserCurrencyReadSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet(userId, currencyId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of user currencies.  Role check: is_staff.
         * @summary Get list of user currencies
         * @param {string} userId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet(userId: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComplexUserCurrencyReadSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet(userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get vat number policy (vat rate and if vat field required).  Role check: is_staff.  Permission: staff_view.
         * @summary Get vat number policy (vat rate and if vat field required)
         * @param {number} countryId Country id
         * @param {CounterAgentKinds} counterAgentKind Counter agent kind
         * @param {boolean} isVatPayer Is vat payer
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUtilsVatPolicyUsersVatPolicyGet(countryId: number, counterAgentKind: CounterAgentKinds, isVatPayer: boolean, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatNumberPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUtilsVatPolicyUsersVatPolicyGet(countryId, counterAgentKind, isVatPayer, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Audit user vat number.  Role check: is_staff.
         * @summary Audit user vat number
         * @param {string} userId 
         * @param {CabinetUserKinds} kind Counter agent kind
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersVatAuditUsersVatAuditUserIdPost(userId: string, kind: CabinetUserKinds, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatValidatorSuccessResultSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersVatAuditUsersVatAuditUserIdPost(userId, kind, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get user\'s list.  Role check: is_staff.
         * @summary List of all users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {UserQueryOrder} [order] Order.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {Array<UserTypes>} [roles] Roles
         * @param {NoteTypes} [noteType] Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {string} [noteObjectId] Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAllListSelectUsersSelectGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: UserQueryOrder, sort?: BaseSort, excludeInactive?: boolean, roles?: Array<UserTypes>, noteType?: NoteTypes, noteObjectId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserPageSchema> {
            return localVarFp.usersAllListSelectUsersSelectGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, roles, noteType, noteObjectId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s list.  Role check: is_staff.
         * @summary List of all users.
         * @param {string} [dateCreatedFrom] Date from.
         * @param {string} [dateCreatedTo] Date to.
         * @param {string} [searchFilter] Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
         * @param {string} [searchFilterSelect] Search filter by name
         * @param {number} [countryId] Country id.
         * @param {UserQueryOrder} [order] Order.
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {boolean} [excludeInactive] Exclude inactive users
         * @param {Array<UserTypes>} [roles] Roles
         * @param {NoteTypes} [noteType] Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {string} [noteObjectId] Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAllListUsersGet(dateCreatedFrom?: string, dateCreatedTo?: string, searchFilter?: string, searchFilterSelect?: string, countryId?: number, order?: UserQueryOrder, sort?: BaseSort, excludeInactive?: boolean, roles?: Array<UserTypes>, noteType?: NoteTypes, noteObjectId?: string, page?: number, pageSize?: number, acceptLanguage?: string, options?: any): AxiosPromise<UserPageSchema> {
            return localVarFp.usersAllListUsersGet(dateCreatedFrom, dateCreatedTo, searchFilter, searchFilterSelect, countryId, order, sort, excludeInactive, roles, noteType, noteObjectId, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if non-staff user with similar name exists.  Role check: is_staff.
         * @summary Check if non-staff user with similar name exists
         * @param {string} name 
         * @param {string} [excludeId] Exclude user id
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSimilarNameUsersSimilarNamePost(name: string, excludeId?: string, acceptLanguage?: string, options?: any): AxiosPromise<SimilarNameSchema> {
            return localVarFp.usersSimilarNameUsersSimilarNamePost(name, excludeId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user currency by id.  Role check: is_staff.
         * @summary Get user currency
         * @param {string} userId 
         * @param {number} currencyId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet(userId: string, currencyId: number, acceptLanguage?: string, options?: any): AxiosPromise<ComplexUserCurrencyReadSchema> {
            return localVarFp.usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet(userId, currencyId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of user currencies.  Role check: is_staff.
         * @summary Get list of user currencies
         * @param {string} userId 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet(userId: string, acceptLanguage?: string, options?: any): AxiosPromise<Array<ComplexUserCurrencyReadSchema>> {
            return localVarFp.usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet(userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vat number policy (vat rate and if vat field required).  Role check: is_staff.  Permission: staff_view.
         * @summary Get vat number policy (vat rate and if vat field required)
         * @param {number} countryId Country id
         * @param {CounterAgentKinds} counterAgentKind Counter agent kind
         * @param {boolean} isVatPayer Is vat payer
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUtilsVatPolicyUsersVatPolicyGet(countryId: number, counterAgentKind: CounterAgentKinds, isVatPayer: boolean, acceptLanguage?: string, options?: any): AxiosPromise<VatNumberPolicy> {
            return localVarFp.usersUtilsVatPolicyUsersVatPolicyGet(countryId, counterAgentKind, isVatPayer, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Audit user vat number.  Role check: is_staff.
         * @summary Audit user vat number
         * @param {string} userId 
         * @param {CabinetUserKinds} kind Counter agent kind
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersVatAuditUsersVatAuditUserIdPost(userId: string, kind: CabinetUserKinds, acceptLanguage?: string, options?: any): AxiosPromise<VatValidatorSuccessResultSchema> {
            return localVarFp.usersVatAuditUsersVatAuditUserIdPost(userId, kind, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersAllListSelectUsersSelectGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersAllListSelectUsersSelectGetRequest
 */
export interface UsersApiUsersAllListSelectUsersSelectGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly countryId?: number

    /**
     * Order.
     * @type {UserQueryOrder}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly order?: UserQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly excludeInactive?: boolean

    /**
     * Roles
     * @type {Array<UserTypes>}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly roles?: Array<UserTypes>

    /**
     * Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
     * @type {NoteTypes}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly noteType?: NoteTypes

    /**
     * Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
     * @type {string}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly noteObjectId?: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersAllListSelectUsersSelectGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersAllListUsersGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersAllListUsersGetRequest
 */
export interface UsersApiUsersAllListUsersGetRequest {
    /**
     * Date from.
     * @type {string}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly dateCreatedFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly dateCreatedTo?: string

    /**
     * Search filter. Staff fields: name, email, phone, city. Supplier fields: name, email, contact name, vat_number, registration_number, city, region. Client fields: name, email, contact name, vat_number, registration_number, city, region. 
     * @type {string}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly searchFilter?: string

    /**
     * Search filter by name
     * @type {string}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly searchFilterSelect?: string

    /**
     * Country id.
     * @type {number}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly countryId?: number

    /**
     * Order.
     * @type {UserQueryOrder}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly order?: UserQueryOrder

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly sort?: BaseSort

    /**
     * Exclude inactive users
     * @type {boolean}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly excludeInactive?: boolean

    /**
     * Roles
     * @type {Array<UserTypes>}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly roles?: Array<UserTypes>

    /**
     * Note type. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
     * @type {NoteTypes}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly noteType?: NoteTypes

    /**
     * Note object id. Used to get users created a \&#39;note_type\&#39; note for \&#39;note_object_id\&#39; user
     * @type {string}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly noteObjectId?: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly pageSize?: number

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersAllListUsersGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersSimilarNameUsersSimilarNamePost operation in UsersApi.
 * @export
 * @interface UsersApiUsersSimilarNameUsersSimilarNamePostRequest
 */
export interface UsersApiUsersSimilarNameUsersSimilarNamePostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersSimilarNameUsersSimilarNamePost
     */
    readonly name: string

    /**
     * Exclude user id
     * @type {string}
     * @memberof UsersApiUsersSimilarNameUsersSimilarNamePost
     */
    readonly excludeId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersSimilarNameUsersSimilarNamePost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGetRequest
 */
export interface UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet
     */
    readonly currencyId: number

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersUtilsUserCurrenciesUsersUserCurrenciesUserIdGetRequest
 */
export interface UsersApiUsersUtilsUserCurrenciesUsersUserCurrenciesUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersUtilsVatPolicyUsersVatPolicyGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersUtilsVatPolicyUsersVatPolicyGetRequest
 */
export interface UsersApiUsersUtilsVatPolicyUsersVatPolicyGetRequest {
    /**
     * Country id
     * @type {number}
     * @memberof UsersApiUsersUtilsVatPolicyUsersVatPolicyGet
     */
    readonly countryId: number

    /**
     * Counter agent kind
     * @type {CounterAgentKinds}
     * @memberof UsersApiUsersUtilsVatPolicyUsersVatPolicyGet
     */
    readonly counterAgentKind: CounterAgentKinds

    /**
     * Is vat payer
     * @type {boolean}
     * @memberof UsersApiUsersUtilsVatPolicyUsersVatPolicyGet
     */
    readonly isVatPayer: boolean

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUtilsVatPolicyUsersVatPolicyGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for usersVatAuditUsersVatAuditUserIdPost operation in UsersApi.
 * @export
 * @interface UsersApiUsersVatAuditUsersVatAuditUserIdPostRequest
 */
export interface UsersApiUsersVatAuditUsersVatAuditUserIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersVatAuditUsersVatAuditUserIdPost
     */
    readonly userId: string

    /**
     * Counter agent kind
     * @type {CabinetUserKinds}
     * @memberof UsersApiUsersVatAuditUsersVatAuditUserIdPost
     */
    readonly kind: CabinetUserKinds

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersVatAuditUsersVatAuditUserIdPost
     */
    readonly acceptLanguage?: string
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get user\'s list.  Role check: is_staff.
     * @summary List of all users.
     * @param {UsersApiUsersAllListSelectUsersSelectGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersAllListSelectUsersSelectGet(requestParameters: UsersApiUsersAllListSelectUsersSelectGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersAllListSelectUsersSelectGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.roles, requestParameters.noteType, requestParameters.noteObjectId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s list.  Role check: is_staff.
     * @summary List of all users.
     * @param {UsersApiUsersAllListUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersAllListUsersGet(requestParameters: UsersApiUsersAllListUsersGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersAllListUsersGet(requestParameters.dateCreatedFrom, requestParameters.dateCreatedTo, requestParameters.searchFilter, requestParameters.searchFilterSelect, requestParameters.countryId, requestParameters.order, requestParameters.sort, requestParameters.excludeInactive, requestParameters.roles, requestParameters.noteType, requestParameters.noteObjectId, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if non-staff user with similar name exists.  Role check: is_staff.
     * @summary Check if non-staff user with similar name exists
     * @param {UsersApiUsersSimilarNameUsersSimilarNamePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersSimilarNameUsersSimilarNamePost(requestParameters: UsersApiUsersSimilarNameUsersSimilarNamePostRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersSimilarNameUsersSimilarNamePost(requestParameters.name, requestParameters.excludeId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user currency by id.  Role check: is_staff.
     * @summary Get user currency
     * @param {UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet(requestParameters: UsersApiUsersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUtilsUserCurrenciesCurrencyUsersUserCurrenciesUserIdCurrencyIdGet(requestParameters.userId, requestParameters.currencyId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of user currencies.  Role check: is_staff.
     * @summary Get list of user currencies
     * @param {UsersApiUsersUtilsUserCurrenciesUsersUserCurrenciesUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet(requestParameters: UsersApiUsersUtilsUserCurrenciesUsersUserCurrenciesUserIdGetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUtilsUserCurrenciesUsersUserCurrenciesUserIdGet(requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vat number policy (vat rate and if vat field required).  Role check: is_staff.  Permission: staff_view.
     * @summary Get vat number policy (vat rate and if vat field required)
     * @param {UsersApiUsersUtilsVatPolicyUsersVatPolicyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUtilsVatPolicyUsersVatPolicyGet(requestParameters: UsersApiUsersUtilsVatPolicyUsersVatPolicyGetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUtilsVatPolicyUsersVatPolicyGet(requestParameters.countryId, requestParameters.counterAgentKind, requestParameters.isVatPayer, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Audit user vat number.  Role check: is_staff.
     * @summary Audit user vat number
     * @param {UsersApiUsersVatAuditUsersVatAuditUserIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersVatAuditUsersVatAuditUserIdPost(requestParameters: UsersApiUsersVatAuditUsersVatAuditUserIdPostRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersVatAuditUsersVatAuditUserIdPost(requestParameters.userId, requestParameters.kind, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidatorsApi - axios parameter creator
 * @export
 */
export const ValidatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validate IBAN.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
         * @summary Validate IBAN
         * @param {string} iban 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsIbanValidatorsIbanPost: async (iban: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iban' is not null or undefined
            assertParamExists('validatorsIbanValidatorsIbanPost', 'iban', iban)
            const localVarPath = `/validators/iban/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iban !== undefined) {
                localVarQueryParameter['iban'] = iban;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate SWIFT.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
         * @summary Validate SWIFT (BIC code)
         * @param {string} swift 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsSwiftValidatorsSwiftPost: async (swift: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'swift' is not null or undefined
            assertParamExists('validatorsSwiftValidatorsSwiftPost', 'swift', swift)
            const localVarPath = `/validators/swift/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (swift !== undefined) {
                localVarQueryParameter['swift'] = swift;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate If client/supplier/agent/staff with same name exists.  Use this endpoint before save client/supplier/agent to show some warning.  Can use exclude_id to exclude user with same id (usually current user that you edit).  Only is_staff users can use this endpoint.
         * @summary Validate if user with same name exists.
         * @param {BodyValidatorsVatValidatorsUniqueNamePost} bodyValidatorsVatValidatorsUniqueNamePost 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsVatValidatorsUniqueNamePost: async (bodyValidatorsVatValidatorsUniqueNamePost: BodyValidatorsVatValidatorsUniqueNamePost, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyValidatorsVatValidatorsUniqueNamePost' is not null or undefined
            assertParamExists('validatorsVatValidatorsUniqueNamePost', 'bodyValidatorsVatValidatorsUniqueNamePost', bodyValidatorsVatValidatorsUniqueNamePost)
            const localVarPath = `/validators/unique-name/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyValidatorsVatValidatorsUniqueNamePost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate VAT number.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.  samples: IE6388047V
         * @summary Validate VAT number
         * @param {string} vatNumber 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsVatValidatorsVatPost: async (vatNumber: string, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vatNumber' is not null or undefined
            assertParamExists('validatorsVatValidatorsVatPost', 'vatNumber', vatNumber)
            const localVarPath = `/validators/vat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vatNumber !== undefined) {
                localVarQueryParameter['vat_number'] = vatNumber;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorsApi - functional programming interface
 * @export
 */
export const ValidatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Validate IBAN.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
         * @summary Validate IBAN
         * @param {string} iban 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsIbanValidatorsIbanPost(iban: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsIbanValidatorsIbanPost(iban, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate SWIFT.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
         * @summary Validate SWIFT (BIC code)
         * @param {string} swift 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsSwiftValidatorsSwiftPost(swift: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsSwiftValidatorsSwiftPost(swift, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate If client/supplier/agent/staff with same name exists.  Use this endpoint before save client/supplier/agent to show some warning.  Can use exclude_id to exclude user with same id (usually current user that you edit).  Only is_staff users can use this endpoint.
         * @summary Validate if user with same name exists.
         * @param {BodyValidatorsVatValidatorsUniqueNamePost} bodyValidatorsVatValidatorsUniqueNamePost 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsVatValidatorsUniqueNamePost(bodyValidatorsVatValidatorsUniqueNamePost: BodyValidatorsVatValidatorsUniqueNamePost, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UniqueUserNameSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsVatValidatorsUniqueNamePost(bodyValidatorsVatValidatorsUniqueNamePost, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate VAT number.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.  samples: IE6388047V
         * @summary Validate VAT number
         * @param {string} vatNumber 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsVatValidatorsVatPost(vatNumber: string, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatValidatorSuccessResultSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsVatValidatorsVatPost(vatNumber, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidatorsApi - factory interface
 * @export
 */
export const ValidatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidatorsApiFp(configuration)
    return {
        /**
         * Validate IBAN.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
         * @summary Validate IBAN
         * @param {string} iban 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsIbanValidatorsIbanPost(iban: string, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.validatorsIbanValidatorsIbanPost(iban, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate SWIFT.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
         * @summary Validate SWIFT (BIC code)
         * @param {string} swift 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsSwiftValidatorsSwiftPost(swift: string, acceptLanguage?: string, options?: any): AxiosPromise<any> {
            return localVarFp.validatorsSwiftValidatorsSwiftPost(swift, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate If client/supplier/agent/staff with same name exists.  Use this endpoint before save client/supplier/agent to show some warning.  Can use exclude_id to exclude user with same id (usually current user that you edit).  Only is_staff users can use this endpoint.
         * @summary Validate if user with same name exists.
         * @param {BodyValidatorsVatValidatorsUniqueNamePost} bodyValidatorsVatValidatorsUniqueNamePost 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsVatValidatorsUniqueNamePost(bodyValidatorsVatValidatorsUniqueNamePost: BodyValidatorsVatValidatorsUniqueNamePost, acceptLanguage?: string, options?: any): AxiosPromise<UniqueUserNameSchema> {
            return localVarFp.validatorsVatValidatorsUniqueNamePost(bodyValidatorsVatValidatorsUniqueNamePost, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate VAT number.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.  samples: IE6388047V
         * @summary Validate VAT number
         * @param {string} vatNumber 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsVatValidatorsVatPost(vatNumber: string, acceptLanguage?: string, options?: any): AxiosPromise<VatValidatorSuccessResultSchema> {
            return localVarFp.validatorsVatValidatorsVatPost(vatNumber, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for validatorsIbanValidatorsIbanPost operation in ValidatorsApi.
 * @export
 * @interface ValidatorsApiValidatorsIbanValidatorsIbanPostRequest
 */
export interface ValidatorsApiValidatorsIbanValidatorsIbanPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsIbanValidatorsIbanPost
     */
    readonly iban: string

    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsIbanValidatorsIbanPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for validatorsSwiftValidatorsSwiftPost operation in ValidatorsApi.
 * @export
 * @interface ValidatorsApiValidatorsSwiftValidatorsSwiftPostRequest
 */
export interface ValidatorsApiValidatorsSwiftValidatorsSwiftPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsSwiftValidatorsSwiftPost
     */
    readonly swift: string

    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsSwiftValidatorsSwiftPost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for validatorsVatValidatorsUniqueNamePost operation in ValidatorsApi.
 * @export
 * @interface ValidatorsApiValidatorsVatValidatorsUniqueNamePostRequest
 */
export interface ValidatorsApiValidatorsVatValidatorsUniqueNamePostRequest {
    /**
     * 
     * @type {BodyValidatorsVatValidatorsUniqueNamePost}
     * @memberof ValidatorsApiValidatorsVatValidatorsUniqueNamePost
     */
    readonly bodyValidatorsVatValidatorsUniqueNamePost: BodyValidatorsVatValidatorsUniqueNamePost

    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsVatValidatorsUniqueNamePost
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for validatorsVatValidatorsVatPost operation in ValidatorsApi.
 * @export
 * @interface ValidatorsApiValidatorsVatValidatorsVatPostRequest
 */
export interface ValidatorsApiValidatorsVatValidatorsVatPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsVatValidatorsVatPost
     */
    readonly vatNumber: string

    /**
     * 
     * @type {string}
     * @memberof ValidatorsApiValidatorsVatValidatorsVatPost
     */
    readonly acceptLanguage?: string
}

/**
 * ValidatorsApi - object-oriented interface
 * @export
 * @class ValidatorsApi
 * @extends {BaseAPI}
 */
export class ValidatorsApi extends BaseAPI {
    /**
     * Validate IBAN.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
     * @summary Validate IBAN
     * @param {ValidatorsApiValidatorsIbanValidatorsIbanPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public validatorsIbanValidatorsIbanPost(requestParameters: ValidatorsApiValidatorsIbanValidatorsIbanPostRequest, options?: AxiosRequestConfig) {
        return ValidatorsApiFp(this.configuration).validatorsIbanValidatorsIbanPost(requestParameters.iban, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate SWIFT.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.
     * @summary Validate SWIFT (BIC code)
     * @param {ValidatorsApiValidatorsSwiftValidatorsSwiftPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public validatorsSwiftValidatorsSwiftPost(requestParameters: ValidatorsApiValidatorsSwiftValidatorsSwiftPostRequest, options?: AxiosRequestConfig) {
        return ValidatorsApiFp(this.configuration).validatorsSwiftValidatorsSwiftPost(requestParameters.swift, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate If client/supplier/agent/staff with same name exists.  Use this endpoint before save client/supplier/agent to show some warning.  Can use exclude_id to exclude user with same id (usually current user that you edit).  Only is_staff users can use this endpoint.
     * @summary Validate if user with same name exists.
     * @param {ValidatorsApiValidatorsVatValidatorsUniqueNamePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public validatorsVatValidatorsUniqueNamePost(requestParameters: ValidatorsApiValidatorsVatValidatorsUniqueNamePostRequest, options?: AxiosRequestConfig) {
        return ValidatorsApiFp(this.configuration).validatorsVatValidatorsUniqueNamePost(requestParameters.bodyValidatorsVatValidatorsUniqueNamePost, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate VAT number.  Returns None if validation is successful.  Raises ValidationException if validation is unsuccessful.  samples: IE6388047V
     * @summary Validate VAT number
     * @param {ValidatorsApiValidatorsVatValidatorsVatPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public validatorsVatValidatorsVatPost(requestParameters: ValidatorsApiValidatorsVatValidatorsVatPostRequest, options?: AxiosRequestConfig) {
        return ValidatorsApiFp(this.configuration).validatorsVatValidatorsVatPost(requestParameters.vatNumber, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WarehouseNomenclatureReportsApi - axios parameter creator
 * @export
 */
export const WarehouseNomenclatureReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export warehouse leftovers by brands data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers by brands data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet: async (exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/warehouse-nomenclature/by-brands/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (hideColumns !== undefined) {
                localVarQueryParameter['hideColumns'] = hideColumns;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current warehouse reports by brands
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet: async (page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/warehouse-nomenclature/by-brands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export warehouse leftovers by country\'s data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers by country\'s data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet: async (exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/warehouse-nomenclature/by-countries/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (hideColumns !== undefined) {
                localVarQueryParameter['hideColumns'] = hideColumns;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current warehouse reports by countries
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet: async (page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/warehouse-nomenclature/by-countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export warehouse leftovers data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet: async (exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/warehouse-nomenclature/by-nomenclature/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (hideColumns !== undefined) {
                localVarQueryParameter['hideColumns'] = hideColumns;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current reports.  Role check: is_staff Permission: warehouse_in_settings_view
         * @summary Get current reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet: async (page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/warehouse-nomenclature/by-nomenclature/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substr(0,10) :
                    dateTo;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WarehouseNomenclatureReportsApi - functional programming interface
 * @export
 */
export const WarehouseNomenclatureReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WarehouseNomenclatureReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export warehouse leftovers by brands data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers by brands data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet(exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet(exportType, hideColumns, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current warehouse reports by brands
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet(page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotNomenclatureReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet(page, pageSize, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export warehouse leftovers by country\'s data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers by country\'s data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet(exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet(exportType, hideColumns, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current warehouse reports by countries
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet(page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotNomenclatureReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet(page, pageSize, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export warehouse leftovers data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet(exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet(exportType, hideColumns, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current reports.  Role check: is_staff Permission: warehouse_in_settings_view
         * @summary Get current reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet(page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseNomenclatureReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet(page, pageSize, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WarehouseNomenclatureReportsApi - factory interface
 * @export
 */
export const WarehouseNomenclatureReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WarehouseNomenclatureReportsApiFp(configuration)
    return {
        /**
         * Export warehouse leftovers by brands data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers by brands data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet(exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet(exportType, hideColumns, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current warehouse reports by brands
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet(page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<NotNomenclatureReportPageSchema> {
            return localVarFp.reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet(page, pageSize, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export warehouse leftovers by country\'s data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers by country\'s data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet(exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet(exportType, hideColumns, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current warehouse reports by countries
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet(page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<NotNomenclatureReportPageSchema> {
            return localVarFp.reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet(page, pageSize, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export warehouse leftovers data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers data.
         * @param {DataExportType} exportType 
         * @param {boolean} [hideColumns] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet(exportType: DataExportType, hideColumns?: boolean, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet(exportType, hideColumns, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current reports.  Role check: is_staff Permission: warehouse_in_settings_view
         * @summary Get current reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [dateFrom] Date from.
         * @param {string} [dateTo] Date to.
         * @param {string} [searchFilter] Search by article or name.
         * @param {number} [brandId] Brand id.
         * @param {number} [categoryId] Category id.
         * @param {number} [subcategoryId] Subcategory id.
         * @param {number} [warehouseId] Warehouse id.
         * @param {number} [countryId] Country id.
         * @param {BaseSort} [sort] 
         * @param {LimitedWarehouseNomenclatureQueryOrder} [order] Ordering. Desc id is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet(page?: number, pageSize?: number, dateFrom?: string, dateTo?: string, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, warehouseId?: number, countryId?: number, sort?: BaseSort, order?: LimitedWarehouseNomenclatureQueryOrder, acceptLanguage?: string, options?: any): AxiosPromise<BaseNomenclatureReportPageSchema> {
            return localVarFp.reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet(page, pageSize, dateFrom, dateTo, searchFilter, brandId, categoryId, subcategoryId, warehouseId, countryId, sort, order, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet operation in WarehouseNomenclatureReportsApi.
 * @export
 * @interface WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGetRequest
 */
export interface WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {boolean}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly hideColumns?: boolean

    /**
     * Date from.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly dateTo?: string

    /**
     * Search by article or name.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * Brand id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly brandId?: number

    /**
     * Category id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * Warehouse id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {LimitedWarehouseNomenclatureQueryOrder}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly order?: LimitedWarehouseNomenclatureQueryOrder

    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet operation in WarehouseNomenclatureReportsApi.
 * @export
 * @interface WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGetRequest
 */
export interface WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly dateTo?: string

    /**
     * Search by article or name.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly searchFilter?: string

    /**
     * Brand id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly brandId?: number

    /**
     * Category id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly subcategoryId?: number

    /**
     * Warehouse id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly warehouseId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {LimitedWarehouseNomenclatureQueryOrder}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly order?: LimitedWarehouseNomenclatureQueryOrder

    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet operation in WarehouseNomenclatureReportsApi.
 * @export
 * @interface WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGetRequest
 */
export interface WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {boolean}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly hideColumns?: boolean

    /**
     * Date from.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly dateTo?: string

    /**
     * Search by article or name.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * Brand id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly brandId?: number

    /**
     * Category id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * Warehouse id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {LimitedWarehouseNomenclatureQueryOrder}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly order?: LimitedWarehouseNomenclatureQueryOrder

    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet operation in WarehouseNomenclatureReportsApi.
 * @export
 * @interface WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGetRequest
 */
export interface WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly dateTo?: string

    /**
     * Search by article or name.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly searchFilter?: string

    /**
     * Brand id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly brandId?: number

    /**
     * Category id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly subcategoryId?: number

    /**
     * Warehouse id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly warehouseId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {LimitedWarehouseNomenclatureQueryOrder}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly order?: LimitedWarehouseNomenclatureQueryOrder

    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet operation in WarehouseNomenclatureReportsApi.
 * @export
 * @interface WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGetRequest
 */
export interface WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * 
     * @type {boolean}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly hideColumns?: boolean

    /**
     * Date from.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly dateTo?: string

    /**
     * Search by article or name.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * Brand id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly brandId?: number

    /**
     * Category id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * Warehouse id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {LimitedWarehouseNomenclatureQueryOrder}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly order?: LimitedWarehouseNomenclatureQueryOrder

    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet operation in WarehouseNomenclatureReportsApi.
 * @export
 * @interface WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGetRequest
 */
export interface WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGetRequest {
    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly pageSize?: number

    /**
     * Date from.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly dateFrom?: string

    /**
     * Date to.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly dateTo?: string

    /**
     * Search by article or name.
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly searchFilter?: string

    /**
     * Brand id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly brandId?: number

    /**
     * Category id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly subcategoryId?: number

    /**
     * Warehouse id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly warehouseId?: number

    /**
     * Country id.
     * @type {number}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly countryId?: number

    /**
     * 
     * @type {BaseSort}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly sort?: BaseSort

    /**
     * Ordering. Desc id is default.
     * @type {LimitedWarehouseNomenclatureQueryOrder}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly order?: LimitedWarehouseNomenclatureQueryOrder

    /**
     * 
     * @type {string}
     * @memberof WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet
     */
    readonly acceptLanguage?: string
}

/**
 * WarehouseNomenclatureReportsApi - object-oriented interface
 * @export
 * @class WarehouseNomenclatureReportsApi
 * @extends {BaseAPI}
 */
export class WarehouseNomenclatureReportsApi extends BaseAPI {
    /**
     * Export warehouse leftovers by brands data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export warehouse leftovers by brands data.
     * @param {WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseNomenclatureReportsApi
     */
    public reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet(requestParameters: WarehouseNomenclatureReportsApiReportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGetRequest, options?: AxiosRequestConfig) {
        return WarehouseNomenclatureReportsApiFp(this.configuration).reportsListByBrandsExportReportsWarehouseNomenclatureByBrandsExportTypeGet(requestParameters.exportType, requestParameters.hideColumns, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.countryId, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current reports.  Role check: is_staff Permission: reports_can_view
     * @summary Get current warehouse reports by brands
     * @param {WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseNomenclatureReportsApi
     */
    public reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet(requestParameters: WarehouseNomenclatureReportsApiReportsListByBrandsReportsWarehouseNomenclatureByBrandsGetRequest = {}, options?: AxiosRequestConfig) {
        return WarehouseNomenclatureReportsApiFp(this.configuration).reportsListByBrandsReportsWarehouseNomenclatureByBrandsGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.countryId, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export warehouse leftovers by country\'s data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export warehouse leftovers by country\'s data.
     * @param {WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseNomenclatureReportsApi
     */
    public reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet(requestParameters: WarehouseNomenclatureReportsApiReportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGetRequest, options?: AxiosRequestConfig) {
        return WarehouseNomenclatureReportsApiFp(this.configuration).reportsListByCountriesExportReportsWarehouseNomenclatureByCountriesExportTypeGet(requestParameters.exportType, requestParameters.hideColumns, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.countryId, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current reports.  Role check: is_staff Permission: reports_can_view
     * @summary Get current warehouse reports by countries
     * @param {WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseNomenclatureReportsApi
     */
    public reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet(requestParameters: WarehouseNomenclatureReportsApiReportsListByCountriesReportsWarehouseNomenclatureByCountriesGetRequest = {}, options?: AxiosRequestConfig) {
        return WarehouseNomenclatureReportsApiFp(this.configuration).reportsListByCountriesReportsWarehouseNomenclatureByCountriesGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.countryId, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export warehouse leftovers data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export warehouse leftovers data.
     * @param {WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseNomenclatureReportsApi
     */
    public reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet(requestParameters: WarehouseNomenclatureReportsApiReportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGetRequest, options?: AxiosRequestConfig) {
        return WarehouseNomenclatureReportsApiFp(this.configuration).reportsListByNomenclatureExportReportsWarehouseNomenclatureByNomenclatureExportTypeGet(requestParameters.exportType, requestParameters.hideColumns, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.countryId, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current reports.  Role check: is_staff Permission: warehouse_in_settings_view
     * @summary Get current reports
     * @param {WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseNomenclatureReportsApi
     */
    public reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet(requestParameters: WarehouseNomenclatureReportsApiReportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGetRequest = {}, options?: AxiosRequestConfig) {
        return WarehouseNomenclatureReportsApiFp(this.configuration).reportsListByNomenclatureReportsWarehouseNomenclatureByNomenclatureGet(requestParameters.page, requestParameters.pageSize, requestParameters.dateFrom, requestParameters.dateTo, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.warehouseId, requestParameters.countryId, requestParameters.sort, requestParameters.order, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WarehouseReportsApi - axios parameter creator
 * @export
 */
export const WarehouseReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers data.
         * @param {DataExportType} exportType 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {number} [brandId] Brand id
         * @param {number} [categoryId] Category id
         * @param {number} [subcategoryId] Subcategory id
         * @param {WarehouseReportQueryOrder} [order] Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
         * @param {number} [warehouseId] Warehouse id
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsWarehouseListExportReportsWarehouseExportTypeGet: async (exportType: DataExportType, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, order?: WarehouseReportQueryOrder, warehouseId?: number, sort?: BaseSort, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportType' is not null or undefined
            assertParamExists('reportsWarehouseListExportReportsWarehouseExportTypeGet', 'exportType', exportType)
            const localVarPath = `/reports/warehouse/{export_type}/`
                .replace(`{${"export_type"}}`, encodeURIComponent(String(exportType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {number} [brandId] Brand id
         * @param {number} [categoryId] Category id
         * @param {number} [subcategoryId] Subcategory id
         * @param {WarehouseReportQueryOrder} [order] Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
         * @param {number} [warehouseId] Warehouse id
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsWarehouseListReportsWarehouseGet: async (page?: number, pageSize?: number, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, order?: WarehouseReportQueryOrder, warehouseId?: number, sort?: BaseSort, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/warehouse/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AutoModernJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }

            if (brandId !== undefined) {
                localVarQueryParameter['brandId'] = brandId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (subcategoryId !== undefined) {
                localVarQueryParameter['subcategoryId'] = subcategoryId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouseId'] = warehouseId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['accept-language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WarehouseReportsApi - functional programming interface
 * @export
 */
export const WarehouseReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WarehouseReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers data.
         * @param {DataExportType} exportType 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {number} [brandId] Brand id
         * @param {number} [categoryId] Category id
         * @param {number} [subcategoryId] Subcategory id
         * @param {WarehouseReportQueryOrder} [order] Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
         * @param {number} [warehouseId] Warehouse id
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsWarehouseListExportReportsWarehouseExportTypeGet(exportType: DataExportType, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, order?: WarehouseReportQueryOrder, warehouseId?: number, sort?: BaseSort, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsWarehouseListExportReportsWarehouseExportTypeGet(exportType, searchFilter, brandId, categoryId, subcategoryId, order, warehouseId, sort, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {number} [brandId] Brand id
         * @param {number} [categoryId] Category id
         * @param {number} [subcategoryId] Subcategory id
         * @param {WarehouseReportQueryOrder} [order] Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
         * @param {number} [warehouseId] Warehouse id
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsWarehouseListReportsWarehouseGet(page?: number, pageSize?: number, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, order?: WarehouseReportQueryOrder, warehouseId?: number, sort?: BaseSort, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseReportPageSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsWarehouseListReportsWarehouseGet(page, pageSize, searchFilter, brandId, categoryId, subcategoryId, order, warehouseId, sort, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WarehouseReportsApi - factory interface
 * @export
 */
export const WarehouseReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WarehouseReportsApiFp(configuration)
    return {
        /**
         * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
         * @summary Export warehouse leftovers data.
         * @param {DataExportType} exportType 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {number} [brandId] Brand id
         * @param {number} [categoryId] Category id
         * @param {number} [subcategoryId] Subcategory id
         * @param {WarehouseReportQueryOrder} [order] Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
         * @param {number} [warehouseId] Warehouse id
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsWarehouseListExportReportsWarehouseExportTypeGet(exportType: DataExportType, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, order?: WarehouseReportQueryOrder, warehouseId?: number, sort?: BaseSort, acceptLanguage?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsWarehouseListExportReportsWarehouseExportTypeGet(exportType, searchFilter, brandId, categoryId, subcategoryId, order, warehouseId, sort, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current reports.  Role check: is_staff Permission: reports_can_view
         * @summary Get current reports
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [searchFilter] Search filter. vendor code, name
         * @param {number} [brandId] Brand id
         * @param {number} [categoryId] Category id
         * @param {number} [subcategoryId] Subcategory id
         * @param {WarehouseReportQueryOrder} [order] Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
         * @param {number} [warehouseId] Warehouse id
         * @param {BaseSort} [sort] Sort order. Desc is default.
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsWarehouseListReportsWarehouseGet(page?: number, pageSize?: number, searchFilter?: string, brandId?: number, categoryId?: number, subcategoryId?: number, order?: WarehouseReportQueryOrder, warehouseId?: number, sort?: BaseSort, acceptLanguage?: string, options?: any): AxiosPromise<WarehouseReportPageSchema> {
            return localVarFp.reportsWarehouseListReportsWarehouseGet(page, pageSize, searchFilter, brandId, categoryId, subcategoryId, order, warehouseId, sort, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportsWarehouseListExportReportsWarehouseExportTypeGet operation in WarehouseReportsApi.
 * @export
 * @interface WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGetRequest
 */
export interface WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGetRequest {
    /**
     * 
     * @type {DataExportType}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly exportType: DataExportType

    /**
     * Search filter. vendor code, name
     * @type {string}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly searchFilter?: string

    /**
     * Brand id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly brandId?: number

    /**
     * Category id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly subcategoryId?: number

    /**
     * Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
     * @type {WarehouseReportQueryOrder}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly order?: WarehouseReportQueryOrder

    /**
     * Warehouse id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly warehouseId?: number

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGet
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for reportsWarehouseListReportsWarehouseGet operation in WarehouseReportsApi.
 * @export
 * @interface WarehouseReportsApiReportsWarehouseListReportsWarehouseGetRequest
 */
export interface WarehouseReportsApiReportsWarehouseListReportsWarehouseGetRequest {
    /**
     * 
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly pageSize?: number

    /**
     * Search filter. vendor code, name
     * @type {string}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly searchFilter?: string

    /**
     * Brand id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly brandId?: number

    /**
     * Category id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly categoryId?: number

    /**
     * Subcategory id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly subcategoryId?: number

    /**
     * Order. If WAREHOUSE_QUANTITY or WAREHOUSE_SUM_COST_PRICE is picked, need to pass warehouse_id
     * @type {WarehouseReportQueryOrder}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly order?: WarehouseReportQueryOrder

    /**
     * Warehouse id
     * @type {number}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly warehouseId?: number

    /**
     * Sort order. Desc is default.
     * @type {BaseSort}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly sort?: BaseSort

    /**
     * 
     * @type {string}
     * @memberof WarehouseReportsApiReportsWarehouseListReportsWarehouseGet
     */
    readonly acceptLanguage?: string
}

/**
 * WarehouseReportsApi - object-oriented interface
 * @export
 * @class WarehouseReportsApi
 * @extends {BaseAPI}
 */
export class WarehouseReportsApi extends BaseAPI {
    /**
     * Export brand profit data.  Role check: is_staff  Permission: reports_can_view
     * @summary Export warehouse leftovers data.
     * @param {WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseReportsApi
     */
    public reportsWarehouseListExportReportsWarehouseExportTypeGet(requestParameters: WarehouseReportsApiReportsWarehouseListExportReportsWarehouseExportTypeGetRequest, options?: AxiosRequestConfig) {
        return WarehouseReportsApiFp(this.configuration).reportsWarehouseListExportReportsWarehouseExportTypeGet(requestParameters.exportType, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.order, requestParameters.warehouseId, requestParameters.sort, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current reports.  Role check: is_staff Permission: reports_can_view
     * @summary Get current reports
     * @param {WarehouseReportsApiReportsWarehouseListReportsWarehouseGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseReportsApi
     */
    public reportsWarehouseListReportsWarehouseGet(requestParameters: WarehouseReportsApiReportsWarehouseListReportsWarehouseGetRequest = {}, options?: AxiosRequestConfig) {
        return WarehouseReportsApiFp(this.configuration).reportsWarehouseListReportsWarehouseGet(requestParameters.page, requestParameters.pageSize, requestParameters.searchFilter, requestParameters.brandId, requestParameters.categoryId, requestParameters.subcategoryId, requestParameters.order, requestParameters.warehouseId, requestParameters.sort, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


