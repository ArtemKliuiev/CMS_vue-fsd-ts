/* tslint:disable */
/* eslint-disable */
/**
 * Kino
 * KINO API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Pydantic schema for showing cinema card.
 * @export
 * @interface CinemaCardOutSchema
 */
export interface CinemaCardOutSchema {
    /**
     * 
     * @type {ImageOutSchema}
     * @memberof CinemaCardOutSchema
     */
    'banner': ImageOutSchema;
    /**
     * 
     * @type {any}
     * @memberof CinemaCardOutSchema
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaCardOutSchema
     */
    'slug'?: any;
}
/**
 * Pydantic schema for creating cinemas to server side.
 * @export
 * @interface CinemaInSchema
 */
export interface CinemaInSchema {
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'seo_title'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'seo_description'?: any;
    /**
     * 
     * @type {ImageInSchema}
     * @memberof CinemaInSchema
     */
    'seo_image': ImageInSchema;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'name_uk'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'name_ru'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'description_uk'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'description_ru'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'terms_uk'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'terms_ru'?: any;
    /**
     * 
     * @type {ImageInSchema}
     * @memberof CinemaInSchema
     */
    'banner': ImageInSchema;
    /**
     * 
     * @type {ImageInSchema}
     * @memberof CinemaInSchema
     */
    'logo': ImageInSchema;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'coordinate'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaInSchema
     */
    'gallery'?: any;
}
/**
 * Pydantic schema for showing cinema full data.
 * @export
 * @interface CinemaOutSchema
 */
export interface CinemaOutSchema {
    /**
     * 
     * @type {ImageOutSchema}
     * @memberof CinemaOutSchema
     */
    'banner': ImageOutSchema;
    /**
     * 
     * @type {ImageOutSchema}
     * @memberof CinemaOutSchema
     */
    'logo': ImageOutSchema;
    /**
     * 
     * @type {ImageOutSchema}
     * @memberof CinemaOutSchema
     */
    'seo_image': ImageOutSchema;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'terms'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'gallery'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'slug'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'coordinate'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'seo_title'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaOutSchema
     */
    'seo_description'?: any;
}
/**
 * Pydantic schema for updating cinema.
 * @export
 * @interface CinemaUpdateSchema
 */
export interface CinemaUpdateSchema {
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'seo_title'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'seo_description'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'seo_image'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'name_uk'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'name_ru'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'description_uk'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'description_ru'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'terms_uk'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'terms_ru'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'banner'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'logo'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'coordinate'?: any;
    /**
     * 
     * @type {any}
     * @memberof CinemaUpdateSchema
     */
    'gallery'?: any;
}
/**
 * 
 * @export
 * @interface CityEnum
 */
export interface CityEnum {
}
/**
 * 
 * @export
 * @interface DirectionEnum
 */
export interface DirectionEnum {
}
/**
 * 
 * @export
 * @interface DynamicInput
 */
export interface DynamicInput {
    /**
     * 
     * @type {any}
     * @memberof DynamicInput
     */
    'page'?: any;
    /**
     * 
     * @type {any}
     * @memberof DynamicInput
     */
    'page_size'?: any;
}
/**
 * Pydantic schema for return gallery images to client side.
 * @export
 * @interface GalleryItemOutSchema
 */
export interface GalleryItemOutSchema {
    /**
     * 
     * @type {any}
     * @memberof GalleryItemOutSchema
     */
    'image': any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemOutSchema
     */
    'image_webp': any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemOutSchema
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemOutSchema
     */
    'alt': any;
}
/**
 * Pydantic schema for uploading image to server side.
 * @export
 * @interface GalleryItemSchema
 */
export interface GalleryItemSchema {
    /**
     * 
     * @type {any}
     * @memberof GalleryItemSchema
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemSchema
     */
    'alt'?: any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemSchema
     */
    'image'?: any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemSchema
     */
    'delete': any;
    /**
     * 
     * @type {any}
     * @memberof GalleryItemSchema
     */
    'filename'?: any;
}
/**
 * Pydantic schema for uploading image to server side.
 * @export
 * @interface ImageInSchema
 */
export interface ImageInSchema {
    /**
     * 
     * @type {any}
     * @memberof ImageInSchema
     */
    'alt'?: any;
    /**
     * 
     * @type {any}
     * @memberof ImageInSchema
     */
    'image': any;
    /**
     * 
     * @type {any}
     * @memberof ImageInSchema
     */
    'filename': any;
}
/**
 * Pydantic schema for return image to client side.
 * @export
 * @interface ImageOutSchema
 */
export interface ImageOutSchema {
    /**
     * 
     * @type {any}
     * @memberof ImageOutSchema
     */
    'image': any;
    /**
     * 
     * @type {any}
     * @memberof ImageOutSchema
     */
    'image_webp': any;
    /**
     * 
     * @type {any}
     * @memberof ImageOutSchema
     */
    'alt': any;
}
/**
 * Pydantic schema for updating image.
 * @export
 * @interface ImageUpdateSchema
 */
export interface ImageUpdateSchema {
    /**
     * 
     * @type {any}
     * @memberof ImageUpdateSchema
     */
    'alt'?: any;
    /**
     * 
     * @type {any}
     * @memberof ImageUpdateSchema
     */
    'image'?: any;
    /**
     * 
     * @type {any}
     * @memberof ImageUpdateSchema
     */
    'filename'?: any;
}
/**
 * 
 * @export
 * @interface LangEnum
 */
export interface LangEnum {
}
/**
 * Pydantic schema for return message to client side.  Purpose of this schema just say that operation has been successful or failed
 * @export
 * @interface LoginResponseSchema
 */
export interface LoginResponseSchema {
    /**
     * 
     * @type {any}
     * @memberof LoginResponseSchema
     */
    'email': any;
    /**
     * 
     * @type {any}
     * @memberof LoginResponseSchema
     */
    'refresh': any;
    /**
     * 
     * @type {any}
     * @memberof LoginResponseSchema
     */
    'access': any;
    /**
     * 
     * @type {any}
     * @memberof LoginResponseSchema
     */
    'admin': any;
}
/**
 * Pydantic schema for return message to client side.  Purpose of this schema just say that operation has been successful or failed
 * @export
 * @interface LoginSchema
 */
export interface LoginSchema {
    /**
     * 
     * @type {any}
     * @memberof LoginSchema
     */
    'password': any;
    /**
     * 
     * @type {any}
     * @memberof LoginSchema
     */
    'email': any;
}
/**
 * Pydantic schema for MailTemplate.  Purpose of this schema to return mail template data
 * @export
 * @interface MailTemplateOutSchema
 */
export interface MailTemplateOutSchema {
    /**
     * 
     * @type {any}
     * @memberof MailTemplateOutSchema
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MailTemplateOutSchema
     */
    'name': any;
}
/**
 * Pydantic schema for mailing.  Purpose of this schema to make mailing
 * @export
 * @interface MailingInSchema
 */
export interface MailingInSchema {
    /**
     * 
     * @type {any}
     * @memberof MailingInSchema
     */
    'user_ids'?: any;
    /**
     * 
     * @type {any}
     * @memberof MailingInSchema
     */
    'temp_id': any;
}
/**
 * Pydantic schema for return message to client side.  Purpose of this schema just say that operation has been successful or failed
 * @export
 * @interface MessageOutSchema
 */
export interface MessageOutSchema {
    /**
     * 
     * @type {any}
     * @memberof MessageOutSchema
     */
    'detail': any;
}
/**
 * 
 * @export
 * @interface PaginatedResponseSchemaCinemaCardOutSchema
 */
export interface PaginatedResponseSchemaCinemaCardOutSchema {
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaCinemaCardOutSchema
     */
    'count': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaCinemaCardOutSchema
     */
    'next': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaCinemaCardOutSchema
     */
    'previous': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaCinemaCardOutSchema
     */
    'results': any;
}
/**
 * 
 * @export
 * @interface PaginatedResponseSchemaList
 */
export interface PaginatedResponseSchemaList {
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaList
     */
    'count': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaList
     */
    'next': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaList
     */
    'previous': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaList
     */
    'results': any;
}
/**
 * 
 * @export
 * @interface PaginatedResponseSchemaUserOutSchema
 */
export interface PaginatedResponseSchemaUserOutSchema {
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaUserOutSchema
     */
    'count': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaUserOutSchema
     */
    'next': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaUserOutSchema
     */
    'previous': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedResponseSchemaUserOutSchema
     */
    'results': any;
}
/**
 * Pydantic schema for getting task info.  Purpose of this schema to get task info
 * @export
 * @interface TaskInfoOutSchema
 */
export interface TaskInfoOutSchema {
    /**
     * 
     * @type {any}
     * @memberof TaskInfoOutSchema
     */
    'progress': any;
}
/**
 * 
 * @export
 * @interface TokenRefreshInputSchema
 */
export interface TokenRefreshInputSchema {
    /**
     * 
     * @type {any}
     * @memberof TokenRefreshInputSchema
     */
    'refresh': any;
}
/**
 * 
 * @export
 * @interface TokenRefreshOutputSchema
 */
export interface TokenRefreshOutputSchema {
    /**
     * 
     * @type {any}
     * @memberof TokenRefreshOutputSchema
     */
    'refresh': any;
    /**
     * 
     * @type {any}
     * @memberof TokenRefreshOutputSchema
     */
    'access': any;
}
/**
 * 
 * @export
 * @interface UserFieldsEnum
 */
export interface UserFieldsEnum {
}
/**
 * Pydantic schema for User.  Purpose of this schema to return user\'s personal data
 * @export
 * @interface UserOutSchema
 */
export interface UserOutSchema {
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'city_display': any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'first_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'last_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'nickname'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'city'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'man'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'phone_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'email': any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'address'?: any;
    /**
     * Указывает, что пользователь имеет все права без явного их назначения.
     * @type {any}
     * @memberof UserOutSchema
     */
    'is_superuser'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserOutSchema
     */
    'birthday'?: any;
}
/**
 * Pydantic schema for User.  Purpose of this schema to get user\'s personal data for registration
 * @export
 * @interface UserRegisterSchema
 */
export interface UserRegisterSchema {
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'first_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'last_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'nickname'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'man'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'phone_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'email': any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'city'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'birthday'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'password1': any;
    /**
     * 
     * @type {any}
     * @memberof UserRegisterSchema
     */
    'password2': any;
}
/**
 * Pydantic schema for update User.  Purpose of this schema to get user\'s personal data for updating
 * @export
 * @interface UserUpdateSchema
 */
export interface UserUpdateSchema {
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'first_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'last_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'nickname'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'man'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'phone_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'city'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserUpdateSchema
     */
    'birthday'?: any;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint gets cities for user to choose. Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Cities
         * @param {any} [acceptLanguage] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCities: async (acceptLanguage?: any, page?: any, pageSize?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/cities/choices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get My Profile
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyProfile: async (acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/my-profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s token by provided credentials.  Please provide:   - **Request body**  data with credentials of user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Obtain Token
         * @param {LoginSchema} loginSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainToken: async (loginSchema: LoginSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginSchema' is not null or undefined
            assertParamExists('obtainToken', 'loginSchema', loginSchema)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s new access token by provided refresh token.  Please provide:   - **Request body**  provide here refresh token  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Refresh Token
         * @param {TokenRefreshInputSchema} tokenRefreshInputSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (tokenRefreshInputSchema: TokenRefreshInputSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshInputSchema' is not null or undefined
            assertParamExists('refreshToken', 'tokenRefreshInputSchema', tokenRefreshInputSchema)
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshInputSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Паролі не співпадають           2) Пароль повинен бути:              * Принаймні одна велика літера              * Принаймні одна мала літера              * Принаймні одна цифра              * Принаймні один спеціальний символ із набору ?!@%^&-              * Мінімальна довжина 8 символів           3) Введено некоректний номер телефону           4) Ім\'я та прізвище повинно починатися з великої літери              (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)     - **409**: Error: Conflict.       Причини:           1) Ця електронна адреса вже використовується   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Register
         * @param {UserRegisterSchema} userRegisterSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (userRegisterSchema: UserRegisterSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegisterSchema' is not null or undefined
            assertParamExists('register', 'userRegisterSchema', userRegisterSchema)
            const localVarPath = `/api/auth/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegisterSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Update My Profile
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyProfile: async (userUpdateSchema: UserUpdateSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateSchema' is not null or undefined
            assertParamExists('updateMyProfile', 'userUpdateSchema', userUpdateSchema)
            const localVarPath = `/api/auth/my-profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint gets cities for user to choose. Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Cities
         * @param {any} [acceptLanguage] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCities(acceptLanguage?: any, page?: any, pageSize?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseSchemaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCities(acceptLanguage, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get My Profile
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyProfile(acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyProfile(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s token by provided credentials.  Please provide:   - **Request body**  data with credentials of user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Obtain Token
         * @param {LoginSchema} loginSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtainToken(loginSchema: LoginSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtainToken(loginSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s new access token by provided refresh token.  Please provide:   - **Request body**  provide here refresh token  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Refresh Token
         * @param {TokenRefreshInputSchema} tokenRefreshInputSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(tokenRefreshInputSchema: TokenRefreshInputSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefreshOutputSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(tokenRefreshInputSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Паролі не співпадають           2) Пароль повинен бути:              * Принаймні одна велика літера              * Принаймні одна мала літера              * Принаймні одна цифра              * Принаймні один спеціальний символ із набору ?!@%^&-              * Мінімальна довжина 8 символів           3) Введено некоректний номер телефону           4) Ім\'я та прізвище повинно починатися з великої літери              (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)     - **409**: Error: Conflict.       Причини:           1) Ця електронна адреса вже використовується   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Register
         * @param {UserRegisterSchema} userRegisterSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(userRegisterSchema: UserRegisterSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(userRegisterSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Update My Profile
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyProfile(userUpdateSchema: UserUpdateSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyProfile(userUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Endpoint gets cities for user to choose. Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Cities
         * @param {any} [acceptLanguage] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCities(acceptLanguage?: any, page?: any, pageSize?: any, options?: any): AxiosPromise<PaginatedResponseSchemaList> {
            return localVarFp.getCities(acceptLanguage, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get My Profile
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyProfile(acceptLanguage?: any, options?: any): AxiosPromise<UserOutSchema> {
            return localVarFp.getMyProfile(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s token by provided credentials.  Please provide:   - **Request body**  data with credentials of user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Obtain Token
         * @param {LoginSchema} loginSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainToken(loginSchema: LoginSchema, acceptLanguage?: any, options?: any): AxiosPromise<LoginResponseSchema> {
            return localVarFp.obtainToken(loginSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s new access token by provided refresh token.  Please provide:   - **Request body**  provide here refresh token  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Refresh Token
         * @param {TokenRefreshInputSchema} tokenRefreshInputSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(tokenRefreshInputSchema: TokenRefreshInputSchema, acceptLanguage?: any, options?: any): AxiosPromise<TokenRefreshOutputSchema> {
            return localVarFp.refreshToken(tokenRefreshInputSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Паролі не співпадають           2) Пароль повинен бути:              * Принаймні одна велика літера              * Принаймні одна мала літера              * Принаймні одна цифра              * Принаймні один спеціальний символ із набору ?!@%^&-              * Мінімальна довжина 8 символів           3) Введено некоректний номер телефону           4) Ім\'я та прізвище повинно починатися з великої літери              (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)     - **409**: Error: Conflict.       Причини:           1) Ця електронна адреса вже використовується   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Register
         * @param {UserRegisterSchema} userRegisterSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(userRegisterSchema: UserRegisterSchema, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp.register(userRegisterSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Update My Profile
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyProfile(userUpdateSchema: UserUpdateSchema, acceptLanguage?: any, options?: any): AxiosPromise<UserOutSchema> {
            return localVarFp.updateMyProfile(userUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCities operation in AuthApi.
 * @export
 * @interface AuthApiGetCitiesRequest
 */
export interface AuthApiGetCitiesRequest {
    /**
     * 
     * @type {any}
     * @memberof AuthApiGetCities
     */
    readonly acceptLanguage?: any

    /**
     * 
     * @type {any}
     * @memberof AuthApiGetCities
     */
    readonly page?: any

    /**
     * 
     * @type {any}
     * @memberof AuthApiGetCities
     */
    readonly pageSize?: any
}

/**
 * Request parameters for getMyProfile operation in AuthApi.
 * @export
 * @interface AuthApiGetMyProfileRequest
 */
export interface AuthApiGetMyProfileRequest {
    /**
     * 
     * @type {any}
     * @memberof AuthApiGetMyProfile
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for obtainToken operation in AuthApi.
 * @export
 * @interface AuthApiObtainTokenRequest
 */
export interface AuthApiObtainTokenRequest {
    /**
     * 
     * @type {LoginSchema}
     * @memberof AuthApiObtainToken
     */
    readonly loginSchema: LoginSchema

    /**
     * 
     * @type {any}
     * @memberof AuthApiObtainToken
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for refreshToken operation in AuthApi.
 * @export
 * @interface AuthApiRefreshTokenRequest
 */
export interface AuthApiRefreshTokenRequest {
    /**
     * 
     * @type {TokenRefreshInputSchema}
     * @memberof AuthApiRefreshToken
     */
    readonly tokenRefreshInputSchema: TokenRefreshInputSchema

    /**
     * 
     * @type {any}
     * @memberof AuthApiRefreshToken
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for register operation in AuthApi.
 * @export
 * @interface AuthApiRegisterRequest
 */
export interface AuthApiRegisterRequest {
    /**
     * 
     * @type {UserRegisterSchema}
     * @memberof AuthApiRegister
     */
    readonly userRegisterSchema: UserRegisterSchema

    /**
     * 
     * @type {any}
     * @memberof AuthApiRegister
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for updateMyProfile operation in AuthApi.
 * @export
 * @interface AuthApiUpdateMyProfileRequest
 */
export interface AuthApiUpdateMyProfileRequest {
    /**
     * 
     * @type {UserUpdateSchema}
     * @memberof AuthApiUpdateMyProfile
     */
    readonly userUpdateSchema: UserUpdateSchema

    /**
     * 
     * @type {any}
     * @memberof AuthApiUpdateMyProfile
     */
    readonly acceptLanguage?: any
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Endpoint gets cities for user to choose. Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Get Cities
     * @param {AuthApiGetCitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCities(requestParameters: AuthApiGetCitiesRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getCities(requestParameters.acceptLanguage, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Get My Profile
     * @param {AuthApiGetMyProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getMyProfile(requestParameters: AuthApiGetMyProfileRequest = {}, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getMyProfile(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s token by provided credentials.  Please provide:   - **Request body**  data with credentials of user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Obtain Token
     * @param {AuthApiObtainTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public obtainToken(requestParameters: AuthApiObtainTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).obtainToken(requestParameters.loginSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s new access token by provided refresh token.  Please provide:   - **Request body**  provide here refresh token  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Refresh Token
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(requestParameters: AuthApiRefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(requestParameters.tokenRefreshInputSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Паролі не співпадають           2) Пароль повинен бути:              * Принаймні одна велика літера              * Принаймні одна мала літера              * Принаймні одна цифра              * Принаймні один спеціальний символ із набору ?!@%^&-              * Мінімальна довжина 8 символів           3) Введено некоректний номер телефону           4) Ім\'я та прізвище повинно починатися з великої літери              (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)     - **409**: Error: Conflict.       Причини:           1) Ця електронна адреса вже використовується   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Register
     * @param {AuthApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(requestParameters: AuthApiRegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(requestParameters.userRegisterSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s personal data by token.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **401**: Error: Unauthorized.     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Update My Profile
     * @param {AuthApiUpdateMyProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public updateMyProfile(requestParameters: AuthApiUpdateMyProfileRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).updateMyProfile(requestParameters.userUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CinemasApi - axios parameter creator
 * @export
 */
export const CinemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create cinema.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
         * @summary Get By Slug
         * @param {any} cnmSlug 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _10b2699aControllerGetBySlug: async (cnmSlug: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cnmSlug' is not null or undefined
            assertParamExists('_10b2699aControllerGetBySlug', 'cnmSlug', cnmSlug)
            const localVarPath = `/api/cinema/{cnm_slug}/`
                .replace(`{${"cnm_slug"}}`, encodeURIComponent(String(cnmSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.     Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
         * @summary Create Cinema
         * @param {CinemaInSchema} cinemaInSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _4890e9a0ControllerCreateCinema: async (cinemaInSchema: CinemaInSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cinemaInSchema' is not null or undefined
            assertParamExists('_4890e9a0ControllerCreateCinema', 'cinemaInSchema', cinemaInSchema)
            const localVarPath = `/api/cinema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cinemaInSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete cinema by id.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete By Slug
         * @param {any} cnmSlug 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _7db73c3dControllerDeleteBySlug: async (cnmSlug: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cnmSlug' is not null or undefined
            assertParamExists('_7db73c3dControllerDeleteBySlug', 'cnmSlug', cnmSlug)
            const localVarPath = `/api/cinema/{cnm_slug}/`
                .replace(`{${"cnm_slug"}}`, encodeURIComponent(String(cnmSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.       Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
         * @summary Update Cinema
         * @param {any} cnmSlug 
         * @param {CinemaUpdateSchema} cinemaUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _93cc4991ControllerUpdateCinema: async (cnmSlug: any, cinemaUpdateSchema: CinemaUpdateSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cnmSlug' is not null or undefined
            assertParamExists('_93cc4991ControllerUpdateCinema', 'cnmSlug', cnmSlug)
            // verify required parameter 'cinemaUpdateSchema' is not null or undefined
            assertParamExists('_93cc4991ControllerUpdateCinema', 'cinemaUpdateSchema', cinemaUpdateSchema)
            const localVarPath = `/api/cinema/{cnm_slug}/`
                .replace(`{${"cnm_slug"}}`, encodeURIComponent(String(cnmSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cinemaUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all cinema cards.  Returns:   - **200**: Success response with the data.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Cinema Cards
         * @param {any} [acceptLanguage] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aca33f19ControllerGetCinemaCards: async (acceptLanguage?: any, page?: any, pageSize?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cinema/all-cards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CinemasApi - functional programming interface
 * @export
 */
export const CinemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CinemasApiAxiosParamCreator(configuration)
    return {
        /**
         * Create cinema.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
         * @summary Get By Slug
         * @param {any} cnmSlug 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _10b2699aControllerGetBySlug(cnmSlug: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CinemaOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._10b2699aControllerGetBySlug(cnmSlug, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.     Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
         * @summary Create Cinema
         * @param {CinemaInSchema} cinemaInSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _4890e9a0ControllerCreateCinema(cinemaInSchema: CinemaInSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._4890e9a0ControllerCreateCinema(cinemaInSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete cinema by id.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete By Slug
         * @param {any} cnmSlug 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _7db73c3dControllerDeleteBySlug(cnmSlug: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._7db73c3dControllerDeleteBySlug(cnmSlug, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.       Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
         * @summary Update Cinema
         * @param {any} cnmSlug 
         * @param {CinemaUpdateSchema} cinemaUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _93cc4991ControllerUpdateCinema(cnmSlug: any, cinemaUpdateSchema: CinemaUpdateSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._93cc4991ControllerUpdateCinema(cnmSlug, cinemaUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all cinema cards.  Returns:   - **200**: Success response with the data.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Cinema Cards
         * @param {any} [acceptLanguage] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aca33f19ControllerGetCinemaCards(acceptLanguage?: any, page?: any, pageSize?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseSchemaCinemaCardOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aca33f19ControllerGetCinemaCards(acceptLanguage, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CinemasApi - factory interface
 * @export
 */
export const CinemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CinemasApiFp(configuration)
    return {
        /**
         * Create cinema.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
         * @summary Get By Slug
         * @param {any} cnmSlug 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _10b2699aControllerGetBySlug(cnmSlug: any, acceptLanguage?: any, options?: any): AxiosPromise<CinemaOutSchema> {
            return localVarFp._10b2699aControllerGetBySlug(cnmSlug, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.     Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
         * @summary Create Cinema
         * @param {CinemaInSchema} cinemaInSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _4890e9a0ControllerCreateCinema(cinemaInSchema: CinemaInSchema, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp._4890e9a0ControllerCreateCinema(cinemaInSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete cinema by id.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete By Slug
         * @param {any} cnmSlug 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _7db73c3dControllerDeleteBySlug(cnmSlug: any, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp._7db73c3dControllerDeleteBySlug(cnmSlug, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.       Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
         * @summary Update Cinema
         * @param {any} cnmSlug 
         * @param {CinemaUpdateSchema} cinemaUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _93cc4991ControllerUpdateCinema(cnmSlug: any, cinemaUpdateSchema: CinemaUpdateSchema, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp._93cc4991ControllerUpdateCinema(cnmSlug, cinemaUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all cinema cards.  Returns:   - **200**: Success response with the data.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Cinema Cards
         * @param {any} [acceptLanguage] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aca33f19ControllerGetCinemaCards(acceptLanguage?: any, page?: any, pageSize?: any, options?: any): AxiosPromise<PaginatedResponseSchemaCinemaCardOutSchema> {
            return localVarFp.aca33f19ControllerGetCinemaCards(acceptLanguage, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _10b2699aControllerGetBySlug operation in CinemasApi.
 * @export
 * @interface CinemasApi10b2699aControllerGetBySlugRequest
 */
export interface CinemasApi10b2699aControllerGetBySlugRequest {
    /**
     * 
     * @type {any}
     * @memberof CinemasApi10b2699aControllerGetBySlug
     */
    readonly cnmSlug: any

    /**
     * 
     * @type {any}
     * @memberof CinemasApi10b2699aControllerGetBySlug
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for _4890e9a0ControllerCreateCinema operation in CinemasApi.
 * @export
 * @interface CinemasApi4890e9a0ControllerCreateCinemaRequest
 */
export interface CinemasApi4890e9a0ControllerCreateCinemaRequest {
    /**
     * 
     * @type {CinemaInSchema}
     * @memberof CinemasApi4890e9a0ControllerCreateCinema
     */
    readonly cinemaInSchema: CinemaInSchema

    /**
     * 
     * @type {any}
     * @memberof CinemasApi4890e9a0ControllerCreateCinema
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for _7db73c3dControllerDeleteBySlug operation in CinemasApi.
 * @export
 * @interface CinemasApi7db73c3dControllerDeleteBySlugRequest
 */
export interface CinemasApi7db73c3dControllerDeleteBySlugRequest {
    /**
     * 
     * @type {any}
     * @memberof CinemasApi7db73c3dControllerDeleteBySlug
     */
    readonly cnmSlug: any

    /**
     * 
     * @type {any}
     * @memberof CinemasApi7db73c3dControllerDeleteBySlug
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for _93cc4991ControllerUpdateCinema operation in CinemasApi.
 * @export
 * @interface CinemasApi93cc4991ControllerUpdateCinemaRequest
 */
export interface CinemasApi93cc4991ControllerUpdateCinemaRequest {
    /**
     * 
     * @type {any}
     * @memberof CinemasApi93cc4991ControllerUpdateCinema
     */
    readonly cnmSlug: any

    /**
     * 
     * @type {CinemaUpdateSchema}
     * @memberof CinemasApi93cc4991ControllerUpdateCinema
     */
    readonly cinemaUpdateSchema: CinemaUpdateSchema

    /**
     * 
     * @type {any}
     * @memberof CinemasApi93cc4991ControllerUpdateCinema
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for aca33f19ControllerGetCinemaCards operation in CinemasApi.
 * @export
 * @interface CinemasApiAca33f19ControllerGetCinemaCardsRequest
 */
export interface CinemasApiAca33f19ControllerGetCinemaCardsRequest {
    /**
     * 
     * @type {any}
     * @memberof CinemasApiAca33f19ControllerGetCinemaCards
     */
    readonly acceptLanguage?: any

    /**
     * 
     * @type {any}
     * @memberof CinemasApiAca33f19ControllerGetCinemaCards
     */
    readonly page?: any

    /**
     * 
     * @type {any}
     * @memberof CinemasApiAca33f19ControllerGetCinemaCards
     */
    readonly pageSize?: any
}

/**
 * CinemasApi - object-oriented interface
 * @export
 * @class CinemasApi
 * @extends {BaseAPI}
 */
export class CinemasApi extends BaseAPI {
    /**
     * Create cinema.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
     * @summary Get By Slug
     * @param {CinemasApi10b2699aControllerGetBySlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CinemasApi
     */
    public _10b2699aControllerGetBySlug(requestParameters: CinemasApi10b2699aControllerGetBySlugRequest, options?: AxiosRequestConfig) {
        return CinemasApiFp(this.configuration)._10b2699aControllerGetBySlug(requestParameters.cnmSlug, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.     Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
     * @summary Create Cinema
     * @param {CinemasApi4890e9a0ControllerCreateCinemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CinemasApi
     */
    public _4890e9a0ControllerCreateCinema(requestParameters: CinemasApi4890e9a0ControllerCreateCinemaRequest, options?: AxiosRequestConfig) {
        return CinemasApiFp(this.configuration)._4890e9a0ControllerCreateCinema(requestParameters.cinemaInSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete cinema by id.  Please provide:   - **cinema_id**  id of cinema  Returns:   - **200**: Success response with the data.   - **404**: Error: Forbidden.       Причини:           1) Не знайдено: немає збігів кінотеатрів            на заданному запиті.     - **500**: Internal server error if an unexpected error occurs.
     * @summary Delete By Slug
     * @param {CinemasApi7db73c3dControllerDeleteBySlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CinemasApi
     */
    public _7db73c3dControllerDeleteBySlug(requestParameters: CinemasApi7db73c3dControllerDeleteBySlugRequest, options?: AxiosRequestConfig) {
        return CinemasApiFp(this.configuration)._7db73c3dControllerDeleteBySlug(requestParameters.cnmSlug, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update cinema.  Please provide:   - **body**  body for creating new cinema  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Недійсне значення (не написане великими літерами).            З великих літер повинні починатися (name, description,            seo_title, seo_description)     - **409**: Error: Conflict.       Причини:           1) Поле name повинно бути унікальним. Ця назва вже зайнята   - **422**: Error: Unprocessable Entity.       Причини:           1) Максимальни довжина description 2000 символів           2) Максимальни довжина name 100 символів           3) Максимальни довжина seo_title 60 символів           4) Максимальни довжина seo_description 160 символів     - **500**: Internal server error if an unexpected error occurs.
     * @summary Update Cinema
     * @param {CinemasApi93cc4991ControllerUpdateCinemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CinemasApi
     */
    public _93cc4991ControllerUpdateCinema(requestParameters: CinemasApi93cc4991ControllerUpdateCinemaRequest, options?: AxiosRequestConfig) {
        return CinemasApiFp(this.configuration)._93cc4991ControllerUpdateCinema(requestParameters.cnmSlug, requestParameters.cinemaUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all cinema cards.  Returns:   - **200**: Success response with the data.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Get Cinema Cards
     * @param {CinemasApiAca33f19ControllerGetCinemaCardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CinemasApi
     */
    public aca33f19ControllerGetCinemaCards(requestParameters: CinemasApiAca33f19ControllerGetCinemaCardsRequest = {}, options?: AxiosRequestConfig) {
        return CinemasApiFp(this.configuration).aca33f19ControllerGetCinemaCards(requestParameters.acceptLanguage, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GalleriesApi - axios parameter creator
 * @export
 */
export const GalleriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get maximum of gallery fields.  Please provide:   - **gallery_id**  id of gallery we want to get  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.         Причини:         1) Не знайдено: немає збігів галерей            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Gallery
         * @param {any} galleryId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d81d4933ControllerGetGallery: async (galleryId: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'galleryId' is not null or undefined
            assertParamExists('d81d4933ControllerGetGallery', 'galleryId', galleryId)
            const localVarPath = `/api/gallery/{gallery_id}/`
                .replace(`{${"gallery_id"}}`, encodeURIComponent(String(galleryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GalleriesApi - functional programming interface
 * @export
 */
export const GalleriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GalleriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get maximum of gallery fields.  Please provide:   - **gallery_id**  id of gallery we want to get  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.         Причини:         1) Не знайдено: немає збігів галерей            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Gallery
         * @param {any} galleryId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d81d4933ControllerGetGallery(galleryId: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GalleryItemOutSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d81d4933ControllerGetGallery(galleryId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GalleriesApi - factory interface
 * @export
 */
export const GalleriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GalleriesApiFp(configuration)
    return {
        /**
         * Get maximum of gallery fields.  Please provide:   - **gallery_id**  id of gallery we want to get  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.         Причини:         1) Не знайдено: немає збігів галерей            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Gallery
         * @param {any} galleryId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d81d4933ControllerGetGallery(galleryId: any, acceptLanguage?: any, options?: any): AxiosPromise<Array<GalleryItemOutSchema>> {
            return localVarFp.d81d4933ControllerGetGallery(galleryId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for d81d4933ControllerGetGallery operation in GalleriesApi.
 * @export
 * @interface GalleriesApiD81d4933ControllerGetGalleryRequest
 */
export interface GalleriesApiD81d4933ControllerGetGalleryRequest {
    /**
     * 
     * @type {any}
     * @memberof GalleriesApiD81d4933ControllerGetGallery
     */
    readonly galleryId: any

    /**
     * 
     * @type {any}
     * @memberof GalleriesApiD81d4933ControllerGetGallery
     */
    readonly acceptLanguage?: any
}

/**
 * GalleriesApi - object-oriented interface
 * @export
 * @class GalleriesApi
 * @extends {BaseAPI}
 */
export class GalleriesApi extends BaseAPI {
    /**
     * Get maximum of gallery fields.  Please provide:   - **gallery_id**  id of gallery we want to get  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.         Причини:         1) Не знайдено: немає збігів галерей            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Get Gallery
     * @param {GalleriesApiD81d4933ControllerGetGalleryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleriesApi
     */
    public d81d4933ControllerGetGallery(requestParameters: GalleriesApiD81d4933ControllerGetGalleryRequest, options?: AxiosRequestConfig) {
        return GalleriesApiFp(this.configuration).d81d4933ControllerGetGallery(requestParameters.galleryId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MailingApi - axios parameter creator
 * @export
 */
export const MailingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create template for mailing.  Please provide:   - **file**  file for new template  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Дозволено відправляти тільки html           2) Максимально дозволений розмір файлу 1MB     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Create Template
         * @param {any} file 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (file: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createTemplate', 'file', file)
            const localVarPath = `/api/mailing/template/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete template for mailing by id.  Returns:   - **200**: Success response with the data.   - **403**: Error: Not Found.      Причини:           1) Не можна видаляти шаблони поки йде розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete Template
         * @param {any} tempId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (tempId: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tempId' is not null or undefined
            assertParamExists('deleteTemplate', 'tempId', tempId)
            const localVarPath = `/api/mailing/template/{temp_id}/`
                .replace(`{${"temp_id"}}`, encodeURIComponent(String(tempId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get last 5 templates for mailing.  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Templates
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: async (acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mailing/templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start mailing letter to recipients.  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.       Причини:           1) Треба зачекати поки закінчиться поточне розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Start Mailing
         * @param {MailingInSchema} mailingInSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startMailing: async (mailingInSchema: MailingInSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailingInSchema' is not null or undefined
            assertParamExists('startMailing', 'mailingInSchema', mailingInSchema)
            const localVarPath = `/api/mailing/start/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailingInSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status for current mailing.  Returns:   - **200**: Success response with the data.   - **201**: Success mailing completed.   - **404**: Error: Not Found.       Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Status Mailing
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMailing: async (acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mailing/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailingApi - functional programming interface
 * @export
 */
export const MailingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create template for mailing.  Please provide:   - **file**  file for new template  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Дозволено відправляти тільки html           2) Максимально дозволений розмір файлу 1MB     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Create Template
         * @param {any} file 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(file: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MailTemplateOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(file, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete template for mailing by id.  Returns:   - **200**: Success response with the data.   - **403**: Error: Not Found.      Причини:           1) Не можна видаляти шаблони поки йде розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete Template
         * @param {any} tempId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(tempId: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(tempId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get last 5 templates for mailing.  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Templates
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplates(acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MailTemplateOutSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start mailing letter to recipients.  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.       Причини:           1) Треба зачекати поки закінчиться поточне розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Start Mailing
         * @param {MailingInSchema} mailingInSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startMailing(mailingInSchema: MailingInSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startMailing(mailingInSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status for current mailing.  Returns:   - **200**: Success response with the data.   - **201**: Success mailing completed.   - **404**: Error: Not Found.       Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Status Mailing
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusMailing(acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfoOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusMailing(acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MailingApi - factory interface
 * @export
 */
export const MailingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailingApiFp(configuration)
    return {
        /**
         * Create template for mailing.  Please provide:   - **file**  file for new template  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Дозволено відправляти тільки html           2) Максимально дозволений розмір файлу 1MB     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Create Template
         * @param {any} file 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(file: any, acceptLanguage?: any, options?: any): AxiosPromise<MailTemplateOutSchema> {
            return localVarFp.createTemplate(file, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete template for mailing by id.  Returns:   - **200**: Success response with the data.   - **403**: Error: Not Found.      Причини:           1) Не можна видаляти шаблони поки йде розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete Template
         * @param {any} tempId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(tempId: any, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp.deleteTemplate(tempId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get last 5 templates for mailing.  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get Templates
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(acceptLanguage?: any, options?: any): AxiosPromise<Array<MailTemplateOutSchema>> {
            return localVarFp.getTemplates(acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Start mailing letter to recipients.  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.       Причини:           1) Треба зачекати поки закінчиться поточне розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Start Mailing
         * @param {MailingInSchema} mailingInSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startMailing(mailingInSchema: MailingInSchema, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp.startMailing(mailingInSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status for current mailing.  Returns:   - **200**: Success response with the data.   - **201**: Success mailing completed.   - **404**: Error: Not Found.       Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Status Mailing
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMailing(acceptLanguage?: any, options?: any): AxiosPromise<TaskInfoOutSchema> {
            return localVarFp.statusMailing(acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTemplate operation in MailingApi.
 * @export
 * @interface MailingApiCreateTemplateRequest
 */
export interface MailingApiCreateTemplateRequest {
    /**
     * 
     * @type {any}
     * @memberof MailingApiCreateTemplate
     */
    readonly file: any

    /**
     * 
     * @type {any}
     * @memberof MailingApiCreateTemplate
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for deleteTemplate operation in MailingApi.
 * @export
 * @interface MailingApiDeleteTemplateRequest
 */
export interface MailingApiDeleteTemplateRequest {
    /**
     * 
     * @type {any}
     * @memberof MailingApiDeleteTemplate
     */
    readonly tempId: any

    /**
     * 
     * @type {any}
     * @memberof MailingApiDeleteTemplate
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for getTemplates operation in MailingApi.
 * @export
 * @interface MailingApiGetTemplatesRequest
 */
export interface MailingApiGetTemplatesRequest {
    /**
     * 
     * @type {any}
     * @memberof MailingApiGetTemplates
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for startMailing operation in MailingApi.
 * @export
 * @interface MailingApiStartMailingRequest
 */
export interface MailingApiStartMailingRequest {
    /**
     * 
     * @type {MailingInSchema}
     * @memberof MailingApiStartMailing
     */
    readonly mailingInSchema: MailingInSchema

    /**
     * 
     * @type {any}
     * @memberof MailingApiStartMailing
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for statusMailing operation in MailingApi.
 * @export
 * @interface MailingApiStatusMailingRequest
 */
export interface MailingApiStatusMailingRequest {
    /**
     * 
     * @type {any}
     * @memberof MailingApiStatusMailing
     */
    readonly acceptLanguage?: any
}

/**
 * MailingApi - object-oriented interface
 * @export
 * @class MailingApi
 * @extends {BaseAPI}
 */
export class MailingApi extends BaseAPI {
    /**
     * Create template for mailing.  Please provide:   - **file**  file for new template  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Дозволено відправляти тільки html           2) Максимально дозволений розмір файлу 1MB     - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Create Template
     * @param {MailingApiCreateTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailingApi
     */
    public createTemplate(requestParameters: MailingApiCreateTemplateRequest, options?: AxiosRequestConfig) {
        return MailingApiFp(this.configuration).createTemplate(requestParameters.file, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete template for mailing by id.  Returns:   - **200**: Success response with the data.   - **403**: Error: Not Found.      Причини:           1) Не можна видаляти шаблони поки йде розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Delete Template
     * @param {MailingApiDeleteTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailingApi
     */
    public deleteTemplate(requestParameters: MailingApiDeleteTemplateRequest, options?: AxiosRequestConfig) {
        return MailingApiFp(this.configuration).deleteTemplate(requestParameters.tempId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get last 5 templates for mailing.  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Get Templates
     * @param {MailingApiGetTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailingApi
     */
    public getTemplates(requestParameters: MailingApiGetTemplatesRequest = {}, options?: AxiosRequestConfig) {
        return MailingApiFp(this.configuration).getTemplates(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start mailing letter to recipients.  Returns:   - **200**: Success response with the data.   - **404**: Error: Not Found.       Причини:           1) Треба зачекати поки закінчиться поточне розсилання.   - **404**: Error: Not Found.      Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Start Mailing
     * @param {MailingApiStartMailingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailingApi
     */
    public startMailing(requestParameters: MailingApiStartMailingRequest, options?: AxiosRequestConfig) {
        return MailingApiFp(this.configuration).startMailing(requestParameters.mailingInSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status for current mailing.  Returns:   - **200**: Success response with the data.   - **201**: Success mailing completed.   - **404**: Error: Not Found.       Причини:           1) Не знайдено: немає збігів шаблонів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Status Mailing
     * @param {MailingApiStatusMailingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailingApi
     */
    public statusMailing(requestParameters: MailingApiStatusMailingRequest = {}, options?: AxiosRequestConfig) {
        return MailingApiFp(this.configuration).statusMailing(requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint gets all users.  Makes pagination, search and sorting of records.  Please provide:  - **page**  number of page we want to get  - **page_size**  length of records per page  - **search_line**  helps to find rows which contains search line  - **sort**  define by which field sort rows  - **direction**  determines in which direction to sort  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Datatable
         * @param {any} [searchLine] 
         * @param {any} [sort] 
         * @param {any} [direction] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datatable: async (searchLine?: any, sort?: any, direction?: any, page?: any, pageSize?: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/datable/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchLine !== undefined) {
                localVarQueryParameter['search_line'] = searchLine;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete By Id
         * @param {any} userId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: async (userId: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteById', 'userId', userId)
            const localVarPath = `/api/users/detail/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get By Id
         * @param {any} userId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (userId: any, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getById', 'userId', userId)
            const localVarPath = `/api/users/detail/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user by id.  Please provide:   - **Request body**  data for updating user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Введено некоректний номер телефону           2) Ім\'я та прізвище повинно починатися з великої літери            (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Update By Id
         * @param {any} userId 
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateById: async (userId: any, userUpdateSchema: UserUpdateSchema, acceptLanguage?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateById', 'userId', userId)
            // verify required parameter 'userUpdateSchema' is not null or undefined
            assertParamExists('updateById', 'userUpdateSchema', userUpdateSchema)
            const localVarPath = `/api/users/detail/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomJWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint gets all users.  Makes pagination, search and sorting of records.  Please provide:  - **page**  number of page we want to get  - **page_size**  length of records per page  - **search_line**  helps to find rows which contains search line  - **sort**  define by which field sort rows  - **direction**  determines in which direction to sort  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Datatable
         * @param {any} [searchLine] 
         * @param {any} [sort] 
         * @param {any} [direction] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datatable(searchLine?: any, sort?: any, direction?: any, page?: any, pageSize?: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseSchemaUserOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datatable(searchLine, sort, direction, page, pageSize, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete By Id
         * @param {any} userId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteById(userId: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get By Id
         * @param {any} userId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(userId: any, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(userId, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user by id.  Please provide:   - **Request body**  data for updating user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Введено некоректний номер телефону           2) Ім\'я та прізвище повинно починатися з великої літери            (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Update By Id
         * @param {any} userId 
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateById(userId: any, userUpdateSchema: UserUpdateSchema, acceptLanguage?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateById(userId, userUpdateSchema, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Endpoint gets all users.  Makes pagination, search and sorting of records.  Please provide:  - **page**  number of page we want to get  - **page_size**  length of records per page  - **search_line**  helps to find rows which contains search line  - **sort**  define by which field sort rows  - **direction**  determines in which direction to sort  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Datatable
         * @param {any} [searchLine] 
         * @param {any} [sort] 
         * @param {any} [direction] 
         * @param {any} [page] 
         * @param {any} [pageSize] 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datatable(searchLine?: any, sort?: any, direction?: any, page?: any, pageSize?: any, acceptLanguage?: any, options?: any): AxiosPromise<PaginatedResponseSchemaUserOutSchema> {
            return localVarFp.datatable(searchLine, sort, direction, page, pageSize, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Delete By Id
         * @param {any} userId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(userId: any, acceptLanguage?: any, options?: any): AxiosPromise<MessageOutSchema> {
            return localVarFp.deleteById(userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Get By Id
         * @param {any} userId 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(userId: any, acceptLanguage?: any, options?: any): AxiosPromise<UserOutSchema> {
            return localVarFp.getById(userId, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user by id.  Please provide:   - **Request body**  data for updating user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Введено некоректний номер телефону           2) Ім\'я та прізвище повинно починатися з великої літери            (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
         * @summary Update By Id
         * @param {any} userId 
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {any} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateById(userId: any, userUpdateSchema: UserUpdateSchema, acceptLanguage?: any, options?: any): AxiosPromise<UserOutSchema> {
            return localVarFp.updateById(userId, userUpdateSchema, acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datatable operation in UsersApi.
 * @export
 * @interface UsersApiDatatableRequest
 */
export interface UsersApiDatatableRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiDatatable
     */
    readonly searchLine?: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiDatatable
     */
    readonly sort?: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiDatatable
     */
    readonly direction?: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiDatatable
     */
    readonly page?: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiDatatable
     */
    readonly pageSize?: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiDatatable
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for deleteById operation in UsersApi.
 * @export
 * @interface UsersApiDeleteByIdRequest
 */
export interface UsersApiDeleteByIdRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiDeleteById
     */
    readonly userId: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiDeleteById
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for getById operation in UsersApi.
 * @export
 * @interface UsersApiGetByIdRequest
 */
export interface UsersApiGetByIdRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiGetById
     */
    readonly userId: any

    /**
     * 
     * @type {any}
     * @memberof UsersApiGetById
     */
    readonly acceptLanguage?: any
}

/**
 * Request parameters for updateById operation in UsersApi.
 * @export
 * @interface UsersApiUpdateByIdRequest
 */
export interface UsersApiUpdateByIdRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiUpdateById
     */
    readonly userId: any

    /**
     * 
     * @type {UserUpdateSchema}
     * @memberof UsersApiUpdateById
     */
    readonly userUpdateSchema: UserUpdateSchema

    /**
     * 
     * @type {any}
     * @memberof UsersApiUpdateById
     */
    readonly acceptLanguage?: any
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Endpoint gets all users.  Makes pagination, search and sorting of records.  Please provide:  - **page**  number of page we want to get  - **page_size**  length of records per page  - **search_line**  helps to find rows which contains search line  - **sort**  define by which field sort rows  - **direction**  determines in which direction to sort  Returns:   - **200**: Success response with the data.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Datatable
     * @param {UsersApiDatatableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public datatable(requestParameters: UsersApiDatatableRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).datatable(requestParameters.searchLine, requestParameters.sort, requestParameters.direction, requestParameters.page, requestParameters.pageSize, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Delete By Id
     * @param {UsersApiDeleteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteById(requestParameters: UsersApiDeleteByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteById(requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new user.  Please provide:   - **Request body**  data for registration new user  Returns:   - **200**: Success response with the data.   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Get By Id
     * @param {UsersApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getById(requestParameters: UsersApiGetByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getById(requestParameters.userId, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user by id.  Please provide:   - **Request body**  data for updating user  Returns:   - **200**: Success response with the data.   - **403**: Error: Forbidden.       Причини:           1) Введено некоректний номер телефону           2) Ім\'я та прізвище повинно починатися з великої літери            (наступні маленькі), доступна кирилиця,            доступні спецсимволи(\'-)   - **404**: Error: Conflict.       Причини:           1) Не знайдено: немає збігів користувачів            на заданному запиті.   - **422**: Error: Unprocessable Entity.   - **500**: Internal server error if an unexpected error occurs.
     * @summary Update By Id
     * @param {UsersApiUpdateByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateById(requestParameters: UsersApiUpdateByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateById(requestParameters.userId, requestParameters.userUpdateSchema, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


